<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>怀府小阁</title>
    <link>http://blog.huaifufeng.com/</link>
    <description>Recent content on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 12 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Git专业笔记（二十一）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-21.html</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-21.html</guid>
      <description>.mailmap文件 按别名合并贡献者以在短日志中显示提交计数 当贡献者从不同的机器或操作系统添加到一个项目中时，他们可能会为此使用不同的电子邮件或名称，这将分割贡献者列表和统计信息。
git shortlog -sn命令可以获取贡献者的列表和他们各自的提交数量，具体的结果像下面这样：
Patrick Rothfuss 871 Elizabeth Moon 762 E. Moon 184 Rothfuss, Patrick 90  可以通过提供包含电子邮件映射的纯文本文件.mailmap来调整此碎片/解除关联。
一行中列出的所有名称和电子邮件地址将分别与第一个命名实体关联。
像上面的例子，一个map邮件像下面这样：
Patrick Rothfuss &amp;lt;fussy@kingkiller.com&amp;gt; Rothfuss, Patrick &amp;lt;fussy@kingkiller.com&amp;gt; Elizabeth Moon &amp;lt;emoon@marines.mil&amp;gt; E. Moon &amp;lt;emoon@scifi.org&amp;gt;  如果这个文件在项目的根目录，运行git shortlog -sn命令将会返回缩减之后的结果：
Patrick Rothfuss 961 Elizabeth Moon 946  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-20.html</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-20.html</guid>
      <description>.gitattributes文件 自动行结束符标准化 在项目的更目录创建.gitattributes文件，里面添加下面的内容：
* text=auto  这将导致所有文本文件（由Git标识的）使用LF提交，但根据操作系统的不同默认检出合适的格式。
这等价于core.autocrlf配置项使用下面的配置：
 Linux/macOS里面是input Windows里面是true  识别二进制文件 Git非常擅长识别二进制文件，但是你可以指明哪些文件时二进制的。在项目的根目录创建.gitattributes文件，并添加下面的配置：
*.png binary  binary是内建的宏命令，等价于-diff -merge -text。
.gitattributes模板 如果你确定你的.gitattributes文件是否少了某些规则，或者你只是想给你的项目添加一个通用的配置，你可以在下面的地址中选择或生成一个.gitattributes文件：
 https://gitattributes.io/ https://github.com/alexkaratarakis/gitattributes  进制行结束符标准化 在项目的根目录创建.gitattributes文件，并在里面添加：
* -text  这个配置等价于下面的配置core.autocrlf = false。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十四)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-14.html</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-14.html</guid>
      <description>函数 带参数函数 在helloJohn.sh文件里面有下面的代码：
#!/bin/bash greet() { local name=&amp;quot;$1&amp;quot; echo &amp;quot;Hello, $name&amp;quot; } greet &amp;quot;John Doe&amp;quot;  执行这个文件：
$ bash helloJohn.sh Hello, John Doe   如果你没有修改参数，可以不用把这个参数放到本地变量中，可以直接使用`echo &amp;ldquo;Hello, $1&amp;rdquo;
 你可以在函数中使用$1，$2，$3等等的变量访问函数的参数。
   注意：对于超过9个的参数，使用$10是没有用的，因为这将被解析成为$10，所以你需要使用${10}、${11}这样的变量。
  在函数中，$@引用所有的参数：   #!/bin/bash foo() { echo &amp;quot;$@&amp;quot; } foo 1 2 3 # output =&amp;gt; 1 2 3   注意：你应该像这里展示的一样，在$@周围使用双引号。
 省略引号将导致shell扩展通配符（即使用户为避免这种情况而专门引用通配符），并且通常会引入不受欢迎的行为，甚至潜在的安全问题。
 foo &amp;quot;string with spaces;&amp;quot; &#39;$HOME&#39; &amp;quot;*&amp;quot; # output =&amp;gt; string with spaces; $HOME *   想要使用默认值的话，用${1:-default_val}的格式：   #!</description>
    </item>
    
    <item>
      <title>Git专业笔记（十九）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-19.html</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-19.html</guid>
      <description>Git清理    Parameter Details     -d 除了未追踪的文件外，删除未追踪的文件夹。如果未追踪的文件夹由不同的Git仓库管理，默认是不删除的。如果你一定要删除，使用两次-f选项。   -f,&amp;ndash;force 如果Git的配置clean. requireForce配置为false，Git将不会删除任何文件或目录，除了提供-f，-n或-i选项。除非给出第二个-f，否则Git将拒绝删除有.git子目录的目录或文件。   -i,&amp;ndash;interactive 交互式操作删除每个文件   -n,&amp;ndash;dry-run 只显示将要被删除的文件列表，而不实际删除这些内容   -q,&amp;ndash;quiet 只显示删除出错的文件，不显示成功的文件    交互式清理 git clean -i  打印出将要被清理的文件，使用下面的命令进行确认：
Would remove the following items: folder/file1.py folder/file2.py *** Commands *** 1: clean 2: filter by pattern 3: select by numbers 4: ask each 5: quit 6: help What now&amp;gt;  交互式选项-i可以和其他的选项-X，-d一起添加。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十三)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-13.html</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-13.html</guid>
      <description>关联数组 操作关联数组 以下代码段显示了所有需要的用法：
#!/usr/bin/env bash declare -A assoc_array=([key_string]=value \ [one]=&amp;quot;something&amp;quot; \ [two]=&amp;quot;another thing&amp;quot; \ [ three ]=&#39;mind the blanks!&#39; \ [ &amp;quot; four&amp;quot; ]=&#39;count the blanks of this key later!&#39; \ [IMPORTANT]=&#39;SPACES DO ADD UP!!!&#39; \ [1]=&#39;there are no integers!&#39; \ [info]=&amp;quot;to avoid history expansion &amp;quot; \ [info2]=&amp;quot;quote exclamation mark with single quotes&amp;quot; \ ) echo # just a blank line echo now here are the values of assoc_array: echo ${assoc_array[@]} echo not that useful, echo # just a blank line echo this is better: declare -p assoc_array # -p == print echo have a close look at the spaces above\!</description>
    </item>
    
    <item>
      <title>Git专业笔记（十八）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-18.html</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-18.html</guid>
      <description>恢复 恢复reset操作 使用Git，你总是（几乎）可以把时钟倒转。
不要害怕尝试重写历史的命令。Git默认不会删除你90天内的提交，在此期间你可以使用reflog轻松的恢复这些修改：
$ git reset @~3 # go back 3 commits $ git reflog c4f708b HEAD@{0}: reset: moving to @~3 2c52489 HEAD@{1}: commit: more changes 4a5246d HEAD@{2}: commit: make important changes e8571e4 HEAD@{3}: commit: make some changes ... earlier commits ... $ git reset 2c52489 ... and you&#39;re back where you started  *注意像--hard和—force这样的选项：他们会丢弃修改
*另外，避免在协助的分支上面修改提交历史。
恢复stash 获取你在执行git stash命令之后你最新的暂存修改，使用下面命令：
git stash apply  查看你暂存的信息列表：
git stash list  你可以获取像下面这样的修改：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十二)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-12.html</link>
      <pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-12.html</guid>
      <description>数组 数组赋值 列表赋值 如果你熟悉Perl，C或者Java的话，你可能会认为Bash使用逗号来分隔数组的元素，然而不是这样的，Bash使用空格来分隔元素：
# Perl中的数组 my @array = (1, 2, 3, 4); #Bash中的数组 array=(1 2 3 4)  使用新元素创建数组：
array=(&#39;first element&#39; &#39;second element&#39; &#39;third element&#39;)  下标赋值 使用明确的元素索引创建一个数组：
array=([3]=&#39;fourth element&#39; [4]=&#39;fifth element&#39;)  索引赋值 array[0]=&#39;first element&#39; array[1]=&#39;second element&#39;  关联数组 Version&amp;gt;= 4.0
decalare -A array array[first]=&#39;First element&#39; array[second]=&#39;Second elemet&#39;  动态赋值 从其他命令的输出结果创建一个数组，例如使用seq获取1到10的值：
array=(`seq 1 10`)  从脚本的输入参数赋值给数组：
array=(&amp;quot;$@&amp;quot;)  使用循环赋值：
while read -r; do #array+=(&amp;quot;$REPLY&amp;quot;) #数组追加 array[$i]=&amp;quot;$REPLY&amp;quot; #索引赋值 let i++ #索引增加 done &amp;lt; &amp;lt;(seq 1 10) #?</description>
    </item>
    
    <item>
      <title>Git专业笔记（十七）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-17.html</link>
      <pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-17.html</guid>
      <description>随意选取    Parameter Details     -e,&amp;ndash;edit 选择这个选项，使用git cherry-pick命令允许你在提交信息之前编辑提交信息   -x 记录提交时，在原始提交消息中附加一行（cherry picked from commit&amp;hellip;），以指示从哪个提交中挑选出这个更改。这个只适用于没有冲突的选取。   &amp;ndash;ff 如果当前的HEAD和cherry的提交的父提交同级，将会执行此提交的快进。   &amp;ndash;continue 使用.git/sequencer里面的信息继续进行当前的操作。可以在解决失败的挑选或恢复中的冲突后继续使用   &amp;ndash;quit 忘记当前的操作。在选取或恢复失败后，可以用来清除sequencer的信息   &amp;ndash;abort 取消当前操作，恢复之前的状态    一个随意选取获取提交中引入的补丁，并尝试在您当前所在的分支上重新应用它。
Source：Git SCM Book
从一个分支复制提交到另一个分支 git cherry-pick &amp;lt;commit-hash&amp;gt;会应用另一个分支上的已经存在的提交修改，将会记录一个新的修改。实际上，你可以把提交从分支复制到另一个分支。
已经有下面的提交树(source)：
dd2e86 - 946992 - 9143a9 - a6fd86 - 5a6057 [master] \ 76cada - 62ecb3 - b886a0 [feature]  我们想把b886a0这个分支的修改复制到master上（5a6057之上）：
我们使用下面的命令：
 git checkout master git cherry-pick b886a0  下面我们的提交树就变成下面这样：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十一)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-11.html</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-11.html</guid>
      <description>true，false和：命令 无限循环 while true; do echo ok done  或者
while :; do echo ok done  或者
until false; do echo ok done  函数返回 function positive() { return 0 } function negative() { return 1 }  一直或从不执行的代码 if true; then echo Always executed fi if false; then echo Never executed fi  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（十六）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-16.html</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-16.html</guid>
      <description>压缩 不使用rebase压缩提交 如果你想把之前的x个提交压缩到一个提交，你可以使用下面的命令：
$ git reset --soft HEAD~x $ git commit  这里，你可以替换x为你想要压缩到一个提交的多个提交的数量。
请记住这将会创建一个新的提交，基本上会丢掉之前x个提交包含的提交人，提交信息和提交日期。你可能需要首先复制粘贴现有的提交消息。
merge时压缩提交 你可以使用git merge —squash命令把这个分支的修改压缩到一个提交。并不是实际的提交被创建了。
 git merge --squash &amp;lt;branch&amp;gt; git commit  这或多或少相当于使用git reset命令，但当合并更改具有符号名时更方便。比较：
git checkout &amp;lt;branch&amp;gt; git reset --soft $(git merge-base master &amp;lt;branch&amp;gt;) git commit  rebase时压缩提交 在git rebase命令执行的时候可以压缩多个提交。建议您在尝试以这种方式压缩提交之前了解rebase命令。
 确定要从哪个提交中rebase，并注意其提交的hash值。
 执行git rebase -i [commit hash]
  或者，你可以使用HEAD~4来代替提交的hash值，来查看最新的提交和最新之前4个提交
 在运行这个命令打开的编辑器中，选择哪些提交你想要合并。替换这些行之前的pick为squash来吧这些提交压缩的签名的提交中。
 在选择了压缩的提交之后，你需要编辑提交的信息
  查看提交并且决定哪些提交要rebase:
&amp;gt; git log --oneline 612f2f7 This commit should not be squashed d84b05d This commit should be squashed ac60234 Yet another commit 36d15de Rebase from here 17692d1 Did some more stuff e647334 Another Commit 2e30df6 Initial commit &amp;gt; git rebase -i 36d15de  这时你选择的编辑器就会打开，在这里你可以描述你想要这些提交做什么。Git在注释中提供了帮助信息。如果你退出了这个编辑器，什么都不会发生，因为每个提交都会保持和之前一样的顺序。在这个例子中，我们应用下面的命令：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-10.html</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-10.html</guid>
      <description>控制结构    Parameter to [ or test Details     File Operators Details   -e &amp;ldquo;$file&amp;rdquo; 如果文件存在，返回true   -d &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个目录的话，返回true   -f &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个普通文件的话，返回true   -h &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个符号链接的话，返回true   String Comparators Details   -z &amp;ldquo;$str&amp;rdquo; 字符串长度为0时为true   -n &amp;ldquo;$str&amp;rdquo; 字符串长度不为0时为true   &amp;rdquo;$str&amp;rdquo; = &amp;ldquo;$str2&amp;rdquo; 如果字符串$str等于字符串$str2。对整数是不合适的，虽然可以工作，但是结果可能不符合预期。   &amp;rdquo;$str&amp;rdquo; != &amp;ldquo;$str2&amp;rdquo; 如果字符串$str不等于$str2时返回true   Integer Comparators Details   &amp;rdquo;$int1&amp;rdquo; -eq &amp;ldquo;$int2&amp;rdquo; 如果整数相等返回true   &amp;rdquo;$int1&amp;rdquo; -ne &amp;ldquo;$int2&amp;rdquo; 如果整数不相等返回true   &amp;rdquo;$int1&amp;rdquo; -gt &amp;ldquo;$int2&amp;rdquo; 如果整数$int1大于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -ge &amp;ldquo;$int2&amp;rdquo; 如果整数$int1大于等于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -lt &amp;ldquo;$int2&amp;rdquo; 如果整数$int1小于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -le &amp;ldquo;$int2&amp;rdquo; 如果整数$int1小于等于$int2返回true    命令列表的条件执行 如何使用命令列表的条件执行 任何内建的命令、表达式或函数，以及外部的命令或脚本都可以使用&amp;amp;&amp;amp;或||运算符有条件的执行。</description>
    </item>
    
    <item>
      <title>Git专业笔记（十五）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-15.html</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-15.html</guid>
      <description>Rev-List    Parameter Detals     &amp;ndash;online 将提交显示为带有标题的单行。    列出在master不在远端master提交 git rev-list --oneline master ^origin/master  git rev-list命令会列出在一个分支不在另一个分支的提交。当您试图弄清楚代码是否已合并到分支中时，它是一个很好的工具。
 使用--oneline选项显示每个提交的标题 ^操作符会在列表中过滤指定的分支 如果需要，可以传递两个以上的分支。git rev-list foo bar ^baz将会列出foo和bar的提交，不包括baz。  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(九)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-9.html</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-9.html</guid>
      <description>重定向    Parameter Details     内部文件标识 整形   重定向 &amp;gt;或&amp;lt;或&amp;lt;&amp;gt;   外部文件标识或路径 文件标识或路径后面加&amp;amp;    重定向标准输出 &amp;gt;重定向当前命令的标准输出（STDOUT）到一个文件或者另外的描述符。
下面的例子会把ls命令的标准输出，输出到一个文件file.txt：
$ ls &amp;gt;file.txt $ &amp;gt; file.txt ls  如果目标文件不存在的话，就会创建这个文件，否则就会重置这个文件。
默认的文件标识符是标准输出，或者没有提供的话就是1。下面的命令和之前的一样，只是指定了标准输出：
$ ls 1&amp;gt;file.txt  注意：重定向是执行的shell初始化的，而不是由执行的命令初始化的，因此在命令执行前，初始化工作就已经完成了。
追加 Vs 重置 重置 &amp;gt;  文件不存在创建指定文件 重置（删除文件内容） 向文件写入内容  $ echo &amp;quot;first line&amp;quot; &amp;gt; /tmp/lines $ echo &amp;quot;second line&amp;quot; &amp;gt; /tmp/lines $ cat /tmp/lines second line  追加 &amp;gt;&amp;gt;  不存在创建文件 追加文件（向文件末尾写入内容）  # Overwrite existing file $ echo &amp;quot;first line&amp;quot; &amp;gt; /tmp/lines # Append a second line $ echo &amp;quot;second line&amp;quot; &amp;gt;&amp;gt; /tmp/lines $ cat /tmp/lines first line second line  重定向到STDOUT和STDERR 文件标识符0和1是指针。我们通过重定向更改文件描述符指向的内容。&amp;gt;/dev/null意味着1指向/dev/null。</description>
    </item>
    
    <item>
      <title>Git专业笔记（十四）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-14.html</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-14.html</guid>
      <description>分支    Parameter Detals     -d,&amp;ndash;delete 删除分支。这个分支必须合并到它的远端分支，如果设置了--track或--set-upstream的话，就需要在HEAD中   -D --delete --force强制删除的简称   -m,&amp;ndash;move 移动/重命名分支和相应的reflog   -M --move —force命令的简称   -r,&amp;ndash;remotes 列出或删除（使用-d）远端追踪的分支   -a,&amp;ndash;all 列出远端追踪分支和本地分支   &amp;ndash;list 激活列表模式。git branch &amp;lt;pattern&amp;gt;会试着新建分支。git branch -- list &amp;lt;pattern&amp;gt;列出所有匹配的分支   &amp;ndash;set-upstream 如果指定的分支不存在或者指定了--force参数，行为会和--track一样。否则在创建分支时设置像--track那样的配置，除了分支指向的地方没有改变    创建和切换新分支 创建一个新分支，并且保留在当前分支，执行下面的命令：
$ git branch &amp;lt;name&amp;gt;  通常，分支名称不得包含空格，并且符合列出的这里列出的其他规范。切换到已经存在的分支：
$ git checkout &amp;lt;name&amp;gt;  创建并且切换到新分支：
$ git checkout -b &amp;lt;name&amp;gt;  在指定索引创建一个分支，而不是在当前分支的最后提交（就是HEAD），可以使用下面任何一个命令：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(八)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-8.html</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-8.html</guid>
      <description>任务和进程 任务处理 创建任务 要创建一个任务，可以在命令后面添加&amp;amp;符号：
$ sleep 10 &amp;amp; [1] 20024  你也可以创建一个运行任务进程，可以按下Ctrl+z：
前后台进程 想要把一个后台进程获取到前台执行，可以使用fg命令加上%和进程数：
$ sleep 10 &amp;amp; [1] 20024 $ fg %1 sleep 10  现在你可以控制流程，想要把进程放回到后台运行的话，使用bg命令。因为终端的缓存，你需要使用Ctrl+z来终端进行。
$ sleep 10 ^Z [1]+ Stopped sleep 10 $ bg %1 [1]+ sleep 10 &amp;amp;  因为程序员的&amp;rdquo;惰性&amp;rdquo;，当只有一个进程或者想要处理列表中第一个进程，可以只适使用一个%。
$ sleep 10 &amp;amp; [1] 20024 $ fg % # to bring a process to foreground &#39;fg %&#39; is also working. sleep 10  或者：</description>
    </item>
    
    <item>
      <title>Git专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</guid>
      <description>配置    Parameter Detals     &amp;ndash;system 编辑为每个人使用的系统配置（在linux上，配置文件在$(prefix)/etc/gitconfig）   &amp;ndash;global 修改为你的每个仓库使用的全局配置文件（在linux上，配置文件在~/.gitconfig）   &amp;ndash;local 编辑指定仓库的配置文件，在你仓库的.git/config这个文件内，这个是默认的配置    配置编辑器 有多个方式来配置你commit和rebase的时候使用的编辑器：
 修改core.editor配置项：   $ git config --global core.editor nano   设置GIT_EDITOR环境变量：  举个例子，应用到一个命令：
 $ GIT_EDITOR=nano git commit  或者为终端执行的所有git命令。注意：直到你关闭了终端，这个配置才会生效：
 $ export GIT_EDITOR=nano   想要修改终端所有程序的编辑器，不仅仅是git，可以VISUAL或EDITOR环境变量（可以查看VISUAL vs EDITOR）:   $ export EDITOR=nano  注意：像上面一样，这个命令只会应用到当前的终端页面。你的shell通常会有一个配置文件，允许你永远的设置你的配置。（比如在bash时，可以添加上面的配置到~/.bashrc获取~/.bash_profile配置文件）。
一些文本编辑器（主要是GUI编辑器）一次只运行一个实例，如果你已经打开了一个实例，通常会退出。如果您的文本编辑器就是这种情况，Git将打印Aborting commit due to empty commit message。不允许你先编辑你的提交信息。如果你遇到了这种情况，检查你的编辑器文档是否有--wait这个配置项。允许你在文档关闭之前终端提交。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(七)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-7.html</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-7.html</guid>
      <description>别名 shell的别名是一种创建新命令或者在已有命令添加自己代码的方式。这和shell的函数有重叠的地方，但是shell函数更加通用，最好优先使用。
绕过别名 有时候你想临时绕过一个别名，而不是让别名不能使用了。下面就是一个例子：
alias ls=&#39;ls --color=auto&#39;  如果我们想要使用ls命令而不是ls别名，有下面几种方法：
 使用内建的command命令：command ls 使用命令的完整路径：/bin/ls 在命令名的任何地方添加一个\：\ls或l\s 把命令引用起来：&amp;rdquo;ls&amp;rdquo;或&amp;rsquo;ls&amp;rsquo;  创建别名 alias word=&#39;command&#39;  使用word就是运行命令command。任何追加到别名后面的参数就会添加到命令后面：
 alias myAlias=&#39;some command --with --options&#39; myAlias foo bar baz  上面的别名将会执行下面的命令：
some command --with --options foo bar baz  想要在一行中执行多个命令，可以使用&amp;amp;&amp;amp;连接多个命令字符串。李润：
alias print_things=&#39;echo &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;bar&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;baz&amp;quot;&#39;  删除别名 删除别名使用下面的命令：
unalias {alias_name}  例如：
# create an alias $ alias now=&#39;date&#39; # preview the alias $ now Thu Jul 21 17:11:25 CEST 2016 # remove the alias $ unalias now # test if removed $ now -bash: now: command not found  BASH_ALIASES 别名是一些命令的快捷方式，可以在交互式bash实例中定义和使用。这些别名被保存在一个名字文件BASH_ALIASES的关联数组文件。想要在脚本中使用这些别名的话，必须在交互式的shell中：</description>
    </item>
    
    <item>
      <title>Git专业笔记（十二）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-12.html</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-12.html</guid>
      <description>rebase    Parameter Detals     &amp;ndash;continue 在解决完merge冲突之后，重新开始执行rebase命令   &amp;ndash;abort 中断rebase操作之后，重新吧HEAD定位到原有分支上。如果在使用rebase命令的时候提供了分支名，HEAD将会被设置到这个分支上。否则HEAD将会重新设置到rebase操作开始的位置。   &amp;ndash;keep-empty 保留那些没有修改的提交   &amp;ndash;skip 重新开始rebase命令，忽略掉当前的补丁   -m,&amp;ndash;merge 在rebase的时候使用megre策略。当使用递归(默认)合并策略的话，这允许rebase知道上游的重命名。注意rebase合并的工作方式是从上游分支顶部的工作分支重放每个提交。因此，当合并冲突发生时，报告为我们的一方是迄今为止重新定位的系列，从上游开始，他们是工作分支。换句话说，双方交换。   &amp;ndash;stat 显示上次rebase之后，上游做的修改。这些不同将会有rebase.stat配置项控制   -x, &amp;ndash;exec command 执行交互式rebase，在每个提交和执行command之间暂停    本地分支rebase rebase在另外提交的顶部应用一系列的提交。rebase一个分支的话，首先切换到这个分支，然后rebase到另一个分支的顶部：
$ git checkout topic $ git rebase master  这会导致：
	A---B---C topic / D---E---F---G master  变成：
 A&#39;--B&#39;--C&#39; topic / D---E---F---G master  这些操作可以合并到一个简单命令上面：切换分支然后执行rebase命令</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-6.html</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-6.html</guid>
      <description>grep 找bar文件中的foo字符：
$ grep foo ~/Desktop/bar  寻找bar文件中不包含foo字符的其他字符串：
$ grep –v foo ~/Desktop/bar  显示所有以foo结尾的字符串：
$ grep &amp;quot;*foo&amp;quot; ~/Desktop/bar  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（十一）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-11.html</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-11.html</guid>
      <description>别名 简单别名 有两种方法来创建Git别名：
 编辑~/.gitconfig文件：   [alias] ci = commit st = status co = checkout   使用命令行：   git config --global alias.ci &amp;quot;commit&amp;quot; git config --global alias.st &amp;quot;status&amp;quot; git config --global alias.co &amp;quot;checkout&amp;quot;  在别名创建之后：
 git ci就是git commit git st就是git status git co就是git checkout  像正常的命令一样，别名也可以使用参数，例如：
 git ci -m &amp;quot;Commit message...&amp;quot; git co -b feature-42  显示搜索别名 你可以使用--get-regexp选项来列出所有的别名：
$ git config --get-regexp &#39;^alias\.&#39;  搜索别名 想要搜索别名的话，在.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-5.html</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-5.html</guid>
      <description>cat    Option Description     -n 输出行号   -v 使用^和M-代替不能打印的字符，除了LFD和TAB   -T 使用^I代替TAB   -E 使用$代替换行符(LF)   -e 和-vE一个含义   -b 输出非空行行号，覆盖-n   -A 等价于-vET   -s 抑制重复输出空行    拼接文件 这是cat命令的主要作用：
$ cat file1 file2 file3 &amp;gt; file_all  cat命令也用来把拼接文件的结果作为管道的一部分：
$ cat file1 file2 file3 | grep foo  输出文件内容 $ cat file.txt  将会输出文件的所有内容。</description>
    </item>
    
    <item>
      <title>Git专业笔记（十）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-10.html</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-10.html</guid>
      <description>提交    参数 详情     &amp;ndash;message, -m 包含在提交中的信息。这将会打开一个编辑器   &amp;ndash;amend 指定这个参数将会把当前暂存区的信息添加到之前的提交内。请注意，这将会修改之前的提交历史   &amp;ndash;no-edit 使用选择的提交信息但是不打开编辑器，例如：git commit --amend --no-edit追加提交到之前的提交上，并且不修改提交信息。   &amp;ndash;all, -a 提交包括未暂存的文件在内的修改   &amp;ndash;date 手动设置关联到这个提交的日期信息   &amp;ndash;only 只提交指定路径的信息。这将只会提交指定的文件   &amp;ndash;patch,-p 使用交互的补丁选择窗口来选择提交哪些修改   -S[keyid], -S &amp;ndash;gpg- sign[=keyid], -S &amp;ndash;no-gpg-sign Sign commit, GPG-sign commit, 取消 commit.gpgSign 配置变量   -n,&amp;ndash;no-verify 这个参数取消执行预提交和提交信息的钩子。详情看钩子    暂存提交修改 基础 在你修改了你的本地文件之后，在你准备提交这些修改之前，需要把文件暂存起来。
例如，如果你修改README.md和program.py这两文件：
$ git add README.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-4.html</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-4.html</guid>
      <description>文件列表    Option Description     -a, &amp;ndash;all 列出所有文件，包含.开头的文件   -A, &amp;ndash;almost-all 列出所有文件，处理.和..   -c 按修改时间排序文件   -d, &amp;ndash;directory 列出所有的目录   -h, &amp;ndash;human-readable 使用人可读的单位列出文件的大小（K, M等）   -H 和上面的参数一样，只是使用1000来代替1024   -l 显示文件的详细信息   -o 显示详细信息处理分组信息   -r, &amp;ndash;reverse 倒序显示文件内容   -s, &amp;ndash;size 显示文件的块大小   -S 以文件大小排序   &amp;ndash;sort=WORD 按照某个词排序（size，version，status等）。ps：mac没有这个选项   -t 按照修改时间排序   -u 按照访问时间排序   -v 按照版本排序   -1 每行返回一个文件    列出文件详情 ls命令的-l参数，打印文件长列表格式的详细信息。如果没有指定文件夹，默认列出当前文件夹的内容。</description>
    </item>
    
    <item>
      <title>Git专业笔记（九）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-9.html</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-9.html</guid>
      <description>submodule clone一个有子模块的仓库 当你克隆了一个有子模块的仓库时，你需要初始化和更新他们：
$ git clone --recursive https://github.com/username/repo.git  这将会克隆关联的子模块，并且把子模块放到合适的位置上面（包括子模块关联的子模块）。这个命令等价于在仓库克隆之后立即执行git submodule update --init --recursive这个命令。
更新子模块 如果一个子模块引用了另一个仓库中的子模块的特定提交。想要切换到所有引用子模块的特定状态的话，可以使用下面的命令：
$ git submodule update --recursive  有时候为了替换引用子模块当前的状态，你想要把本地米宽的分支切换到远端的最新状态。使用下面的命令可以把所有引用的子模块切换到远端最新的分支：
$ git submodule foreach git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;  或者使用默认的git pull参数：
$ git submodule foreach git pull  注意：这将只会更新本地工作区副本。如果一个子模块用这个命令更新了，他将会出现在git status命令的文件列表内。如果你想要把你的引用更新到最新的状态，你可以提交这些修改：
 git add &amp;lt;submodule_directory&amp;gt; git commit  如果你使用git pull的话，这写修改可能会造成合并冲突。你可以使用git pull —rebase来把修改到会到最新。大多数情况下这会减少出现冲突的次数。这也会把所有的分支pull到本地：
$ git submodule foreach git pull --rebase  想要把某个分支切换到最新的状态，可以使用：
$ git submodule update --remote &amp;lt;submodule_directory&amp;gt;  添加子模块 你可以把另外的Git仓库当做你自己项目的一个文件夹，使用Git来追踪：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-3.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-3.html</guid>
      <description>导航目录 绝对目录和相对目录 想要切换到一个绝对路径的目录，可以使用/开头的完整目录名称：
$ cd /home/username/project/abc  如果你想到达的目录在这个目录的下级目录，可以使用一个相对路径。例如，你当前在/home/username/project目录，如果想要到这个目录的abc子目录：
$ cd abc  如果你想到当前目录的上级目录，可以使用..符号。比如，如果你当前在/home/username/project/abc这个目录，现在想要到/home/username/project这个目录，可以使用下面的命令：
$ cd ..  这也可以称作“向上”目录。
到之前目录 在当前的shell中，你可以到你之前在的目录，而不用管这个目录在哪：
$ cd -  如果多次执行这个目录，你将会在当前目录和之前的目录之间切换。
home目录 默认的目录是home目录（$HOME，特别是/home/username），所以当没有带目录参数的执行cd命令的时候，将会直接到home目录：
$ cd  或者你可以更加明确的执行：
$ cd $HOME  home目录的简单符合是~，所以也可以这样执行：
$ cd ~  脚本目录 通常，有两种bash脚本：
 在当前目录执行的系统工具。 相对于自己目录修改文件的项目工具。  对第二中脚本来说，到的脚本所在的目录是非常有用的。这可以使用下面的命令：
$ cd &amp;quot;$(dirname &amp;quot;$(readlink -f &amp;quot;$0&amp;quot;)&amp;quot;)&amp;quot;  这个命令运行了3个命令：
 readlink -f &amp;quot;$0&amp;quot;获取当前脚本的目录。 dirname获取脚本的目录。 cd修改当前的目录到dirname返回的目录。  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-2.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-2.html</guid>
      <description>脚本shebang 环境shebang 想要使用bash命令执行一个脚本文件，可以使用可以执行的env来指定PATH环境变量中的bash命令。脚本文件的第一行需要是：带有bash参数的绝对路径的env可执行文件：
#!/usr/bin/env bash  只有在使用下面这样的方式执行脚本的时候，shebang里面的env命令才会被解析：
script.sh  当然，这个脚本必须有执行权限。
当直接指明bash解析器来执行脚本的时候，这个shebang是被忽略的：
bash script.sh  直接shebang 想要用bash来执行一个脚本，也可以定义一个可以执行的bash路径：
#!/bin/bash  当直接执行脚本的时候，shebang将会被解析并执行：
./script.sh  脚本需要可以执行的权限。
当bash解析器直接指明来执行这个脚本的时候，这个shebang不会被执行：
bash script.sh  其他的shebang 操作系统内核能识别的有两种程序：一种是用ELF (ExtenableLoadableFormat)头声明的二进制程序，通常是编译生成的；另一种就是各种的脚本。
如果一个文件的第一行以#!开头，下一个字符串必须是一个解析器的路径。如果操作系统内核读到了这行，会调用路径指向的解析器，然后把后面的字符都传给这个解析器作为参数。如果没有文件焦作something或者wrong：
#!/bin/bash something wrong echo &amp;quot;This line never gets printed&amp;quot;  bash执行的时候，参数something wrong是不存在的。脚本文件的名称也会被添加。下面看下直接声明echo命令的shebang：
#&amp;quot;/bin/echo something wrong # and now call this script named &amp;quot;thisscript&amp;quot; like so: # thisscript one two # the output will be: something wrong ./thisscript one two  一些想awk的程序就用这种技术来运行长时间留在硬盘上的脚本。</description>
    </item>
    
    <item>
      <title>Git专业笔记（八）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-8.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-8.html</guid>
      <description>merge    parameter Details     -m 在merge提交里使用的信息   -v 显示详细的输出   &amp;ndash;abort 中断把文件恢复到之前的状态   &amp;ndash;ff-only 当一个merge提交被要求的话立即中断   &amp;ndash;no-ff 强制创建一个merge提交，即使它不是强制的   &amp;ndash;no-commit 假装merge失败了，允许去检查和调整这个结果   &amp;ndash;stat merge合并之后，展示状态的不同   -n/&amp;ndash;no-stat 不显示状态的不同   &amp;ndash;sqaush 允许对这个分支的merge修改做一个单独的提交    自动合并 当两个分支的提交不冲突的话，Git可以自动的合并他们：
~/Stack Overflow(branch:master) » git merge another_branch Auto-merging file_a Merge made by the &#39;recursive&#39; strategy. file_a | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)  找到没有merge提交的分支 有时候你有一些已经把修改merge到master上的分支。这将找出来所有不是master分支并且和master分支没有区别提交的分支。这用来查找在PR合并到master之后，没有删除的分支非常有帮助：</description>
    </item>
    
    <item>
      <title>Git专业笔记（七）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-7.html</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-7.html</guid>
      <description>撤销修改 返回前一个提交 返回前一个提交，首先使用git log找到前一个提交的hash值。然后要临时返回那个提交的话，使用下面的命令：
$ git checkout 789abcd  这将返回hash值为789abcd的提交。现在你可以在不影响你的HEAD的情况下，在这个老提交的基础上建立新的提交。你可以使用branch或checkout -b命令来建立一个分支，然后把这些修改放到这个分支上面。
使用下面的命令返回上一个提交的话，会保留之前的修改：
$ git reset --soft 789abcd  去返回上一个提交，可以使用下面的命令：
$ git reset --soft HEAD~  想要抛弃某个提交之后的修改，可以使用下面的命令：
$ git reset --hard 789abcd  想要抛弃上一个提交之后的修改，使用下面的命令：
$ git reset --hard HEAD~  注意：你可以使用reflog和reset恢复丢弃的提交，但是没有提交的修改是无法恢复的。
撤销修改 撤消对工作副本中文件或目录的更改。
$ git checkout -- file.txt  下面的命令将会递归的应用到当前目录的所有文件和文件夹上面，他将撤销工作区副本的所有修改：
$ git checkout .  想要撤销部分修改的话，可以使用---patch选项。这样对每个修改，你都将被询问，是要撤销还是保留：
$ git checkout --patch -- dir  想要撤销添加到index的修改，使用下面的命令：
$ git reset --hard  如果没有—hard选项的话，这将会执行一个软reset命令。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(一)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-1.html</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-1.html</guid>
      <description>开始Bash Hello World 交互shell Bash shell通常是使用其交互模式：这允许你输入和修改命令，当你按下Return键的时候，就会执行这些命令。大多数基于Unix和类Unix的操作系统都会使用Bash作为它们默认的shell（特别是Linux和macOS）。当终端打开的时候会自动的进入交互模式的Bash shell。
使用下面的方式输出一个Hello World：
$ echo &amp;quot;Hello World&amp;quot; #&amp;gt; Hello World # Output Example  注意点：
 你可以在终端中通过修改shell的名称来修改shell。比如：sh，bash等等 echo是Bash内建的一个命令，会把它接收到的参数输出到标准输出中。默认它会在输出的后面输出一个新行。  非交互shell Bash shell也可以在脚本中被按照非交互模式运行，当shell不需要人工操作时。交互的行为和非交互的行为都是唯一的：Unix V7 Bourne shell和其他的衍生shell 的一项重要设计原则。因此，任何在命令行中可以执行的命令都可以放到脚本中重复使用。
下面的步骤创建了一个Hello World脚本：
 创建一个叫hello-world.sh的文件。   $ touch hello-world.sh   为文件添加执行权限：chmod +x hello-world.sh
 添加下面的代码：
   #!/bin/bash echo &amp;quot;Hello World&amp;quot;  第一行：脚本的第一行必须以字符串#!开始，这被叫做 shebang。这个shebang通知操作系统去允许/bin/bash，并且把文件的路径作为参数传递给这个命令。像：/bin/bash hello-world.sh
第二行：使用echo命令把Hello world输出到标准输出。
 在命令行中执行hello-world.sh这个脚本可以使用下面的人一个方式：
 ./hello-world.sh 最常用的方法，也是最推荐的方法。 /bin/bash hello-world.sh bash hello-world.</description>
    </item>
    
    <item>
      <title>Git专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-6.html</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-6.html</guid>
      <description>git diff    parameter details     -p, -u, &amp;ndash;patch 生成补丁。   -s, &amp;ndash;no-patch 取消差异的输出。对于像git diff这样显示补丁的命令非常有用。或者用来取消—patch选项的效果。   &amp;ndash;raw 输出原生格式信息的文件差异信息。   &amp;ndash;diff-algorithm= 选择差异对比的算法。可选的算法有：myers，minimal，patience，histogram   &amp;ndash;summary 输出一个压缩的扩展头信息，包括（创建，重命名和模式修改等）   &amp;ndash;name-only 只展示修改文件的名称   &amp;ndash;name-status 展示已修改文件的名称和状态，常见的状态有：M 修改 A 添加 D 删除   &amp;ndash;check 如果修改出现了标记冲突和空白错误会发出警告。被视作空白错误的信息是由core.whitespace控制的。默认情况下，尾随空格（包括仅由空格组成的行）和空格字符（在行的初始缩进内紧跟制表符）被视为空格错误。如果出现问题就会以非0的退出码退出。不和--exit-code兼容。   &amp;ndash;full-index 当想产生补丁格式的输出时，取代最开始的几个字符，将会把完整的pre-和post-image二进制对象显示在索引行中。   &amp;ndash;binary 除了像--full-index外，还会输出一个可以用于git apply命令的二进制差异文件。   -a, &amp;ndash;text 把所有的文件视作文本。   &amp;ndash;color 设置颜色模式：如果要将diff设置为较小并保持git的颜色，请使用--color=always    展示工作区差异 $ git diff  这将展示当前分支未暂存的修改和之前的提交的差异。这只展示相对于索引的差异，也就是只展示你可以在下次提交的，但是还没有提交的修改。想要添加这些修改，可以使用git add。</description>
    </item>
    
    <item>
      <title>Git专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-5.html</link>
      <pubDate>Sun, 27 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-5.html</guid>
      <description>忽略文件文件夹 这章的主题是介绍怎么避免把不想要的文件（或者文件的修改）添加到Git仓库内。有好几种方式可以实现这个目的：全局或者本地的.gitignore ，.git/exclude，git update-index --assume-unchanged，git update-index --skip-tree。但是请记住Git是用来管理内容的：忽略实际忽略的是文件夹的内容。一个空的文件夹将会被自动忽略，因为它不能不添加到仓库内。
.gitignore 你可以让Git通过添加一个或多个.gitignore文件来忽略某些文件或者文件夹，即不把这些内容通过Git来追踪。
在一些软件项目中，.gitignore文件会包含一列在构建程序或运行时产生的文件或文件夹。在.gitignore中，可能包含指向下面内容的名称或路径：
 临时资源，像缓存，log文件，编译文件等 不应该分享给其他人的配置文件 包含密码、秘钥、证书等隐秘信息的文件  当在顶层目录创建这个文件时，这些规则将会应用到这个仓库所有的文件和子目录。当在子目录创建时，这些规则只会应用到这个目录和这个目录子目录的文件中。
当一个文件或目录被忽略了，这代表：
 不会被Git库追踪。 不会再git status和git diff命令中输出处理。 不会通过git add -A命令暂存这些内容。  在一些特殊的场景下，你需要把已经追踪的文件忽略掉，这时你要特别小心。可以查看下面章节：忽略已提交内容。
例子： 下面是一些.gitignore中比较简单的例子，基于glob file patterns：
# Lines starting with `#` are comments. # Ignore files called &#39;file.ext&#39; file.ext # Comments can&#39;t be on the same line as rules! # The following line ignores files called &#39;file.ext # not a comment&#39; file.ext # not a comment # Ignoring files with full path.</description>
    </item>
    
    <item>
      <title>Git专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-4.html</link>
      <pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-4.html</guid>
      <description>暂存区 暂存所有文件 想要删除一个远端的分支：
$ git add -A  在Git 2.0+之后的版本
$ git add .  在版本2.x时，git add .命令将会添加当前目录及其子目录下的所有修改的文件。但是在1.x的版本，只会暂存新建或修改的文件，不会暂存删除的文件。
使用git add -A或者git add --all来存储所有修改的文件，不管在哪个版本都是有效的。
取消存储的修改文件 $ git reset &amp;lt;filePath&amp;gt;  添加大片修改 你可以看到大片的选项是怎么被存储的，通过使用patch选项：
$ git add -p  或者
$ git add --patch  这个命令将会打开一个交互界面，允许你查看修改，并且决定哪些内容去被存储起来：
Stage this hunk [y,n,q,a,d,/,s,e,?]?   y stage this hunk for the next commit n do not stage this hunk for the next commit q quit; do not stage this hunk or any of the remaining hunks a stage this hunk and all later hunks in the file d do not stage this hunk or any of the later hunks in the file g select a hunk to go to / search for a hunk matching the given regex j leave this hunk undecided, see next undecided hunk J leave this hunk undecided, see next hunk k leave this hunk undecided, see previous undecided hunk K leave this hunk undecided, see previous hunk s split the current hunk into smaller hunks e manually edit the current hunk ?</description>
    </item>
    
    <item>
      <title>Git专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-3.html</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-3.html</guid>
      <description>操作远端 删除远端分支 想要删除一个远端的分支：
$ git push [remote-name] --delete [branch-name]  或者
$ git push [remote-name] :[branch-name]  修改远端地址 查看已经存在的远端地址：
$ git remote -v # origin https://github.com/username/repo.git (fetch) # origin https://github.com/usernam/repo.git (push)  修改仓库的地址：
$ git remote set-url origin https://github.com/username/repo2.git # Change the &#39;origin&#39; remote&#39;s URL  查看验证新的远端地址：
$ git remote -v # origin https://github.com/username/repo2.git (fetch) # origin https://github.com/username/repo2.git (push)  远端列表 查看这个仓库关联的远端列表：
$ git remote  查看这个仓库关联的远端列表，包括这些远端的fetch和push的Url地址。
$ git remote --verbose  或者</description>
    </item>
    
    <item>
      <title>Git专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-2.html</link>
      <pubDate>Fri, 18 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-2.html</guid>
      <description>查看历史    Parameter Explanation     -q, &amp;ndash;quiet Quiet, suppresses diff output   &amp;ndash;source Shows source of commit   &amp;ndash;use-mailmap Use mail map file (changes user info for committing user)   &amp;ndash;decorate[=&amp;hellip;] Decorate options   &amp;ndash;L &amp;lt; n,m:file&amp;gt; Show log for specific range of lines in a file, counting from 1. Starts from line n, goes to line m. Also shows diff.</description>
    </item>
    
    <item>
      <title>Git专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-1.html</link>
      <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-1.html</guid>
      <description>开始学习Git 创建自己的项目，并添加、提交文件 首页在终端验证你是否已经安装有Git：
在所有的操作系统上，都可以使用下面的命令：
$ git --version  在类Unix系统还可以使用下面的命令：
$ which git  如果什么都没有返回，或者没有通过验证，这就表明你需要通过下载并运行安装程序，在你的系统上安装Git。查看Git官网，上面有特别详细和容易的安装教程。
安装完Git之后，在你真正的提交之前，还需要配置好你的名称和邮件地址。
一旦安装成功Git，你就可以到你希望进行版本管理的文件夹下，初始化一个空的Git仓库：
$ git init  这会创建一个隐藏的.git文件夹，用来存放Git工作需要的信息。
接下来检查下Git将把什么文件加入到仓库内，这是非常值得注意的，也是在添加、提交文件之前的必要操作：
$ git status  检查文件的列表，你可以告诉Git哪些文件你想进行版本的管理（避免将像密码这样的重要信息或者污染仓库的信息添加到Git仓库里面）：
$ git add &amp;lt;file/directory name #1&amp;gt; &amp;lt;file/directory name #2&amp;gt; &amp;lt; ... &amp;gt;  如果所有的文件你都想和能访问这个仓库的人分享，有一个简单的命令可以添加当前目录和当前目录子目录内的所有文件：
$ git add .  这将“暂存”所有的文件，等待将这些文件加入版本管理，准备在你的第一次提交中提交它们。
对于你不想添加到版本管理的文件，你可以在执行add之前命令创建一个名.gitignore的文件，并且填写里面的内容。
提交所有已经添加的文件，同时填写一个提交的注释信息：
$ git commit -m &amp;quot;Initial commit&amp;quot;  这使用提供的信息创建了一个新的提交。一个提交就像你整个项目的一个快照。现在你就可以把本地的文件push到远端的仓库内，如果有需要的时候，你可以重新返回这里。
如果你忽略了-m参数，你默认的编辑器将会打开，你可以在编辑器里面编辑并且保存提交信息。
添加远端仓库 想要添加一个新的远端仓库地址，你可以在你仓库所在的文件夹内，在终端内执行git remote add命令。
1. 一个远端的名称，比如```origin``` 2. 一个远端的URL地址，比如```https://&amp;lt;your-git-service-address&amp;gt;/user/repo.git``` ```shell $ git remote add origin https://&amp;lt;your-git-service-address&amp;gt;/owner/repository.</description>
    </item>
    
    <item>
      <title>Golang学习（二）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/go-learn-2.html</link>
      <pubDate>Sat, 12 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/go-learn-2.html</guid>
      <description>上一节简单介绍了Golang的基本含义和简单的例子，接下来就详细介绍一下使用Go开发需要的详细环境配置。主要是GOPATH等环境变量和一些很有效的工具。
环境配置 go语言一般需要设置三个环境变量：
 GOPATH：go的工作区，是我们代码的所在目录。 GOROOT：go的安装路径，即go的安装目录。不过在1.11之后已经不需要再配置这个路径了。 GOBIN：go生成的执行文件的目录，也不需要专门的配置，默认在GOPATH目录下的src/bin目录  GOPATH go语言的代码工作区目录，可以是一个目录，也可以是多个目录，go命令会按照多个目录的顺序依次搜索相应的目录，
GOPATH目录的基本结构如下，下面会有三个目录：
bin/ pkg/ src/   bin目录就是GOBIN默认对应的目录，存放编译后的可执行文件，一般不用单独在设置。 src是我们的代码目录文件，下面包含.go文件，就是go的源码文件。 pkg编译后的生成的静态库文件，和平台有关系，每个平台会有相应的目录。在linux下是扩展名为.a的文件。  使用go install会bin目录生成项目的执行文件，而go build会在当前目录生成项目的执行文件。
管理工具 我们自己在开发时，可能不同的项目会需要在不同版本的go下面执行，就需要在不同版本go下面进行切换，这里就介绍两款工具，方便我们管理不同版本的go；go的包管理工具
GVM 管理不同版本go的管理工具GVM。
安装 在终端执行下面的命令，因为我本地安装了oh-my-zsh，所以我这里就最开始是zsh，如果你本地是原生的bash，将zsh替换成bash就可以：
$ zsh &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) Cloning from https://github.com/moovweb/gvm.git to /Users/test/.gvm Created profile for existing install of Go at &amp;quot;/usr/local/Cellar/go/1.11.4/libexec&amp;quot; Installed GVM v1.0.22 Please restart your terminal session or to get started right away run `source /Users/test/.gvm/scripts/gvm`  出现如上的信息就代表安装成功了，在安装下面的提示执行如下命令，激活gvm的命令：</description>
    </item>
    
    <item>
      <title>Golang学习（一）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/go-learn-1.html</link>
      <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/go-learn-1.html</guid>
      <description>作为一个PHP程序员，最近因为兴趣和业务的需要(学习了一个东西，如果不使用的话，忘记的速度会非常快)，开始接触golang这门语言，这里做下学习的笔记，这里是学习的第一步，简单介绍一下golang的一些基本信息。
简介 golang是一门谷歌开发并开源，和C++，java，c等一样的类c语言；一门静态、编译型语言。
该语言起源于2007年，于2009年正式的发布，目前在TIBOE中排行到19位。在各个地区尤其是国内拥有大量的使用，包括京东，七牛，B站等都有使用。
专注安全 golang在保留了C++的大部分语法，移除了其中指针运算，运算符重载等特性，同时增加了GC等新特性，拥有不输于C++的性能，是一门类型安全、内存安全的编程语言。
统一格式 golang强制要求语言的格式，让每个人的代码格式都是一致的，也许有人会不习惯，但是我觉得相同的语言格式对于代码的一致性，更容易理解别人的代码。
原生协程 为了更好的利用分布式和多核的计算机，实现了goroutine来达到这个目标，使用channel作为goroutine通信的工具。原生支持协程。简单的一个go func就可以实现协程。
易于开发 虽然具备不输于C++的性能，但是去除了一些C++的不良特性，增加gc。对于开发者来说，不用再考虑那些疑惑的特性，不用考虑内存的申请，更加关注于程序自身。
快速编译 golang的编译速度非常快，整个标准库一般在20s以下，自己的库一般也就几s就可以了，比c的编译速度更快，减少开发者等待编译的时间。
WebAssembly golang和WebAssembly强强联合，加入WASM的大家庭，允许编写可以在浏览器运营的程序，然后使用JavaScript调用wasm的文件，处理需要运算的功能，虽然目前还比较简单，但是值得期待。
等等，特性还有很多，我这只是列出一些比较有特色的特性。
Hello World! 任何语言的第一步都是Hello World!，我们也从这里开始。
安装 这里就直接使用mac环境介绍了，其他环境自行百度。
使用mac开发的，一般都已经安装好HomeworkBrew了，这里就直接执行命令就可以：
$ brew install go  安装网络的不同，等待的时间也不一样长，在命令行输入如下命令，就可以确定是否安装成功了:
$ go version  当输出类似go version go1.11.4 darwin/amd64的信息就代表安装成功了。
go一般会安装到如下目录：/usr/local/Cellar/go，目录下面是不同版本的目录。同时，会在/usr/local/bin下生成一个指向刚才目录下某个版本的go执行命令，
代码 环境安装成功之后，只是编写Hello World 的话，在任何目录下都可以。我们就直接在自己的家目录下编写第一个文件吧。
使用vim在命令行打开hello.go文件，然后输入如下内容：
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;Hello World!&amp;quot;) }  然后保存文件。
想要执行一个go文件，很简单，直接使用go run filename就可以，比如要执行hello.go文件，我们可以：
$ go run hello.go Hello World!  这我们就执行成功了，输出了我们想要的Hello World！</description>
    </item>
    
    <item>
      <title>Hugo&#43;GitHub搭建自己的blog</title>
      <link>http://blog.huaifufeng.com/2019/01/post/hugo-first.html</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/hugo-first.html</guid>
      <description>2019年新的开始，新年第一天的首个工作就是把blog搭了起来，之后就要坚持做下去了，保证一周能有一篇有货的文章，这个也是给自己提的一个邀请，每周要学习至少一个知识点，可以分享的知识点。
这个blog是用hugo搭建的，因为最近在学习go语言，所以就挑选了这个以go语音实现的静态网站生成工具，在以后就要看下hugo的源码了，希望能够学习并升级这个工具。下面就介绍一下hugo+github搭建自己的blog。
环境搭建 这里涉及到两个环境的配置Hugo静态网站生成器和GitHub代码托管网站的配置，下面分别介绍两个环境的配置过程。
Hugo环境搭建 Hugo是一个用golang语言实现的一个静态网站生成器，不只是用来生成blog，还可以用来生成商城，信息网站等。它最主要的特性就是快，安全。这里就介绍下安装方法。
Hugo支持目前市面上的操作系统，包括：Mac，Windows，Linux，OpenBSD，FreeBSD。我这里用的Mac电脑，就介绍下Mac的安装，其他的环境可以到Hugo安装页面查看相应的安装步骤。
1、首先确定你的电脑是否安装有Homebrew，这是一个mac的安装包管理工具，可以用来安装软件。
brew --version  如果输出了版本号，说明你的电脑已经安装了这个软件，否则就需要执行下面的命令进行安装。
/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;  然后重新输入上面的命令进行安装。
2、使用Homebrew安装Hugo
brew install hugo  安装完毕之后使用下面的命令验证：
hugo version  获取到版本号说明安装成功。
3、然后就可以使用过hugo的命令来生成网站，生成页面了。
首先生成网址，先到达你存放网站信息的地方，使用下面的命令生成网站的根目录文件夹example(替换为你自己的项目目录)：
hugo new site example  生成网站的目录结构如下：
. ├── archetypes ├── assets ├── config.toml //网站的配置文件 ├── content //网站内容的原始文件 ├── data ├── layouts ├── static └── themes //网站的模板文件  其他的我们暂时不关心，目前用到的是content，themes，config.toml
首先需要把我们的项目变成一个git项目，才可以进行下面的操作：
git init git add . git commit -m &#39;init&#39;  Hugo目前已经有了一批的模板，只需要到这个地址，就可以找到需要的模板了，我这个blog就是从中使用的模板。使用下面的命令就可以把一个模板下载到本地：</description>
    </item>
    
    <item>
      <title></title>
      <link>http://blog.huaifufeng.com/some/localhost-127.0.0.1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/some/localhost-127.0.0.1/</guid>
      <description>localhost 127.0.0.1
Localhost
特殊的DNS域名，分配给计算机本身使用。
不经网卡传输，不受网络防火墙和网卡相关设置的限制
访问localhost使用本机用户的权限去访问
127.0.0.1
通过网卡传输，依赖网卡，受网络防火墙和网卡设置限制
访问127.0.0.1 使用本机通过网络去访问本机，涉及到网络用户权限
访问本地程序时，使用localhost比较好，不占用网卡和网络资源
/etc/hosts
配置 127.0.0.1 localhost
不配做 ping localhost 不通</description>
    </item>
    
  </channel>
</rss>