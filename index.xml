<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>怀府小阁</title>
    <link>http://blog.huaifufeng.com/</link>
    <description>Recent content on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 20 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL专业笔记(六十七)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-67.html</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-67.html</guid>
      <description>忘记密码恢复 1. 设置root密码，运行root使用socket和http访问 解决问题：access denied for user root using password YES Stop mySQL:
sudo systemctl stop mysql  重启MySQL，忽略授权表：
sudo mysqld_safe --skip-grant-tables  登录：
mysql -u root  在SQL shell中，查看用户是否存在：
SELECT User, password, plugin FROM mysql.user;  更新用户信息(plugin为null，表示启用所有的组件)：
update mysql.user set password=PASSWORD(&#39;mypassword&#39;), plugin=NULL WHERE User=&#39;root&#39;; exit;  在Unix的shell终止不带验证的MySQL，然后重启带有验证的MySQL：
sudo service mysql stop sudo service mysql start  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十六)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-66.html</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-66.html</guid>
      <description>MySQL5.7之后恢复和重置默认root密码 在MySQL5.7之后，我们不需要再按照MySQL的时候创建一个root账户或者提供一个root密码。默认当我们启动mysql服务器的时候，默认的密码会存储在mysqld.log文件中。我们需要使用这个密码登录，并且我们需要修改密码。
1. 当服务器初始启动时发生什么？ 假设服务器的数据目录是空的：
 服务器初始化 SSL整数和密钥文件生成在数据目录 validate_password组件安装和启用 超级用户&amp;rsquo;root&amp;rsquo;@&amp;lsquo;localhost&amp;rsquo;创建。设置root的密码并且存储在错误log文件内  2. 怎么使用默认密码修改root的密码？ 显示默认的&amp;rdquo;root&amp;rdquo;的密码：
shell&amp;gt; sudo grep &#39;temporary password&#39; /var/log/mysqld.log  修改root的密码，首先使用这个临时密码登录，然后设置用户的密码：
shell&amp;gt; mysql -uroot -p mysql&amp;gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass5!&#39;;  注意：MySQL的validate_password组件默认是现在的。这要求密码需要包含至少一个大写字母，一个小写字母，一个数字，一个特殊字符，并且密码的长度大于8个字符。
3. 当Unix的sock文件&amp;rdquo;/var/run/mysqld&amp;rdquo;不存在是，修改root密码 如果我忘记了密码，我将会获取一个错误：
$ mysql -u root -p 输出密码： ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)  我试着解决这个问题，首先确认服务的状态：
$ systemctl status mysql.service mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: en Active: active (running) since Thu 2017-06-08 14:31:33 IST; 38s ago  然后我使用mysqld_safe —skip-grant-tables &amp;amp;，但是我遇到一个错误：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十五)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-65.html</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-65.html</guid>
      <description>修改密码 1. Linux上面修改MySQL root的密码 修改MySQL root用户的密码：
步骤1：停止MySQL服务器
 在Ubuntu或Debian  sudo /etc/init.d/mysql stop   在CentOS，Fedora或Red Hat Enterprise Linux  sudo /etc/init.d/mysqld stop  步骤2：不带权限系统开启MySQL服务器
sudo mysqld_safe --skip-grant-tables &amp;amp;  或者，如果mysqld_safe不可用
sudo mysqld --skip-grant-tables &amp;amp;  步骤3：连接MySQL服务器
mysql -u root  步骤4：为root用户设置新密码
Version&amp;gt;5.7
FLUSH PRIVILEGES; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;; FLUSH PRIVILEGES; exit;  Version&amp;lt;=5.7
FLUSH PRIVILEGES; SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39;=PASSWORD(&#39;new_password&#39;); FLUSH PRIVILEGES; exit;  注意：ALTER USER的语法是在MySQL5.7.6提供的。
步骤5：重启MySQL服务器</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十四)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-64.html</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-64.html</guid>
      <description>GRANT确保安全 1. 最佳实践 限制root(或任何其他的超级用户)本地登录：
GRANT ... TO root@localhost ...  这个可以避免从其他服务器上面访问。你应该避免给太多人SUPER权限，并且他们应该意识到他们的责任。应用程序不应该拥有SUPER权限。
现在用户只能登录一个数据库：
GRANT ... ON dbnae.* ...  这样，这样黑进应用程序代码的人就无法通过dbname。这可以通过下面任何一种方法完善：
GRANT SELECT ON dbname.* ... -- 只读 GRANT ... ON dbname.tblname ... -- 只有一个表  只读还可以需要&amp;rdquo;安全&amp;rdquo;的配置：
GRANT SELECT, CREATE TEMPORARY TABLE ON dbname.* ... -- 只读  如你所见，没有绝对安全的方法。但是你可以做一些事情来减少被攻破的可能。(诚实的人也是这样。)
在极少数情况下，你可能需要营养程序执行一些只有root用户可以执行的操作。这可以通过&amp;rdquo;存储过程&amp;rdquo;来实现，这个具有安全定义符(并且root定义了)。这将只公开SP所做的，例如，可能是某个特定表上的一个特定操作。
2. 主机(user@主机) 这里&amp;rdquo;host&amp;rdquo;可以是一个主机名称或者IP地址。另外，它可能涉及到通配符。
GRANT SELECT ON db.* TO sam@&#39;my.domain.com&#39; IDENTIFIED BY &#39;foo&#39;;  例子：注意：这里通常是需要用引号包起来的
localhost -- the same machine as mysqld &#39;my.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十三)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-63.html</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-63.html</guid>
      <description>创建新用户 1. 创建MySQL用户 要创建新用户，我们需要 按照下面的步骤：
步骤1：使用root用户登录到MySQL：
$ mysql -u root -p  步骤2：我们可以看到MySQL的命令提示
mysql&amp;gt; CREATE USER &#39;my_new_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;test_password&#39;;  现在，我们成功创建了新用户，但是这个用户还没有任何权限。所以需要使用下面的命令给用户赋予相应的权限：
mysql&amp;gt; GRANT ALL PRIVILEGES ON my_db.* TO &#39;my_new_user&#39;@&#39;localhost&#39; identified by &#39;my_password&#39;;  2. 指定密码 最基本的方式是：
mysql&amp;gt; CREATE USER &#39;my_new_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;test_password&#39;;  但是，对于不建议使用明文编码密码的情况，直接使用PASSOWRD方法来获取密码的hash值：
mysql&amp;gt; select PASSWORD(&#39;test_password&#39;); -- returns *4414E26EDED6D661B5386813EBBA95065DBC4728 mysql&amp;gt; CREATE USER &#39;my_new_user&#39;@&#39;localhost&#39; IDENTIFIED BY PASSWORD &#39;*4414E26EDED6D661B5386813EBBA95065DBC4728&#39;;  3. 创建一个用户并且授予所有权限 grant all privileges on schema_name.* to &#39;new_user_name&#39;@&#39;%&#39; identified by &#39;newpassword&#39;;  注意：这可以用来创建新的root用户</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十二)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-62.html</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-62.html</guid>
      <description>SSL链接配置 1. 基于Debian系统的设置 这里假设MySQL已经安装了，并且用户拥有sudo权限。
生成CA和SSL key
确保OpenSSL和相关的库已经安装了：
apt-get -y install openssl apt-get -y install libssl-dev  接下来创建并进入一个SSL文件的目录：
mkdir /home/ubuntu/mysqlcerts cd /home/ubuntu/mysqlcerts  要生成密钥，请创建证书颁发机构(CA)以及密钥进行签名(自签名)：
openssl genrsa 2048 &amp;gt; ca-key.pem openssl req -new -x509 -nodes -days 3600 -key ca-key.pem -out ca.pem  每个提示里面输入的值不会影响配置项。下面创建服务器的密钥，使用之前创建的CA进行签名：
openssl req -newkey rsa:2048 -days 3600 -nodes -keyout server-key.pem -out server-req.pem openssl rsa -in server-key.pem -out server-key.pem openssl x509 -req -in server-req.pem -days 3600 -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out server-cert.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十一)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-61.html</link>
      <pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-61.html</guid>
      <description>服务器信息    参数 说明     GLOBAL 显示配置到整个服务器上面的变量。可选的   SESSION 显示只配置当前会有的变量。可选    1. SHOW VARIABLES 例子 获取所有的服务器变量，请在首选的(PHPMyAdmin或其他)窗口或mysql的命令行中运行下面的查询：
SHOW VARIABLES;  你可以像下面这样指定要获取全局变量还是当前会话的变量：
-- 会话变量 SHOW SESSION VARIABLES; -- 全局变量 SHOW GLOBALE VARIABLES;  像其他的SQL查询一样，你可以在这里使用LIKE等命令：
SHOW [GLOBAL | SESSION] VARIABLES LIKE &#39;max_join_size&#39;;  或者使用标识符：
SHOW [GLOBAL | SESSION] VARIABLES LIKE &amp;quot;%size%&amp;quot;;  你可以使用WHERE语句来筛选这个结果：
SHOW [GLOBAL | SESSION] VARIABLES WHERE VALUE &amp;gt; 0;  2. SHOW STATUS 例子 获取所有的服务器的状态，请在首选的(PHPMyAdmin或其他)窗口或mysql的命令行中运行下面的查询：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-60.html</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-60.html</guid>
      <description>一对多关系 一对多(1:M)的概念涉及行之间的连接，特别是一个表中的一行对应另一个表中的多行的情况。
1:M 是一种指向，也就是说查询1:M关系时，都可以使用&amp;rdquo;一&amp;rdquo;行在另一个表中找到&amp;rdquo;多&amp;rdquo;行，但不能使用单个&amp;rdquo;多&amp;rdquo;行找到多个&amp;rdquo;单&amp;rdquo;行。
1. Company表示例 假设有一个企业表，其中每个雇员都有一个经理，这个经理关联一个或多个雇员，并且每个雇员都只有一个经理。
两个表中有下面的数据：
EMPLOYEES EMP_ID FIRST_NAME LAST_NAME MGR_ID E01 Johnny Appleseed M02 E02 Erin Macklemore M01 E03 Colby Paperwork M03 E04 Ron Sonswan M01 MANAGERS MGR_ID FIRST_NAME LAST_NAME M01 Loud McQueen M02 Bossy Pants M03 Barrel Jones  2. 获取某个经理管理的雇员 SELECT e.emp_id, e.first_name, e.last_name FROM employees e JOIN managers m ON m.mgr_id=e.mgr_id WHERE m.mgr_id = &#39;M01&#39;; -- 结果 EMP_ID FIRST_NAME LAST_NAME E02 Erin Macklemore E04 Ron Sonswan  最后，对于我们查询的每个经理，我们将看到一个或多个员工返回。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十九)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-59.html</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-59.html</guid>
      <description>亚秒精度时间 1. 获取当前毫秒精度时间 SELECT NOW(3)  就是这样。
2. 获取当前时间的JavaScript时间戳格式 JavaScript时间戳基于古老的Unixtime_t数据类型，显示从1970-01-01 00:00:00 UTC开始的毫秒数。
下面的表达式获取当前时间的JavaScript时间戳整数（不管当前时区设置如何，这都会正确地执行此操作）。
ROUND(UNXI_TIMESTAMP(NOW(3)) * 1000.0, 0)  如果你的列中存储有TIMESTAMP格式的值，你可以使用UNIX_TIMESTAMP()方法获取时间的JavaScript时间戳整数。
SELECT ROUND(UNIX_TIMESTAMP(column) * 1000.0, 0)  如果你的列中包含DATETIME列，你可以将他们作为JavaScript时间戳检索。那么这些时间戳将会按照时区进行便宜。
3. 创建存储亚秒列的表 CREATE TABLE times ( dt DATETIME(3), ts TIMESTAMP(3) );  创建带有毫秒精度的日期/时间字段的表。
INSERT INTO times VALUES (NOW(3), NOW(3));  在表中插入一行包含NOW()毫秒精度的值：
INSERT INTO times VALUES (&#39;2015-01-01 16:34:00.123&#39;,&#39;2015-01-01 16:34:00.128&#39;);  插入指定的时间精度值。
注意：如果你想要插入高精度的值的话，需要使用NOW(3)而不是NOW()
4. 转换毫秒精度的日期和时间为文本值 %f是小数精度格式说明符，对DATE_FORMATE()来说。
SELECT DATE_FORMAT(NOW(3), &#39;%Y-%m-%d %H:%i:%s.%f&#39;)  这将会显示2016-11-19 09:52:53.248000这样小数的毫秒。因为我们使用的是NOW(3)，所以分数的最后3位是0。
5. 存储Javascript时间戳到一个TIMESTAMP列中 如果你有一个JavaScript的时间戳，例如1478960868932，你可以像下面这样将这个值转换为MySQL的小数时间值：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十八)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-58.html</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-58.html</guid>
      <description>多种语言使用UTF-8连接 1. Python 源代码的第一行或第二行(需要有utf8的编码声明)
# -*- coding: utf-8 -*-  连接：
db = MySQLdb.connect(host=DB_HOST, user=DB_USER, passwd=DB_PASS, db=DB_NAME, charset=&amp;quot;utf8mb4&amp;quot;, use_unicode=True)  对于web页面，下面中的一个：
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt; &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;  2. PHP 在php.ini(在PHP5.6之后是默认的)：
default_charset UTF-8  当在web页面的时候：
header(&#39;Content-type: text/plain; charset=UTF-8&#39;);  当连接MySQL的时候：
(for mysql:) Do not use the mysql_* API! (for mysqli:) $mysqli_obj-&amp;gt;set_charset(&#39;utf8mb4&#39;); (for PDO:) $db = new PDO(&#39;dblib:host=host;dbname=db;charset=utf8&#39;, $user, $pwd);  在代码中，不用使用任何转换例程。
对于数据入口：
&amp;lt;form accept-charset=&amp;quot;UTF-8&amp;quot;&amp;gt;  对于JSON，避免使用\uxxxx:
 $t = json_encode($s, JSON_UNESCAPED_UNICODE);  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十七)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-57.html</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-57.html</guid>
      <description>处理稀疏或丢失的数据 1. 处理包含NULL值的列 在MySQL和其他的SQL语言中，NULL是一个特殊的属性。
考虑有下面的表，其中包括求职者信息、他们的公司以及他们离开公司的时间。NULL值表示这个人还在公司中工作:
CREATE TABLE example (`applicant_id` INT, `company_name` VARCHAR(255), `end_date` DATE); +--------------+-----------------+------------+ | applicant_id | company_name | end_date | +--------------+-----------------+------------+ | 1 | Google | NULL | | 1 | Initech | 2013-01-31 | | 2 | Woodworking.com | 2016-08-25 | | 2 | NY Times | 2013-11-10 | | 3 | NFL.com | 2014-04-13 | +--------------+-----------------+------------+  你的任务是使用一个查询获取所有在2016-01-01之后的记录，包括还在公司工作的员工记录(那些NULL的值)，下面这个查询语句：
SELECT * FROM example WHERE end_date &amp;gt; &#39;2016-01-01&#39;;  将不会包含NULL值的记录：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十六)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-56.html</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-56.html</guid>
      <description>自定义PS1 1. 自定义当前数据库的MySQL PS1 在.bashrc或.bash_profile中添加下面的内容：
export MYSQL_PS1=&amp;quot;\u@\h [\d]&amp;quot;  这会让MySQL客户端提示当前的 user@host [database]
2. 使用MySQL配置文件配置PS1 在mysqld.cnf或者等价的文件中添加下面的内容：
[mysql] prompt = &#39;\u@\h [\d] &#39;  这将会获得相同的功能，但是不需要处理.bashrc这样的文件。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十五)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-55.html</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-55.html</guid>
      <description>临时表 1. 创建临时表 临时表用来保存临时数据是很有用的。临时表选项是在MySQL3.23之后开始有效的。
临时表在会话结束或连接关闭的时候自动销毁。用户也可以自己删的临时表。
相同名称的临时表可以在同时被多个连接使用，因为临时表只在创建表的客户端中有效可以访问。
临时表可以使用下面的语法穿甲：
-- 基本语法 CREATE TEMPORARY TABLE tempTable1( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(100) NOT NULL, PRIMARY KEY (id) ); -- 从select创建 CREATE TEMPORYARY TABLE tempTable1 SELECT ColumnName1,ColumnName2,... FROM table1;  你可以像创建表一样添加索引：
CREATE TEMPORARY TABLE tempTable1 (PRIMARY KEY(ColumnName2)) SELECT ColumnName1,ColumnName2,... FROM table1;  IF NOT EXISTS关键字用来避免&amp;rsquo;table already exists&amp;rsquo;错误。你过你创建的表名在的当前会话中已经存在了，这个表将不会创建。
CREATE TEMPORARY TABLE IF NOT EXISTS tempTable1 SELECT ColumnName1,ColumnName2,... FROM table1;  2. 删除临时表 Drop Temporary Table用来删除这个会话中创建的临时表。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十四)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-54.html</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-54.html</guid>
      <description>MySQL Client    参数 描述     -D —database=name 数据库的名称   —delimiter=str 设置语句的分隔符，默认是&amp;rdquo;;&amp;rdquo;   -e —execute=&amp;lsquo;command&amp;rsquo; 执行命令   -h —hostname=name 要连接的主机名称   -p —password=password 密码。注意：在-p和密码之间没有空格   -p (没有密码) 将会提示输入密码   -P —port=# 端口号   -s —slient 安静模式，产生更少的输出。使用-t作为列分隔符   -ss 和-s一样，但是忽略列名   -S —socket=path 当连接本地实例的时候，指定使用的socket(Unix)或pipe(Windows)   —skip-column-names 忽略列名   -u —user=name 用户名   -U —safe-updates —i-am-a-dummy 使用sql_safe_updates=ON变量登录。这在DELETE和UPDATE操作时，只允许指定Key的操作   -V —version 打印版本号并退出    1.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十三)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-53.html</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-53.html</guid>
      <description>Union 1. Union运算符 Union运算符用来把两个或多个SELECT语句的结果集(只有非重复的值)组合在一起。
查询：从&amp;rdquo;Customers&amp;rdquo;和&amp;rdquo;Supplies&amp;rdquo;表中查询不同的城市(只限非重复的值)
SELECT City FROM Customers UNION SELECT City FROM Suppliers ORDER BY City;  结果：
Number of Records: 10 City ------ Aachen Albuquerque Anchorage Annecy Barcelona Barquisimeto Bend Bergamo Berlin Bern  2. Union ALL Union ALL从&amp;rdquo;Customers&amp;rdquo;和&amp;rdquo;Suppliers&amp;rdquo;两个表中查到所有的值(包括重复的值)。
查询：
SELECT City FROM Customers UNION ALL SELECT City FROM Suppliers ORDER BY City;  结果：
Number of Records: 12 City ------- Aachen Albuquerque Anchorage Ann Arbor Annecy Barcelona Barquisimeto Bend Bergamo Berlin Berlin Bern  3.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十二)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-52.html</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-52.html</guid>
      <description>LOAD DATA INFILE 1. 使用LOAD DATA INFILE 导入大量数据到数据库 考虑下面的示例，假设您有一个以&amp;rdquo;;&amp;ldquo;分隔的csv加载到数据库中。
1;max;male;manager;12-7-1985 2;jack;male;executive;21-8-1990 . . . 1000000;marta;female;accountant;15-6-1992  创建一个要导入数据的表：
CREATE TABLE `employee` ( `id` INT NOT NULL , `name` VARCHAR NOT NULL, `sex` VARCHAR NOT NULL , `designation` VARCHAR NOT NULL , `dob` VARCHAR NOT NULL );  使用下面的语句来把数据导入的数据表中：
LOAD DATA INFILE &#39;path of the file/file_name.txt&#39; INTO TABLE employee FIELDS TERMINATED BY &#39;;&#39; //指定字段分隔符 LINES TERMINATED BY &#39;\r\n&#39; (id, name, sex, designation, dob)  考虑其中日期格式不标准的情况：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十一)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-51.html</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-51.html</guid>
      <description>使用mysqlimport导入数据    选项 详情     —delete -D 服务器登录选项   —fields-optionally-enclosed-by 定义引用字段的字符   —fields-terminated-by 字段终止符   —ignore -i 如果key重复了，那就忽略已经插入的行   —lines-terminated-by 定义行终止符   —password -p 密码   —port -P 端口号   —replace -r 重复key时，覆盖原本的行   —user -u 用户名   —where -w 指定条件    1. 基本用法 使用tab分隔符的employee.txt文件：
 1 \t Arthur Dent 2 \t Marvin 3 \t Zaphod Beeblebrox</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-50.html</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-50.html</guid>
      <description>使用mysqldump备份    选项 详情     — 服务器登录选项   -h (—host) 要连接的服务器的主机(IP地址或主机名称)。默认是localhost(127.0.0.1)。例如-h localhost   -u (—user) MySQL的用户名   -p (—password) MySQL的用户密码。重要：当使用这个选项的时候，在-p和密码之间没有空格。例如-pMyPassword   — 导出选项   —add-drop-database 在每个CREATE DATABASE语句之前添加一个DROP DATABASE。如果你想要替换服务器上面的数据库，这个是很有用的   —add-drop-table 在每个CREATE TABLE语句前面增加DROP TABLE语句。当你想要替换服务器上面的表的话很有用。   —no-create-db 禁止在转存中使用CREATE DATABASE语句。当你确定要转存的数据库在目标数据库中已经存在时使用。   -t (—no-create-info) 禁止在转存中使用CREATE TABLE语句。这在你只想导出表的数据时有用，然后在另外的库中使用这个转存文件导入数据到相同的表中。   -d (—no-data) 不写表信息。值或导出CREATE TABLE语句。对应创建数据库的&amp;rdquo;模板&amp;rdquo;很有用   -R (—routines) 在导出中包含存储过程/函数   -K (—disable-keys) 在插入数据之前禁止每个表的key，数据导入之后允许key。这会增加MyISAM中没有唯一索引的表的导入速度。    1.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十九)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-49.html</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-49.html</guid>
      <description>复制 1. 主从配置复制 假设有两个MySQL服务器进行复制配置，其中一台是主库，一台是从库。
我们需要配置主库记录在其上执行的每个操作的日志。我们需要配置从库监控主库的日志，一旦主库做了一些修改操作，从库就需要执行同样的操作。
主库配置
首先，我们需要为主库设置一个用户。这个用户用来给从库建立到主库的连接使用。
CREATE USER &#39;user_name&#39;@&#39;%&#39; IDENTIFIED BY &#39;user_password&#39;; GRANT REPLICATION SLAVE ON *.* TO &#39;user_name&#39;@&#39;%&#39;; FLUSH PRIVILEGES;  修改上面代码中的user_name和user_password为你自己的用户名和密码。
现在my.inf(Linux中是my.cnf)需要被修改了，在[mysqld]部分添加下面的内容：
server-id = 1 log-bin = mysql-bin.log binlog-do-db = your_database  第一行用来为这个MySQL服务器设置一个ID。
第二行告诉MySQL开始在指定的log文件中开始写入日志。在Linux机器上，这个需要被设置为log-bin=/home/mysql/logs/mysql-bin.log。如果您正在已使用复制的MySQL服务器中启动复制，请确保此目录中没有复制日志。
第三行用来说明我们想要哪个数据库去写日志。你需要替换其中的your_database为你自己的数据库名。
确保ship-networking没有开启，重启主库。
从库配置
从库的my.inf也需要修改。需要在[mysqld]部分包含下面的内容：
server-id = 2 master-host = master_ip_address master-connect-retry = 60 master-user = user_name master-password = user_password replicate-do-db = your_database relay-log = slave-relay.log relay-log-index = slave-relay-log.index  第一行用来设置这个从库的ID，这个ID应该是唯一的。
第二行是主库服务器的IP地址。修改这个值为你的主库服务器的IP。
第三行以秒为单位，限制重试的次数。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十八)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-48.html</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-48.html</guid>
      <description>分区 1. 范围分区 按照范围分区的表是指每个分区包含按照指定分区表达式在某个范围内的行。范围应该是连续但不重叠的，使用VALUES LESS THAN运算符获得。在下面的例子中，假设你创建了包含下面20加连锁视频店(从1到20)的人事记录。
CREATE TABLE employees( id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30), hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;, separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;, job_code INT NOT NULL, store_id INT NOT NULL );  这个表可以根据你的需要，按照不同的范围分为几个区。一种方法是使用store_id列。例如，你可以把表分为4个部分，使用PARTITION BY RANGE语句：
ALTER TABLE employees PARTITION BY RANGE (store_id) ( PARTITION p0 VALUES LESS THAN (6), PARTITION p1 VALUES LESS THAN (11), PARTITION p2 VALUES LESS THAN (16), PARTITION p3 VALUES LESS THAN MAXVALUE );   MAXVALUE表示一个始终大于最大可能整数值的整数值。(在数学中，用作最小上界。)</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-47.html</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-47.html</guid>
      <description>集群 1. 消除歧义 &amp;ldquo;MySQL集群&amp;rdquo;消除歧义：
 NDB集群：一种专用，主要是内存中引擎。没有广泛使用 Galera集群又叫Percona XtraDB集群又叫PXC又叫带有Galera的MariaDB：一个非常好的MySQL高可用性解决方案;它超越了Replication  查看单独的&amp;rdquo;集群&amp;rdquo;相关的页面。
对于&amp;rdquo;聚簇索引&amp;rdquo;，查看主键相关。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十六)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-46.html</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-46.html</guid>
      <description>日志文件 1. 慢查询日志 慢查询日志包含查询话费时间在long_query_time秒之后才结束的查询记录。例如，话费了10秒才查询结束。要查看当前设置的慢查询时间值，可以使用下面的命令：
SELECT @@long_query_time; +-------------------+ | @@long_query_time | +-------------------+ | 10.000000 | +-------------------+  可以在my.cnf或my.ini文件中配置一个全局的设置值。或者可以在一个会话中进行设置，虽然这个不太常用。这个值是从0到10(秒)之间的一个值。应该使用什么值呢？
 10秒太高了，一般不使用。 2秒是一个妥协的方案 0.5或者其他分数是可能的 0秒会捕获所有的内容；这可能会很快的把硬盘填满，但是很有用。  慢查询日志要么开启要么关闭。并且log文件也是可以指定的。下面的内容介绍了相关的变量：
SELECT @@slow_query_log; -- 慢查询是否开启 SELECT @@slow_query_log_file; -- 慢查询日志文件 SELECT @@datadir; -- 日志文件的目录 SET GLOBAL slow_query_log=0; --关闭 SET GLOBAL slow_qeury_log=1; --开启  更详细的信息，查看MySQL的手册：慢查询日志。
注意：上面例子中开启和关闭慢查询的方法是5.6之后新加的，在老版本中使用另外的语法。
&amp;ldquo;最好&amp;rdquo;的查询你系统上面的慢日志：
long_query_time=... turn on the slowlog run for a few hours turn off the slowlog (or raise the cutoff) run pt-query-digest to find the &#39;worst&#39; couple of queries.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十五)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-45.html</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-45.html</guid>
      <description>事务 1. 开启事务 一个事务就是一个SQL语句的序列分组，可以包括像select,insert,update或者delete这些超值，然后在一个工作单元中执行。
换句话说，事务只有在分组中的每个操作执行成功的情况下才会完成执行。如果事务中任何一个操作失败了，事务就会失败。
银行事务是用来解释这个的最好例子。假设有两个用户之间的转账操作。要实现这个功能你需要写下面的SQL语句：
 首先检查第一个账户请求的数量是不是有效。 从第一账户中删除请求的数量 在第二个账户中增加这个金额  如果上面的操作中任何一个操作失败了，就需要返回之前的状态。
ACID：事务的属性
事务有下面四个属性：
 原子性：确保工作单元内的所有操作都成功完成；否则事务的操作会在失败时终止，以前的操作都会回滚到以前的状态。 一致性：确保数据库在成功提交事务时正确更改状态。 隔离性：使事务能够独立运行并且彼此透明 持久性：确保提交事务的结果在系统故障时持续存在  事务使用START TRANSACTION或BEGIN WORK来开启，然后使用COMMIT或ROLLBACK语句结束。在这两个语句之间的SQL语句就是事务的代码块。
START TRANSACTION; SET @transAmt = &#39;500&#39;; SELECT @availableAmt:=ledgerAmt FROM accTable WHERE customerId=1 FOR UPDATE; UPDATE accTable SET ledgerAmt=ledgerAmt-@transAmt WHERE customerId=1; UPDATE accTable SET ledgerAmt=ledgerAmt+@transAmt WHERE customerId=2; COMMIT;  在使用START TRANSACTION语句之后，自动提交操作将会被终止，知道事务结束使用COMMIT或ROLLBACK 操作才会提交这些修改。然后恢复自动提交操作之前单的状态。
FOR UPDATE语句指示(并锁定)事务持续期间的行。
事务没有提交之前，这个事务对其他用户就不是有效的。
事务的一般过程
 通过START TRANSACTION或BEGIN WORK来开启一个事务。 运行事务中的SQL语句 检查事务中SQL是否安装你的要求执行了 如果时的话，执行COMMIT命令。否知执行ROLLBACK操作恢复之前的状态 即使在提交之后，如果您正在使用或可能最终使用galera/pxc，也要检查错误。  2. COMMIT，ROLLBACK，AUTOCOMMIT AUTOCOMMIT</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十四)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-44.html</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-44.html</guid>
      <description>MyISAM转换为InnoDB 1. 基本转换 ALTER TABLE ENGINE=InnoDB;  这个操作转换了两个数据表的引擎，但是不关心这两种引擎之间的差异。大部分差别是没有影响的，特别是对小表来说。但是多于常用的表来说，还要考虑其他的因素。转换注意点。
2. 转换一个数据库的所有表 使用下面的命令可以方便的吧一个数据库中所有的表进行转换。
SET @DB_NAME = DATABASE(); SELECT CONCAT(&#39;ALTER TABLE `&#39;, table_name, &#39;` ENGINE=InnoDB;&#39;) AS sql_statements FROM information_schema.tables WHERE table_schema = @DB_NAME AND &#39;ENGINE&#39; = &#39;MyISAM&#39; AND &#39;TABLE_TYPE&#39; = &#39;BASE TABLE&#39;;   注意：你应该连接上数据让DATABASE()正常工作，否则这个方法将会返回NULL。这主要适用于随服务器提供的标准MySQL客户机，因为它允许在不指定数据库的情况下进行连接。
 运行这个表获取你数据库中所有的MyISAM表。
最后，复制输出的SQL然后执行他们。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十三)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-43.html</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-43.html</guid>
      <description>MyISAM引擎 1. ENGINE=MyISAM CREATE TABLE foo ( ... ) ENGINE=MyISAM;  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十二)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-42.html</link>
      <pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-42.html</guid>
      <description>字符集和排序 1. 什么是字符集和排序？ 有几十种字符集和数百种排序规则。(一种排序规则只属于一种字符串)。查看SHOW COLLATION;的输出。
通常只有4中字符集比较重要：
ascii -- 基础的7位编码 latin1 -- ascii, 加上大多数西欧语言需要的字符 utf8 -- the 1-, 2-, and 3-byte subset of utf8. 不包括 Emoji and 一些中文. utf8mb4 -- UTF8字符的全集合，包含当前所有的语言  全部包括英文字符，编码相同。utf8是utf8mb4的子集。
最好用法：
 将utf8mb4用于包含多种语言的TEXT和VARCHAR列 对于十六进制字符串（UUID、MD5等）和简单代码（国家/地区代码、邮政编码等），使用ASCII（Latin1是OK）。  在MySQL5.3.3之前是没有utf8mb4这个字符集的，所以在之前的版本中utf8是最有效的。
在MySQL之外的环境中，&amp;rdquo;UTF8&amp;rdquo;表示的是和MySQL中utf8mb4是想同的，而不是utf8。
排序规则以字符集开头，以_ci结尾表示&amp;rdquo;大小写和重音区分&amp;rdquo;，以&amp;rdquo;_bin&amp;rdquo;结尾表示已二进制比较。
最新的uttf8mb4排序规则是utf8mb4_unicode_520_ci，是基于Unicode 5.20。如果你基于一个语言，那么你可能用到&amp;rdquo;utf8mb4_polish_ci&amp;rdquo;，它将根据波兰语惯例稍微重新排列字母。
2. 设置表和字段的字符集 你可以为每个表和每个单独的字段设置字符集，使用CHARACTER SET和charset语句。
CREATE TABLE Address ( `AddressID` INTEGER NOT NULL PRIMARY KEY, `Street` VARCHAR(80) CHARACTER SET ASCII, `City` VARCHAR(80), `Country` VARCHAR(80) DEFAULT &amp;quot;United States&amp;quot;, `Active` BOOLEAN DEFAULT 1, ) Engine=InnoDB default charset=UTF8;  City和Country将会使用UTF8编码，这个是这个表的默认字符集。Street使用ASCII编码，我们专门指定的。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十一)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-41.html</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-41.html</guid>
      <description>使用Docker-Compose安装MySQL容器 1. 简单的Docker-Compose例子 下面是使用Docker创建MySQL服务器的简单例子。
创建docker-compose.yml文件：
注意：如果你想为你所有的项目使用相同的容器，需要在你的HOME_PATH中创建一个PATH。如果你想要在你的每个项目中创建这个文件，你需要在项目中创建一个docker目录。
version: &#39;2&#39; services: cabin_db: image: mysql:latest volumes: - &amp;quot;./.mysql-data/db:/var/lib/mysql&amp;quot; restart: always ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: rootpw MYSQL_DATABASE: cabin MYSQL_USER: cabin MYSQL_PASSWORD: cabinpw  运行
cd PATH_TO_DOCKER-COMPOSE.YML docker-compose up -d  连接到服务器
mysql -h 127.0.0.1 -u root -P 3306 -p rootpw -- 成功了  终止服务器
 docker-compose stop  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-40.html</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-40.html</guid>
      <description>ENUM 1. 什么是ENUM？ ENUM提供了一个为一行数据增加属性的功能。具有少量非数字选项的属性效果最好。例子：
reply ENUM(&#39;yes&#39;, &#39;no&#39;) gender ENUM(&#39;male&#39;, &#39;female&#39;, &#39;other&#39;, &#39;decline-to-state&#39;)  它们的值是字符串：
INSERT ... VALUES (&#39;yes&#39;, &#39;female&#39;) SELECT ... --&amp;gt; yes female  2. VARCHAR是一种可选方案 假设我们有下面的内容：
type ENUM(&#39;fish&#39;, &#39;mammal&#39;, &#39;bird&#39;); -- 下面是另一种方案 type VARCHAR(20) COMENT &#39;fish,mammal,bird等等&#39;  这是相当开放的，因为新的类型是很容易添加的。
比较，以及是否比枚举更好或更差：
 (相同) INSERT:简单的提供相同的字符串 (更糟？) INSERT：拼写错误可能注意不到 (相同) SELECT：返回实际的字符串 (更坏) 需要更多的存储空间。  3. 添加一个选项 ALTER TABLE tbl MODIFY COLUMN type ENUM(&#39;fish&#39;,&#39;mammal&#39;,&#39;bird&#39;,&#39;insect&#39;);  注意：
 和其他的MODIFY COLUMN一样，你需要包含NOT NULL，以及任何其他之前拥有的限定符，不然会丢失一些东西 如果添加在列表的末尾，并且列表的数量小于256个，ALTER操作将会正常执行修改表结构的操作。也就是说，不会有冗长的表副本。（旧版本的MySQL没有这种优化。）  4. NULL VS NOT NULL 下面是当NULL和&amp;rsquo;错误值&amp;rsquo;存储到NULLable和非NULL时什么将会发生的例子。也展示了通过+0来转换为数字的操作。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十九)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-39.html</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-39.html</guid>
      <description>事件 1. 创建一个事件 MySQL有它的事件功能，可以避免复杂的cron交互，当您计划的大部分内容与SQL相关，而与文件关联较少时。查看事件手册。把事件想象为定时执行的存储过程。
要节省调试事件相关问题的时间，请记住必须打开全局事件处理程序才能处理事件。
SHOW VARIABLES WHERE variable_name = &#39;even_scheduler&#39;; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | event_scheduler | OFF | +-----------------+-------+  当配置关闭的时候，什么都不会触发。使用下面的命令打开这个配置：
SET GLOBAL event_scheduler = ON;  测试的表
CREATE TABLE theMessage ( Id INT AUTO_INCREMENT PRIMARY KEY, userId INT NO NULL, message VARCHAR(255) NOTT NULL, updateDt DATETIME NOT NULL, KEY (updateDt) ); INSERT theMessages(userId,message,updateDt) VALUES (1,&#39;message 123&#39;,&#39;2015-08-24 11:10:09&#39;); INSERT theMessages(userId,message,updateDt) VALUES (7,&#39;message 124&#39;,&#39;2015-08-29&#39;); INSERT theMessages(userId,message,updateDt) VALUES (1,&#39;message 125&#39;,&#39;2015-09-03 12:00:00&#39;); INSERT theMessages(userId,message,updateDt) VALUES (1,&#39;message 126&#39;,&#39;2015-09-03 14:00:00&#39;);  上述插入件用于显示起点。请注意，下面创建的两个事件将清除行。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十八)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-38.html</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-38.html</guid>
      <description>配置和调整 1. InnoDB性能 在my.cnf中有几百个配置项。对于MySQL的&amp;rdquo;普通&amp;rdquo;用户来说，他们并不关心这个。
一旦你的数据库变得重要了，非常建议设置下面的参数：
innodb_buffer_pool_size  这应该被设置为有效RAM的70%(如果你至少有4GB的内存；如果你的内存较小或机器比较老，这个值还有更小一些。)这个配置控制这InnoDB引擎使用的缓存数量。因此这个配置对于InnoDB的性能是非常重要的。
2. 允许大数据插入的参数 如果我们需要在一个列中存储图片或视频这种大文件，我们需要修改下面的配置项，用来满足我们应用的需要：
max_allowed_packet = 10M M is Mb, G in Gb, K in Kb  3. 增加group_concat的字符串限制 group_concat用来将一个分组的非NULL的值的拼接组合。这个的结果字符串的最大长度可以使用group_concat_max_len选项来控制：
SET [GLOBAL | SESSION] group_concat_max_len = val;  设置变量的GLOBAL模式，将会设置一个永久的值，而设置SESSION模式，将会只在这个这个会话下有效果。
4. 最小InnoDB配置项 这是使用InnoDB表的MySQL服务器的最低配置。使用InnoDB使用查询缓存。删除表或数据时收回硬盘空间。当使用SSD时，刷新是一个冗余的操作(SSD不是连续的)。
default_storage_engine = InnoDB query_cache_type = 0 innodb_file_per_table = 1 innodb_flush_neighbors = 0  并发
通过将innodb_thread_concurrency设置为0，确保我们可以创建超过默认4个线程。这使用InnoDB可以根据最佳执行情况进行设置。
innodb_thread_concurrency = 0 innodb_read_io_threads = 64 innodb_write_io_threads = 64  硬盘利用率
设置MySQL的IOPS的容量(平均负载)和最大容量(最大负载)。对于HDD，默认200是可以的。但是现在，对于SSD可以达到数千的IOPS，你可能需要设置这个值。可以运行很多的测试来确定IOPS。如果您运行的是一个专用的mysql服务器，上面的值应该接近这个限制。如果您在同一台机器上运行任何其他服务，则应根据需要进行分配。
innodb_io_capacity = 2500 innodb_io_capacity_max = 3000  RAM利用率</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-37.html</link>
      <pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-37.html</guid>
      <description>触发器 1. 基础触发器 创建表
mysql&amp;gt; CREATE TABLE account(acct_num INT, amount DECIMAL(10, 2)); Query OK, 0 rows affected (0.03 sec)  创建触发器
mysql&amp;gt; CREATE TRIGGER ins_sum BEFORE INSERT ON account -&amp;gt;FOR EACH ROW SET @sun = @sum + NEW.amount; Query OK, 0 rows affected (0.06 sec)  这个CREATE TRIGGER语句创建一个名为ins_sum的触发器，并且关联到account表上面。它也包含指明触发器时间，触发器时间和触发器执行什么操作的语句。
插入数据
想要使用触发器，将累加变量(@sum)设置为0，执行一个INSERT语句，然后查看这个变量的值：
mysql&amp;gt; SET @sum = 0; mysql&amp;gt; INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00); mysql&amp;gt; SELECT @sum AS &#39;Total amount inserted&#39;; +-----------------------+ | Total amount inserted | +-----------------------+ | 1852.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十六)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-36.html</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-36.html</guid>
      <description>MySQL管理员 1. 原子重命名和表格重新加载 RENAME TABLE t TO t_old, t_copy TO t;  当执行RENAME TABLE操作期间，没有其他请求可以访问这个表，这样重命名操作没有并发的问题。
原子重命名特别适用于在不等待删除和加载完成的情况下重新加载表：
CREATE TABLE new LIKE real; load `new` by whatever means - LOAD DATA, INSERT, whatever RENAME TABLE real TO old, new TO real; DROP TABLE old;  2. 修改root密码 mysaladmin -u root -p&#39;old-password&#39; password &#39;new-password&#39;  3. 删除数据库 用来删除数据库和所有表的脚本：
mysqladmin -u[username] -p[password] drop [database]  使用时要格外小心。
想要使用SQL语句删除数据库(你需要在这个数据库上面拥有DROP权限)：
DROP TABLE database_name  或者：
DROP SCHEMA database_name  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十五)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-35.html</link>
      <pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-35.html</guid>
      <description>从JSON类型提取数据    参数 描述     json_doc 有效的JSON数据   path 成员路径    MySQL5.7.8支持原生的JSON类型。因为你有不同的方法来创建json对象，你也可以访问和读取元素使用不同的方法。
主要的方法是JSON_EXTRACT，因此-&amp;gt;和-&amp;gt;&amp;gt;运算符更加友好。
1. 读取JSON数组值 创建JSON类型的@myjson变量：
SET @myjson = CAST(&#39;[&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, {&amp;quot;id&amp;quot;:1, &amp;quot;label&amp;quot;:&amp;quot;C&amp;quot;}]&#39; as JSON);  SELECT查询其中的元素：
SELECT JSON_EXTRACT( @myjson , &#39;$[1]&#39; ) , JSON_EXTRACT( @myjson , &#39;$[*].label&#39;) , JSON_EXTRACT( @myjson , &#39;$[1].*&#39; ) , JSON_EXTRACT( @myjson , &#39;$[2].*&#39;) ; -- result values: &#39;\&amp;quot;B\&amp;quot;&#39;, &#39;[\&amp;quot;C\&amp;quot;]&#39;, NULL, &#39;[1, \&amp;quot;C\&amp;quot;]&#39; -- visually: &amp;quot;B&amp;quot;, [&amp;quot;C&amp;quot;], NULL, [1, &amp;quot;C&amp;quot;]  2.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十四)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-34.html</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-34.html</guid>
      <description>JSON MySQL5.7.8开始支持元素的JSON数据类型，允许方便的访问JSON数据。https://dev.mysql.com/doc/refman/5.7/en/json.html
1. 创建带有主键和JSON字段的表 CREATE TABLE table_name ( id INT NOT NULL AUTO_INCREMENT, json_col JSON, PRIMARY KEY (id) );  2. 插入一个简单的JSON INSERT INTO table_name(json_col) VALUES (&#39;{&amp;quot;City&amp;quot;:&amp;quot;Galle&amp;quot;, &amp;quot;Description&amp;quot;: &amp;quot;Best damn city in the world&amp;quot;}&#39;);  这个是很容易的，但是注意因为JSON的键必须包围在双引号内，所以整个JSON字符串必须包围在单引号内。如果查询成功了，这个数据将会存储为二进制格式。
3. 更新JSON字段 在前面的例子中，我们查看了组合类型数据怎么存储到一个JSON字段中。如果我们想要更新这个字段怎么办？我们想在之前的数据中数据一个键为variations，值为scheveningen的内容：
UPDATE myjson SET dict=JSON_ARRAY_APPEND(dict, &#39;$.variations&#39;, &#39;scheveningen&#39;) WHERE id = 2;  注意：
 在我们json字典中的$.variations数组。$符合表示json文档。有关mysql识别的JSON路径的完整解释，请参阅https://dev.mysql.com/doc/refman/5.7/en/json-path-syntax.html 因为我们没有使用JSON进行查询的例子，所以这个例子使用主键。  现在，如果我们执行SELECT * FROM myjson，我们将看到：
+----+--------------------------------------------------------------------------------+ | id | dict | +---+---------------------------------------------------------------------------------+ | 2 | {&amp;quot;opening&amp;quot;: &amp;quot;Sicilian&amp;quot;, &amp;quot;variations&amp;quot;: [&amp;quot;pelikan&amp;quot;, &amp;quot;dragon&amp;quot;, &amp;quot;najdorf&amp;quot;, &amp;quot;scheveningen&amp;quot;]} | +----+--------------------------------------------------------------------------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十三)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-33.html</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-33.html</guid>
      <description>PREPARE语句 1. PREPARE, EXECUTE和DEALLOCATE PREPARE语句 PREPARE准备一个将要执行的语句。
EXECUTE执行一个准备好的语句。
DEALLOCATE PREPARE释放一个准备好的语句。
SET @s = &#39;SELECT SQRT(POW(?,2) + POW(?, 2)) AS hypotenuse&#39;; PREPARE stmt2 FROM @s; SET @a = 6; SET @b = 8; EXECUTE stmt2 USING @a, @b;  结果：
+------------+ | hypotenuse | +------------+ | 10 | +------------+  最后：
DEALLOCATE PREPARE stmt2;  注意：
 你必须使用@variable，而不是声明的变量，对于FROM @s语句 PREPARE的主要用途是构造一种情况的查询（绑定但是还不能工作的），然后插入表名之后就可以执行  2. 修改表增加列 SET v_column_definition := CONCAT( v_column_name , &amp;quot; &amp;quot;, v_column_type , &#39; &#39;, v_column_options ); SET @stmt := CONCAT(&#39;ALTER TABLE ADD COLUMN &#39;, v_column_definition); PREPARE stmt FROM @stmt; EXECUTE stmt; DEALLOCATE PREPARE stmt;  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十二)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-32.html</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-32.html</guid>
      <description>全文搜索 MySQL提供有全文搜索。它在包含文本的列的表中搜索单词和短语的最佳匹配项。
1. 简单的全文搜索 SET @searchTerm = &#39;Database Programming&#39;; SELECT MATCH (Title) AGAINST (@searchTerm IN NATURAL LANGUAGE MODE) SCORE, ISBN, Author, Title FROM book WHERE MATCH (TITLE) AGAINST (@searchTerm IN NATURAL LANGUAGE MODE) ORDER BY MATCH (Titile) AGAINST (@searchTerm IN NATURAL LANGUAGE MODE) DESC;  有一个名叫book的表，这个表里面有ISBN, TITLE, Author这几个列。这个语句搜索匹配到Database Programming的记录。这首先显示匹配最好的记录。
想要这个正常工作的话，一个Title列的全文索引必须是有效的：
ALTER TABLE book ADD FULLTEXT INDEX Fulltext_title_index(Title);  2. 简单的布尔值搜索 SET @searchTerm = &#39;Database Programming =Java&#39;; SELECT MATCH (Title) AGAINST (@searchTerm IN BOOLEAN MODE) Score, ISBN, Author, Title FROM book WHERE MATCH (Title) AGAINST (@searchTerm IN BOOLEAN MODE) ORDER BY MATCH (Title) AGAINST (@searchTerm IN BOOLEAN MODE) DESC;  表名为book的表有ISBN, Title, Author，这将会搜索数据标题中有Database和Programming但是不包含Java的书籍。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-46.html</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-46.html</guid>
      <description>过滤和过滤函数    参数 详情     variable 要进行筛选的值。注意标量的值在进行筛选之前，在筛选之前内部会将标量值转换为字符串。   filter 将要应用的筛选的ID。手册中列出了有效的变量筛选类型。如果忽略的话，默认会使用FILTER_DEFAULT，这等价于FILTER_UNSAFE_RAW。这将导致默认情况下不进行过滤。   options 选项的关联数组或者标志位的二进制表示。如果筛选器接受选项，标志位可以在数组的&amp;rdquo;flags&amp;rdquo;字段中添加。对于&amp;rdquo;回调&amp;rdquo;筛选器，应该传入可调用类型。这个回调方法必须接受一个参数，就是要筛选的值，并在筛选/清理后返回这个值。    这个扩展通过验证或清理数据来筛选数据。当数据源中包含未知(或外部)的数据(如用户输入的数据)时，是非常有用的。例如，这些数据来自HTML的表格。
1. 验证布尔值 var_dump(filter_var(true, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); //true var_dump(filter_var(false, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); //false var_dump(filter_var(1, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(0, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;1&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(&#39;0&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39; &#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;true&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(&#39;false&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var([], FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // NULL var_dump(filter_var(null, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false  2.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十一)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-31.html</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-31.html</guid>
      <description>索引和键 1. 创建索引 -- 创建my_table中name列的索引 CREATE INDEX idx_name ON my_table(name);  2. 创建唯一索引 一个唯一索引用来避免在表中插入重复的数据。一个唯一索引的列可以插入多个NULL值(因为，默认情况下NULL是和其他值都不相同的，包括其他的NULL)。
-- 创建my_table表中name列的唯一索引 CREATE UNIQUE INDEX idex_name ON my_table(name);  3. AUTO_INCREMENT键 CREATE TABLE ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, ... PRIMARY KEY(id), ... );  主要注意点：
 从1开始并且自动增加1当你没有在INSERT语句中指定值，或者指定这个值为NULL 这个id一直都是和其他的不一样的，但是 不要对id进行假设(如没有间隙、连续生产、不重用等)，除了在任何时候都是唯一的。  细微注意点：
 当重启服务器的时候，&amp;rdquo;下一个&amp;rdquo;值就是MAX(id)+1这么计算的 如果在系统关闭或崩溃之前的最后一个操作是删除最大的id值，这个id可能被重用(这根据引擎决定)。所以，不要详细自增量永久是唯一的，它们只是在任何时刻是唯一的。 对弈多主机或集群解决方案，查看auto_increment_offset和auto_increment_increment 有些时候简单的使用INDEX(id)而不是PRIMARY KEY也是可以的。(这在某些情况下是有中性能提升) 使用AUTO_INCREMENT作为PARTITION key是很少有好处的，所以不要这么做 各种操作都可能&amp;rdquo;毁坏&amp;rdquo;值。这发送在当他们预分配的值，不要这么使用：INSERT IGNORE(使用重复键)，REPLACE(这等价于DELETE加上INSERT)，和其他的操作。ROLLBACK是另外造成id间隙的操作。 在主从复制过程中，不能信任ID以升序到达从服务器。尽管ID是按照练习顺序分配的，但是InnoDB是按照提交顺序发送到从系统的。  4. 创建组合索引 这将会在两个键上面创建联合索引，mystring和mydatetime，提升在这两个键上面的WHERE查询的速度。
CREATE INDEX idx_mmycol_myothercol ON my_table(mycol, myothercol);  注意：这个顺序是很重要的！如果在查下语句的WHERE条件中没有包含这两个列，那将会用到最左的索引。在这样的情况下，当查询的WHERE语句中包括mycol将会使用这个索引，一个查询包含myothercol将不会使用索引。详细信息查看这个blog。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-45.html</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-45.html</guid>
      <description>类型提示 1. 类和接口提示 在PHP5的时候，增加了类和接口的提示。
类提示
&amp;lt;?php class Student { public $name = &#39;Chris&#39;; } class School { public $name = &#39;University of Edinburgh&#39;; } function enroll(Student $student, School $school) { echo $student-&amp;gt;name . &#39; is being enrolled at &#39; . $school-&amp;gt;name; } $student = new Student(); $school = new School(); enroll($student, $school);  上面的例子将会输出：
 Chris is being enrolled at University of Edinburgh
 接口提示
&amp;lt;?php interface Enrollable {}; interface Attendable {}; class Chris implements Enrollable { public $name = &#39;Chris&#39;; } class UniversityOfEdinburgh implements Attendable { public $name = &#39;University of Edinburgh&#39;; } function enroll(Enrollable $enrollee, Attendable $premises) { echo $enrollee-&amp;gt;name .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-30.html</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-30.html</guid>
      <description>存储例程(程序和函数)    参数 详情     RETURNS 指定从函数返回的值的数据类型   RETURN RETURN后面实际的变量或值是调用函数返回的值    1. 带有IN OUT INOUT参数的存储过程 DELIMITER $$ DROP PROCEDURE IF EXISTS sp_nested_loop$$ CREATE PROCEDURE sp_nested_loop(IN i INT, IN j INT, OUT x INT, OUT y INT, INOUT z INT) BEGIN DECLARE a INTEGER DEFAULT 0; DECLARE b INTEGER DEFAULT 0; DECLARE c INTEGER DEFAULT 0; WHILE a &amp;lt; i DO WHILE b &amp;lt; j DO SET c = c + 1; SET b = b + 1; END WHILE; SET a = a + 1; SET b = 0; END WHILE; SET x = a, y = c; SET z = x + y + z; END $$ DELIMITER ;  调用这个存储过程：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-44.html</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-44.html</guid>
      <description>流    参数名字 描述     流资源 由&amp;lt;schema&amp;gt;://&amp;lt;target&amp;gt;语法组成的数据提供程序    1. 注册流包装器 流包装器可以为一个或多个特定方案提供处理程序。
下面的例子显示了一个简单的流包装器，当流关闭的的时候发送一个PATCH的HTTP请求。
//注册FooWrapper类作为 foo://URL stream_wrapper_register(&amp;quot;foo&amp;quot;, FooWrapper::class, STREAM_IS_URL) or die(&amp;quot;Duplicate stream wrwapper registered&amp;quot;); class FooWrapper { public $context; private $url; public function stream_open(string $path, string $mode, int $options, string &amp;amp;$openedPath) : bool { $url = parse_url($path); if ($url === false) { return false; } $this-&amp;gt;url = $url[&#39;host&#39;] . &#39;/&#39; . $url[&#39;path&#39;]; return true; } public function stream_write(string $data) : int { $this-&amp;gt;buffer .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十九)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-29.html</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-29.html</guid>
      <description>错误码 1. 1064：语法错误 SELECT LastName, FirstName, FROM Person;  返回信息：
 Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &amp;lsquo;from Person&amp;rsquo; at line 2.
 从MySQL获取&amp;rdquo;1064 error&amp;rdquo;的错误信息意味着查询有语法错误。换句话说，MySQL不能有效解析查询语句。
错误信息中引号包围的信息时MySQL指出的自己不知道如何解析的查询的最开始的位置。在这个例子中，MySQL在上下文中无法理解&amp;rdquo;from Person&amp;rdquo;。在这个例子中，是在from Person中有一个额外的逗号。这个逗号告诉MySQL在SELECT语句中需要另外的一个列。
一个语法错误通常是这样的结构… near &#39;…&#39;。引号包围的部分是离错误最近的地方。想要定位一个错误，查看引号包围部分的最开始部分和引号前面的最后的部分。
有时候，你会遇到… near &#39;&#39;，这时候，引号中没有任何东西。这意味着MySQL不能指出错误在语句的开始还是结束位置。这通常意味着查询语句包含不完整的引号(&amp;lsquo;或者&amp;rdquo;)，或者不完整的括号，或者之前没有正确终止该语句。
对于存储例程，你可能忘记使用DELIMITER。
所以，当你遇到了一个1064错误，查看查询语句，查看错误信息中指明的位置。检查错误信息说明位置周围的查询语句。
如果你寻找某些人来帮助你解决一个1064错误，最好提供完整的查询语句和错误信息内容。
2. 1175：安全更新 这个错误通常出现在你更新或删除表中的记录，但是没有包含一个条件WHERE语句。
想要不出现这个错误，可以修改下面的配置项：
SET SQL_SAFE_UPDATES = 0;  重新启用的话，输入下面的内容：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-43.html</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-43.html</guid>
      <description>文件处理    参数 描述     filename 要读取的文件名称   use_include_path 如果你想要在include_path中搜索这个文件，可以选择可选的第二个参数，并且把这个参数设置为TRUE。   context 一个环境流资源    1. 便捷方法 1.1 原始直接IO file_get_contents和file_put_contents提供了在一次请求中便捷的从一个文件读取内容到字符串或者将字符串写入一个文件中。
file_put_contents也可以使用FILE_APPEND位标识符来像文件中追加内容，而不是截断或覆盖文件的内容。也可以使用LOCK_EX位标识符来为写文件操作增加一个额外的锁。位标识符可以使用|二进制或来添加。
$path = &#39;file.txt&#39;; //从文件中读取内容 $contents = file_get_contents($file); //做一些修改，比如讲CRLF替换为LF $contents = str_replace(&amp;quot;\r\n&amp;quot;, &amp;quot;\n&amp;quot;, $contents); //将修改后的内容写入文件 file_put_contents($path, $contents);  FILE_APPEND用来像日志文件追加内容，LOCK_FILE用来解决多个进程同时写内容的竞争冲突。例如，将当期session的内容写入文件中：
file_put_contents(&#39;logins.log&#39;, &amp;quot;{$_SESSION[&amp;quot;username&amp;quot;]} logged in&amp;quot;, FILE_APPEND | LOCK_EX);  1.2 CSV IO fgetcsv($file, $length, $separator)  fgetcsv解析读入的行并找出 CSV 格式的字段，成功返回一个包含这些字段的数组，失败的时候返回FALSE。
默认情况下，将只会读取CSV文件中的一行：
$file = fopen(&#39;contacts.csv&#39;, &amp;quot;r&amp;quot;); print_r(fgetcsv($file)); print_r(fgetcsv($file, 5, &amp;quot; &amp;quot;)); fclose($file);  contacts.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十八)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-28.html</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-28.html</guid>
      <description>MySQL表的锁 1. 行级锁 如果一个表是InnoDB引擎的，MySQL会自动使用行级锁，便于多个事务可以同时对一个表进行读写，而不用彼此等待。
如果两个事务视图修改同一个行并且两个事务都是用行级锁，那么一个事务需要等待另一个事务执行完毕。
也可以同通多对预期要修改的每一行使用SELECT … FRO UPDATE语句来获得。
假设有两个连接来详细介绍行级锁：
连接1
START TRANSACTION; SELECT ledgerAmount FROM accDetails WHERE id=1 FOR UPDATE:  在连接1中使用SELECT … FOR UPDATE来获取行级锁。
连接2
UPDATE accDetails SET ledgerAmount = ledgerAmount + 500 WHERE id=1;  但某些人在连接2中其他更新相同的行，将需要等待连接1事务执行完毕，或者达到innodb_lock_wait_timeout配置(默认的时间是50秒)的超时时间，出现一个错误。
 Error Code: 1205. Lock wait timeout exceeded; try restarting transaction  想要查看这个锁的详细信息，使用SHOW ENGINE INNODB STATUS。
---TRANSACTION 1973004, ACTIVE 7 sec updating mysql tables in use 1, locked 1 LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s) MySQL thread id 4, OS thread handle 0x7f996beac700, query id 30 localhost root update UPDATE accDetails SET ledgerAmount = ledgerAmount + 500 WHERE id=1 ------- TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:  连接2</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-42.html</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-42.html</guid>
      <description>魔术方法 __call()和__callStatic() __call()和__callStatic()将会在某些人调用不存在的对象方法或者静态方法的时候调用。
class Foo { /** * 这个方法将会在某些人调用对象不存在的方法时调用，像 * $foo-&amp;gt;method($arg, $arg1); * * 第一个参数是方法名称 就像上面的method * 第二个参数是由$arg和$arg1组成的数组 */ public function __call($method, $arguments) { $snakeName = CaseHelper::camelToSnake($method); $subMethod = substr($snakeName, 0, 3); $propertyName = substr($snakeName, 4); switch($subMethod) { case &#39;get&#39;: return $this-&amp;gt;data[$propertyName]; case &#39;set&#39;: $this-&amp;gt;data[$propertyName] = $arguments[0]; break; case &#39;has&#39;: return isset($this-&amp;gt;data[$propertyName]); default: throw new BadMethodCallException(&amp;quot;Undefined method $method&amp;quot;); } } public static function __callStatic($method, $arguments) { print_r(func_get_args()); } }  例子</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-27.html</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-27.html</guid>
      <description>删除表    参数 详情     TEMPORARY 可选。如果指定的话，只能使用DROP TABLE语句删除临时表   IF EXISTS 可选。如果指定，如果表不存在的话，DROP TABLE语句将不会报一个错误    1. 删除表 DROP TABLE可以用来删除数据库中的一个表。
创建表
创建一个名字为tbl的表，然后删除这个表。
CREATE TABLE tbl( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(100) NOT NULL, author VARCHAR(40) NOT NULL, submission_date DATE, PRIMARYY KEY (id) );  删除表
DROP TABLE tbl;   注意
删除表将会从数据库中删除表的全部信息，包括所有的信息，所以这个操作没法恢复。
 2. 从数据库删除表 DROP TABLE Database.table_name  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-41.html</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-41.html</guid>
      <description>Composer依赖关联    参数 详情     license 定义项目想要使用什么类型的证书   authors 定义项目的作者，包括作者的详细信息   support 定义支持邮寄，irc通道，其他的任何连接   require 定义实际依赖的包和包的版本信息   require-dev 定义开发这个项目必须的包   sugget 定义包的建议信息，包括这个包可以有什么作用   autoload 定义项目的自动加载逻辑   autoload-dev 定义开发这个项目的自动加载逻辑    Composer是PHP最常用的依赖管理工具。它就像是Node的npm，Python的pip，.NET的NuGet。
Composer是什么？ Composer是PHP的依赖/包管理工具。这可以用于安装，追踪，更新你的项目依赖。Composer也负责自动加载应用程序所依赖的依赖项，让你可以轻松的在项目中使用依赖项，而不必担心将他们包含在任何文件的顶部。
你项目的依赖信息都放在项目更目录中的composer.json文件中。这个文件包含生产环境和开发环境依赖的包的版本信息。
可以在Composer网站上看到一个composer.json的完整格式信息。
这个文件可以通过编辑器手动编辑，也可以通过composer require &amp;lt;package&amp;gt;或者composer require-dev &amp;lt;package&amp;gt;自动的进行添加。
想要在你的项目中使用composer，你需要在项目中创建composer.json文件。你可以手动创建这个文件，或者通过composer init这个命令创建。在你在终端中运行composer init之后，这将会让你提供项目的一些信息：项目名(vendor/package 例如 laravel/laravel)，描述(可选的)，作者和其他的一些信息，像最低稳定版本，许可证和依赖的包信息等等。
composer.json中的require关键字指明你项目依赖的包名。require关键字使用一个对象来存储包名(monolog/monolog)和相应的版本号。
{ &amp;quot;require&amp;quot;: { &amp;quot;composer/composer&amp;quot;: &amp;quot;1.2.*&amp;quot; } }  想要按照这里定义的依赖包的话，你需要使用composer install命令，这将会下载定义的指定版本的包，并把这个包下载到vendor目录。这非常方便的把第三方的代码放到vendor目录中。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十六)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-26.html</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-26.html</guid>
      <description>更改表 1. 修改存储引擎;重建表;修改file_per_table 例如，如果一个表t1当前不是InnoDB表，下面的语句将会修改这个表的存储引擎为InnoDB：
ALTER TABLE t1 ENGINE=InnoDB;  如果这个表已经是InnoDB存储引擎了，这个语句将会重建表和索引，并且和OPTIMIZE TABLE的操作效果相同。你可能获取一些硬盘空间的改进。
如果innodb_file_per_table的值和t1构建时的值不同，就会将这个值转换为(或从)file_per_table。
2. 修改表的列 CREATE TABLE stackoverflow; USE stackoverflow; CREATE TABLE stack( id_user INT NOT NULL, usernaem VARCHAR(30) NOT NULL, password VARCHAR(30) NOT NULL ); ALTER TABLE stack ADD COLUMN submit date NOT NULL; -- 增加新列 ALTER TABLE stack DROP COLUMN submit; -- 删除列 ALTER TABLE stack MODIFY submit DATETIME NOT NULL; -- 修改列类型 ALTER TABLE stack CHANGE submit submit_date DATETIME NOT NULL; -- 修改列类型和名称 ALTER TABLE stachk ADD COLUMN mod_id INT NOT NULL AFTER id_user; -- 增加新列在存在的列之后  3.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-40.html</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-40.html</guid>
      <description>Trait 什么是Trait PHP只允许单继承。换句话说，一个类只可以继承一个类。但是当你想要包含不在父类中的功能怎么办？在PHP5.4之前你必须要有创造性，但是在PHP5.4中，引入了Trait。Trait允许你&amp;rdquo;复制并粘贴&amp;rdquo;一个类的一部分到你的类中。
trait Talk { /** @var string */ public $phrase = &#39;Well Wilbur...&#39;; public function speak() { echo $this-&amp;gt;phrase; } } class MrEd extends Horse { use Talk; public function __construct() { $this-&amp;gt;speak(); } public function setPhrase($phrase) { $this-&amp;gt;phrase = $phrase; } }  现在我们有一个继承了Horse的MrEd类。但是不是所有的Horse类都具备Talk的功能，所以我们使用了Trait。注意这里我们是怎么做的。
首先，我们定义了我们的Trait。我们可以使用自动加载和命名空间。然后我们在MrEd中使用use关键字引入。
你注意到MrEd使用Talk的方法和变量但是没有定义他们。还记得我们之前说的&amp;rdquo;复制和粘贴&amp;rdquo;吗？这些方法和变量在类中定义了，就像这个类已经定义了这写方法和变量。
Trait和抽象类很像，定义了变量和方法。你不可以直接实现一个Trait(new Trait())。Trait不能像抽象类和接口那样，让一个类隐式定义一个方法。Trait只用于显示定义(因为你可以实现任意多个接口)。
什么时候应该使用Trait？
讨论Trait时，首先需要考虑的问题就是这个问题。
 我可以通过重构我的代码来避免使用Trait吗？
 答案往往是肯定的。Trait是有单一继承引起的边缘情况。滥用或过度使用Trait的可能性很高。但是考虑到Trait为代码引入了另外的源，这意味着还有另一层复杂性。在这个例子中，我们处理了3个类。但是Trait意味着你不止处理这些。对于每一个特性，您的类都变得更加难以处理，因为您现在必须参考每个特性来找出它定义了什么（并且可能在发生冲突的地方，请参见冲突解决）。理想情况下，代码中的特征应该尽可能少。
促进水平代码重用 假设我们有一个Log的接口：
interface Logger { function log($message); }  现在我们有两个Logger接口的实现类：FileLogger和ConsoleLogger：
class FileLogger implements Logger { public function log($message) { //添加代码实现 } } class ConsoleLogger implements Logger { public function log($message) { //添加实现 } }  现在如果你定义了一个Foo类，你想要实现一些日志任务，你可以像下面一样：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十五)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-25.html</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-25.html</guid>
      <description>创建表 1. 创建表带有主键 CREATE TABLE Person ( PersonID INT UNSIGNED NOT NULL, LastName VARCHAR(66) NOT NULL, FirstName VARCHAR(66), Address VARCHAR(255), City VARCHAR(66), PRIMARY KEY (PersonID) );  一个主键就是一个NOT NULL的单独或者多列的标识符，这个标识符可以表示表中唯一的行。创建了一个索引，但是没有显示声明为非空的话，MySQL将会以静默和隐式的方式声明他们。
一个表只可以有一个PRIMARY KEY，并且每个表都推荐有一个。InnoDB将会在不存在的情况下创建一个(像MySQL文档中说明的)，尽管这是不可取的。
通常，一个AUTO_INCREMENT INT被认为是&amp;rdquo;代理键&amp;rdquo;，用于索引优化和其他表的关系。当添加新纪录的时候，这个列的值(通常)会从默认值1开始加1。
然而，尽管它的名字是这个，但是目的不是为了保证值是递增的，而是保证值是连续的和唯一的。
一个递增的INT并不会恢复默认的初始值，当这个表的行都被删除的时候。除非这个表被truncate处理了，使用TRUNCATE TABLE语句。
定义一列为主键(行内定义)
如果主键只是一个单独的列的话，可以在列定义的行中添加PRIMARY KEY：
CREATE TABLE Person ( PersonID INT UNSIGNED NOT NULL PRIMARY KEY, LastName VARCHAR(66) NOT NULL, FirstName Varchar(66), Address Varchar(255), City VARCHAR(66) );  这个命令的格式是简单并且易读的。
定义多列为主键
定义主键包含多个列也是可能的。可能会在关联外键关系的子表中这么做。多列主键是通过在单独的主键子句中列出参与列来定义的。这里行内定义就不行了，行内主键定义只能用于当个列。例如：
CREATE TABLE invoice_line_items( LineNum SMALLINT UNSIGNED NOT NULL, InvoiceNum INT UNSIGNED NOT NULL, --- 其他列 PRIMARY KEY (InvoiceNum, LineNum), FOREIGN KEY (InvoiceNum) REFERENCES -- 一个表属性的引用 );  注意：主键的列应该按照逻辑顺序指定，这可能和列的定义顺序不一样，就像上面的例子一样。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十九）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-39.html</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-39.html</guid>
      <description>正则表达式    参数 详情     $pattern 一个正则表达式的字符串(PCRE)    全局正则表达式匹配 一个全局正则表达式匹配可以使用preg_match_all。preg_match_all返回目标字符串中所有匹配的结果(与只返回第一个匹配结果的preg_match不同)。
preg_match_all返回匹配的数量。$matches包含所有匹配到的结果，并且有第四个参数控制格式。
如果提供一个数组，$matches包含和preg_match返回相同的格式，除了preg_match在第一个匹配之后就终止，但是preg_match_all会迭代整个字符串，直到字符串处理完毕，返回一个包含匹配结果的多维数组，这个数组的格式有第四个参数控制。
第四个参数$flag控制$matches的格式。默认的值是PREG_PATTERN_ORDER，可能的其他值PREG_SET_ORDER和PREG_PATTERN_ORDER。
下面的代码展示栏preg_match_all的用法：
$subject = &#39;a1b c2d3e f4g&#39;; $pattern = &#39;/[a-z]([0-9])[a-z]/&#39;; var_dump(preg_match_all($pattern, $subject, $matches, PREG_SET_ORDER)); //int(3) var_dump($matches); preg_match_all($pattern, $subject, $matches); //默认使用PREG_PATTERN_ORDER var_dump($matches); preg_match($pattern, $subject, $matches); var_dump($matches);  第一个var_dump将会使用PREG_SET_ORDER作为第四个参数：
array(3) { [0]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;a1b&amp;quot; [1]=&amp;gt; string(1) &amp;quot;1&amp;quot; } [1]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;c2d&amp;quot; [1]=&amp;gt; string(1) &amp;quot;2&amp;quot; } [2]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;f4g&amp;quot; [1]=&amp;gt; string(1) &amp;quot;4&amp;quot; } }  $matchs有3个子数组，每个数组代表一个匹配结果，有着和preg_match相同的格式。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十四)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-24.html</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-24.html</guid>
      <description>视图    参数 详情     view_name 视图名称   SELECT 语句 要打包到视图中的SQL语句。它可以是一条SELECT语句，用于从一个或多个表中提取数据。    1. 创建视图 特权
CREATE VIEW语句需要视图的CREATE VIEW权限，以及SELECT语句选择的每一列的权限。对于SELECT语句中其他地方使用的列，必须具备SELECT权限。如果使用了OR REPLACE语句，你必须具有视图的DROP权限。依赖于DEFINER值，CREATE VIEW也需要SUPER权限，这在后面会说明。
当引用视图的时候，将会进行权限的检查。
一个视图是依赖于一个数据库的。默认情况下，一个新视图是在默认数据库上面创建的。想要显示在一个数据库上面创建视图，需要使用完整的数据库名。
例如：
db_name.view_name
mysql&amp;gt; CREATE VIEW test.v AS SELECT * FROM t;  注意：在一个数据库里面，基本的表和视图使用同一个命名空间，所以表和视图不能有相同的名字。
一个视图可以：
 可以从多种SELECT语句中创建 引用一个基本表或其他视图 使用join，union和子查询 SELECT甚至不需要引用任何表  另外的例子
下面的例子定义了一个视图，从另外的表中查询两个列表，和这两个列的计算表达式。
mysql&amp;gt; CREATE TABLE t(qty INT, price INT); mysql&amp;gt; INSERT INTO t VALUES(3, 50); mysql&amp;gt; CREATE VIEW v AS SELECT qty, price, qty * price AS value FROM t; mysql&amp;gt; SELECT * FROM v; +------+-------+-------+ | qty | price | value | +------+-------+-------+ | 3 | 50 | 150 | +------+-------+-------+  限制</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十八）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-38.html</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-38.html</guid>
      <description>解析HTML 从字符串解析HTML PHP实现了一个DOM Level 2的解析器，允许你使用getElementById()和appendChild()这样的方法来处理HTMl。
$html = &#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;span id=&amp;quot;text&amp;quot;&amp;gt;Hello World!&amp;lt;/span&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;; $doc = new DOMDocument(); libxm_use_internal_errors(true); $doc-&amp;gt;loadHTML($html); echo $doc-&amp;gt;getElementById(&#39;text&#39;)-&amp;gt;textContent;  输出：
Hello World!  注意对应HTML的问题，PHP都会发出警告，特别是在导入文档片段的时候。为了避免这些警告，通过libxml_use_internal_errors()来通知DOM库(libxml)处理自己的错误。如果需要的话，可以使用libxml_get_errors()来处理错误。
XPath $html = &#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;span class=&amp;quot;text&amp;quot;&amp;gt;Hello, World!&amp;lt;/span&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;; $doc = new DOMDocument(); $doc-&amp;gt;loadHTML($html); $xpath = new DOMXPath($doc); $span = $xpath-&amp;gt;query(&amp;quot;//span[@class=&#39;text&#39;]&amp;quot;)-&amp;gt;item(0); echo $span-&amp;gt;textContent;  输出：
Hello, World!  SimpleXML 介绍
 SimpleXML是一个提供了便捷处理XML文档的PHP库(特别是读取和迭代XML数据) 唯一的限制就是XML文档必须是格式良好的。  过程方法
// Load an XML string $xmlstr = file_get_contents(&#39;library.xml&#39;); $library = simplexml_load_string($xmlstr); // Load an XML file $library = simplexml_load_file(&#39;library.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十三)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-23.html</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-23.html</guid>
      <description>正则表达式 正则表达式是为复杂搜索指定模式的一种强大方法。
REGEXP / RLIKE REGEXP或者别名RLIKE运算符允许基于正则表达式的模式匹配。
假设有下面的employee的表：
+-------------+-------------+-------------+--------------+----------+ | EMPLOYEE_ID | FIRST_NAME | LAST_NAME | PHONE_NUMBER | SALARY | +-------------+-------------+-------------+--------------+----------+ | 100 | Steven | King | 515.123.4567 | 24000.00 | | 101 | Neena | Kochhar | 515.123.4568 | 17000.00 | | 102 | Lex | De Haan | 515.123.4569 | 17000.00 | | 103 | Alexander | Hunold | 590.423.4567 | 9000.00 | | 104 | Bruce | Ernst | 590.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十七）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-37.html</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-37.html</guid>
      <description>SimpleXML SimpleXML读取数据 字符串 使用simplexml_load_string从字符串创建一个SimpleXMLElement。
$xmlString = &amp;quot;&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&amp;gt;&amp;quot;; $xml = simplexml_load_string($xmlString) or die(&amp;quot;Error: Cannot create object&amp;quot;);  注意这里使用or而不是||,因为or的优先级比=低。or后面的代码只有在$xml解析为false时才会执行。
文件 使用simplexml_load_file从一个文件地址加载数据：
$xml = simplexml_load_string(&amp;quot;filePath.xml&amp;quot;); $xml = simplexml_load_string(&amp;quot;https://example.com/doc.xml&amp;quot;);  这个URL可以是任何PHP支持的格式，或者自定义的流封装。
参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十二)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-22.html</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-22.html</guid>
      <description>处理时区 获取指定时区的当前日期和时间 获取本地时区的NOW()值，获取印度时区的值，获取UTC的值。
SELECT NOW(); SET time_zone=&#39;Asia/Kolkata&#39;; SELECT NOW(); SET time_zone=&#39;UTC&#39;; SELECT NOW();  转换存储的DATE或DATETIME值到另外的时区 如果你在表中的某个列中存储了DATE或DATETIME格式的时间值，这是相对于某个时区的值，但是在MySQL中，时区是没有和值存储在一起的。如果你想要把这个时间转换为另外时区的时间，你可以做，但是你必须知道原本的时区值。然后使用CONVERT_TZ()来实现这个转换过程。下面的例子显示把UTC的时区的时间转换为California的时区时间。
SELECT CONVERT_TZ(date_sold, &#39;UTC&#39;, &#39;America/Los_Angeles&#39;) date_sold_local FROM sales WHERE state_sold=&#39;CA&#39;;  获取TIMESTAMP值的指定时区值 这非常简单。所有TIMESTAMP的值都是世界时间值，只需要设置你想要显示的time_zone时区值，就可以了。
SET SESSION time_zone=&#39;America/Los_Angeles&#39;; SELECT timestamp_sold FROM sales WHERE state_sold=&#39;CA&#39;;  为什么是这样？TIMESTAMP的值是基于UNIX time_t数据格式的。这些UNIX的时间戳存的是从1970:01:01 00:00:00 UTC到现在的秒数。
注意：TIMESTAMP存储的是世界时间。DATE和DATETIME存储是依赖存储时的时区。
本地时区配置 每个服务器都有一个默认的全局时区配置，由服务器的拥有者设置。你可以使用下面的命令查看当前的时区配置：
SELECT @@time_zone  不幸的是，这将会返回SYSTEM，这表示MySQL的时区使用服务器系统的时区配置。
下面的查询队列(是的，这有些hack)，会在几分钟内返回服务器时区配置和UTC的偏移量。
CREATE TEMPORARY TABLE times (dt DATETIME, ts TIMESTAMP); SET time_zone = &#39;+0:00&#39;; INSERT INTO times VALUES(NOW(), NOW()); SET time_zone = &#39;SYSTEM&#39;; SELECT dt, ts, TIMESTAMPDIFF(MINUTE, dt, ts)offset FROM times; DROP TEMPORARY TABLE times;  这是怎么实现的呢？临时表里面的两列有不同的时间格式。DATETIME存储当地时间到表里面，TIMESTAMP存储UTC时间到表里面。所以当时区设置为UTC的时候，INSERT语句插入列个完全相同的日期/时间值。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-36.html</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-36.html</guid>
      <description>XML 使用DomDocument创建XML 使用DomDocument创建XML，我们需要使用createElement()和createAttribute()来创建所有的标签和属性。然后会用appendChild()来创建XML的结构。
下面的例子包含标签，属性，CDATA部分和第二个标签的不同命名空间：
$dom = new DOMDocument(&#39;1.0&#39;, &#39;utf-8&#39;); $dom-&amp;gt;preserveWhiteSpace = false; $dom-&amp;gt;formatOutput = true; //创建没有值的主标签 $books = $dom-&amp;gt;createElement(&#39;books&#39;); $book_1 = $dom-&amp;gt;createElement(&#39;book&#39;); //创建带值的标签 $name_1 = $dom-&amp;gt;createElement(&#39;name&#39;, &#39;PHP - An Introduction&#39;); $price_1 = $dom-&amp;gt;createElement(&#39;price&#39;, &#39;$5.95&#39;); $id_1 = $dom-&amp;gt;createElement(&#39;id&#39;, &#39;1&#39;); //创建并添加属性 $attr_1 = $dom-&amp;gt;createAttribute(&#39;version&#39;); $attr_1 -&amp;gt; value = &#39;1.0&#39;; $id_1-&amp;gt;appendChild($attr_1); //创建第二个不同命名空间的标签 $namespace = &#39;www.example.com/libraryns/1.0&#39;; //在books标签前面添加命名空间 $books-&amp;gt;setAttributeNS(&#39;http://www.w3.org/2000/xmlns/&#39;, &#39;xmlns:ns&#39;, $namespace); $book_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:book&#39;); $name_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:name&#39;); //创建CDATA部分，并放入name标签 $name_cdata = $dom-&amp;gt;createCDATASection(&#39;PHP - Advanced&#39;); $name_2 -&amp;gt; appendChild($name_cdata); $price_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:price&#39;, &#39;$25.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十一)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-21.html</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-21.html</guid>
      <description>日期和时间运算 日期计算 NOW() + INTERVAL 1 DAY --明天的这个时间 CURDATE() - INTERVAL 4 DAY --4天之前的凌晨  线上3到10个小时之间（180分到600分之前）存储的mysql问题
SELECT qId,askDate,minuteDiff FROM ( SELECT qId,askDate TIMESTAMPDIFF(MINUTE, askDate, now()) as minuteDiff FROM questions_mysql ) xDerived WHERE minuteDiff BETWEEN 180 AND 600 ORDER BY qId DESC LIMIT 50; +----------+---------------------+------------+ | qId | askDate | minuteDiff | +----------+---------------------+------------+ | 38546828 | 2016-07-23 22:06:50 | 182 | | 38546733 | 2016-07-23 21:53:26 | 195 | | 38546707 | 2016-07-23 21:48:46 | 200 | | 38546687 | 2016-07-23 21:45:26 | 203 | | .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-35.html</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-35.html</guid>
      <description>依赖注入 依赖注入(DI)是&amp;rdquo;传入&amp;rdquo;的一种花哨说法。这实际含义就是对一个对象的依赖通过构造函数或set方法来传入，而不是在对象内部创建这些依赖对象。依赖注入也可能指的是自动构造和注入的依赖注入容器。
构造函数注入 对象通常依赖于另外的对象。相对于在构造函数中创建依赖对象，应该把依赖对象作为参数传入构造函数。这样可以确保对象之间没有紧密耦合，并且可以更改对类实例化的依赖性。这有许多好处，包括通过使依赖关系显式化使代码更容易阅读，以及使测试更简单，因为依赖关系可以更容易地被切换和模拟。
在下面的例子中，Component依赖一个Logger实例，但是它不创建这个实例。而是在构造函数中通过参数传入。
interface Logger { public function log(string $message); } class Component { private $logger; public function __construct(Logger $logger) { $this-&amp;gt;logger = $logger; } }  没有依赖注入的话，代码就像下面这样：
class Component { private $logger; public function __construct() { $this-&amp;gt;logger = new FooLogger(); } }  在构造函数中使用new来创建新对象表明没有使用依赖注入(或者使用不完全)，这里代码是高度绑定的。这也说明代码没有完全测试，或者可能有一些脆弱的测试，这些测试对程序状态做出错误的假设。
在上面的例子中，我们使用依赖注入，如果需要的话，我们可以很方便的修改使用不同的Logger对象。例如，我们可能需要使用不同的Logger实现来把日志存放到不同的位置，或者使用不同的日志格式，或者把日志存入数据库而不是文件。
Setter注入 依赖也可以使用setter方法进行注入：
interface Logger { public function log($message); } class Component { private $logger; private $databaseConnection; public function __construct(DatabaseConnection $databaseConnection) { $this-&amp;gt;databaseConnection = $databaseConnection; } public function setLogger(Logger $logger) { $this-&amp;gt;logger = $logger; } public function core() { $this-&amp;gt;logSave(); return $this-&amp;gt;databaseConnection-&amp;gt;save($this); } public function logSave() { if ($this-&amp;gt;logger) { $this-&amp;gt;logger-&amp;gt;log(&#39;saving&#39;); } } }  当类的core方法不依赖于依赖项的话，这是很有意思的。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-20.html</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-20.html</guid>
      <description>字符串运算符    名称 描述     ASCII() 返回最左侧字符的数值   BIN() 返回包含数字的二进制表示的字符串   BIT_LENGTH() 返回以位为单位的参数长度   CHAR() 返回整数参数对应的字符   CHAR_LENGTH() 返回参数中的字符数量   CONCAT() 返回拼接的字符串   CONCAT_WS() 返回指定分隔符拼接的字符串   ELT() 返回指定索引位置的字符串   EXPORT_SET() 返回一个字符串，使得对于值位中设置的每个位，您获得一个on字符串，并且对于每个未设置的位，您将获得一个off字符串   FIELD() 返回第一个参数在随后参数中的索引位置   FIELD_IN_SET() 返回第一个参数在第二个参数中的索引位置   FORMAT() 返回一个指定数量小数位格式化的数字   FROM_BASE64() 解码一个base64字符串并且返回结果   HEX() 返回十进制或字符串的十六进制表示   INSERT() 在指定位置插入一个子字符串，最多可插入指定的字符数   INSTR() 返回子字符串第一次出现的位置   LCASE() LOWER()的别名   LEFT() 返回指定的最左边的字符数   LENGH() 返回字符串的字节数量   LIKE 简单的模式匹配   LOAD_FILE() 加载命名的文件   LOCATE() 返回子串第一次初夏你的位置   LOWER() 返回参数的小写格式   LPAD() 返回字符串参数，用指定的字符串左填充   LTRIM() 删除前导空格   MAKE_SET() 返回一组逗号分隔的字符串，这些字符串在位集中具有相应的位   MATCH 全文本搜索   MID() 返回指定位置开始的子字符串   NOT LIKE 简单模式匹配的否定   NOT REGEXP 正则表达式的否定   OCT() 返回包含数字的八进制表示形式的字符串   OCT_LENGTH() LENGTH()方法的别名   ORD() 返回参数最左边的字符的字符代码   POSITION() LOCATE()的别名   QUOTE() 对SQL中的参数进行转义   REGEXP 正则表达式模式   REPEAT() 重复一个字符串指定的次数   REPLACE() 替换指定字符串的出现次数   REVERSE() 反转一个字符串的字符   RIGHT() 返回字符串指定最右边的值   RILIKE REGEXP 的别名   RPAD() 附加字符串指定的次数   RTRIM() 移除尾部的空格   SOUNDEX() 返回Soundex字符串   SOUNDS LIKE 比较读音   SPACE() 返回指定空格数的字符串   STRCMP() 比较两个字符串   SUBSTR() 返回指定的子字符串   SUBSTRING() 返回指定的子字符串   SUBSTRING_INDEX() 在指定的分隔符出现次数之前从字符串返回子字符串   TO_BASE64() 将参数转换为base64位字符串   TRIM() 移除开头和末尾的字符串   UCASE() UPPER()的别名   UNHEX() 返回一个包含数字十六进制表示的字符串   UPPER() 返回参数的大写格式   WEIGHT_STRING() 返回字符串的权重字符串    LENGTH() 返回字符串的字节数量。因为字符串的字符可能编码超过一个字节，所以想要获取字符的数量使用CHAR_LENGTH()。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-34.html</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-34.html</guid>
      <description>反射 类或对象的特征 类的特征检查可以使用property_exists和method_exists来实现。
class MyClass { public $public_field; protected $protected_field; private $private_field; static $static_field; const CONSTANT = 0; public function public_function() {} protected function protected_function() {} } // check properties $check = property_exists(&#39;MyClass&#39;, &#39;public_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;protected_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;private_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;static_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;other_field&#39;); // check methods $check = method_exists(&#39;MyClass&#39;, &#39;public_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;protected_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;private_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;static_function&#39;); // however.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十九)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-19.html</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-19.html</guid>
      <description>算术 算术运算符 MySQL提供了下面的算术运算符。
   运算符 名称 例子     + 加法 SELECT 3+5; -&amp;gt; 8 SELECT 3.5+5.5 -&amp;gt; 9.0 SELECT 3.5 + 2 -&amp;gt; 5.5   - 减法 SELECT 3 - 5; -&amp;gt; -2   * 乘法 SELECT 3 * 5; -&amp;gt; 15   / 除法 SELECT 20 / 4; -&amp;gt; 5 SELECT 355 / 133; -&amp;gt; 3.1416 SELECT 10.0 / 0; -&amp;gt; NULL   DIV 整除 SELECT 5 DIV 2; -&amp;gt; 2   % 或者 MOD 取余 SELECT 7 % 3; -&amp;gt; 1 SELECT 15 MOD 4; -&amp;gt; 3 SELECT 15 MOD -4; -&amp;gt; 3 SELECT -15 MOD 4; -&amp;gt; -3 SELECT -15 MOD -4; -&amp;gt; -3 SELECT 3 MOD 2.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-33.html</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-33.html</guid>
      <description>cURL扩展 curl_init 初始化一个cURL
   参数 详情     url 应用cURL请求的url网址    curl_setopt 设置cURL传输的选项
   参数 详情     ch cURL处理的对象(curl_inti()返回的值)   option CURLOPT_XXX将用来设置选项，查看PHP手册查看选项和接受值的列表   value 设置cURL选项的值    curl_exec 执行以cURL请求
   参数 详情     ch cURL处理的对象(curl_init()返回的值)    curl_close 结束一个cURL请求
   参数 详情     ch cURL处理的对象(curl_init()返回的值)    基本用法(GET请求) cURL是一个使用URL语法传输数据的工具。支持HTTP，FTP，SCP和其他的类型(curl&amp;gt;=7.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十八)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-18.html</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-18.html</guid>
      <description>UNION 使用UNION组合SELECT语句 你可以使用UNION来组合两个结果相同的查询的结果。
例如，你想要两个独立表的所有联系信息，authors和editors，你可以使用UNION关键字：
SELECT name, email, phone_number FROM authors UNION SELECT name, email, phone_number FROM editors;  使用UNION将会自动过滤重复信息。如果你想要保留重复信息，你可以使用UNION ALL。
组合不同列的数据 SELECT name. caption as title, year, pages FROM books UNION SELECT name. title, year, 0 as pages FROM movies;  将两个不同列的记录集组合时，使用默认值模拟确实的列。
ORDER BY 如果你需要排序UNION之后的结果集，使用下面的语法：
( SELECT ... ) UNION ( SELECT ... ) ORDER BY  如果没有添加括号的话，ORDER BY语句将会添加到最后的SELECT语句上面。
OFFSET分页 当在UNION上添加LIMIT的时候，下面这个语法可以使用:
( SELECT ... ORDER BY x LIMIT 10 ) UNION ( SELECT .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-32.html</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-32.html</guid>
      <description>SOAP客户端    参数 详情     $wsdl WSDL的URI，如果不是 WSDL模式的化，是Null   options Soap客户端的选项数组，非WSDL模式要设置location和uri，其他的选项是可选的。查看下面的值    WSDL模式 首先，创建一个新的SoapClient对象，传入一个WSDL文件的URL和选项的数组。
$soap = new SoapClient(&#39;https://example.com/soap.wsdl&#39;, [ &#39;soap_version&#39; =&amp;gt; SOAP_1_2, &#39;compression&#39; =&amp;gt; SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_GIZP, &#39;cache_wsdl&#39; =&amp;gt; WSDL_CACHE_BOTH, &#39;trace&#39; =&amp;gt; TRUE, &#39;exceptions&#39; =&amp;gt; TRUE ]);  然后使用$soap对象调用SOAP的方法：
$result = $soap-&amp;gt;requestData([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);  非WSDL模式 这个和WSDL模式相似的，传入WSDL文件的地址为NULL，必须传下location和uri选项。
$soap = new SoapClient(NULL, [ &#39;location&#39; =&amp;gt; &#39;https://example.com/soap/endpoint&#39;, &#39;uri&#39; =&amp;gt; &#39;namespace&#39; ]);  类图 当在PHP中创建SOAP客户端的时候，你可以使用classmap键的配置数组。classmap定义了WSDL实际使用的类型，而不是默认的stdClass。使用这个的原因是因为你可以获取这些类自实现的字段和方法调用，而不是猜测stdClass有什么字段。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-17.html</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-17.html</guid>
      <description>JOIN表带有相同列 join 3个带有相同列的表 CREATE TABLE Table1 ( id INT UNSIGNED NOT NULL, created_on DATE NOT NULL, PRIMARY KEY (id) ) CREATE TABLE Table2 ( id INT UNSIGNED NOT NULL, personName VARCHAR(255) NOT NULL, PRIMARY KEY (id) ) CREATE TABLE Table3 ( id INT UNSIGNED NOT NULL, accountName VARCHAR(255) NOT NULL, PRIMARY KEY (id) )  在建表之后，你就可以使用一个查询语句从三个表中寻找具有相同名称的id：
SELECT t1.id AS table1Id, t2.id AS table2Id, t3.id AS table3Id FROM Table1 t1 LEFT JOIN Table2 t2 ON t2.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-31.html</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-31.html</guid>
      <description>JSON json_encode
   参数 详情     value 进行编码的值。除了资源类型外其他都可以。所有字符串数据必须是UTF-8的格式。   options 二进制位标识符，包括JSON_HEX_QUOT,JSON_HET_TAG,JSON_HEX_AMP,JSON_HEX_APOS,JSON_NUMERIC_CHECK,JSON_PRETTY_PRINT,JSON_UNESCAPED_SLASHES,JSON_FORCE_OBJECT,JSON_PRESERVE_ZERO_FRACTION,JSON_UNESCAPED_UNICODE,JSON_PARTIAL_OUTPUT_ON_ERROR.这些常量的行为在jSON常量页有详细描述。   depth 设置最大的深度。必须是一个大于0的数    json_decode
   参数 详情     json 需要被解码的json字符串。这个函数只能处理UTF-8编码的字符串。   assoc 函数返回关联数组而不是对象   options JSON解码的二进制标识选项。当前只支持JSON_BIGINT_AS_STRING(默认会把大数字处理为浮点数)    JSON(JavaScript对象表示法)是一个平台和语言无关的将对象序列化到一个字符串的方法。因为这经常被用到web中，所以PHP中上线了一个JSON的基本扩展。
解码JSON字符串 json_decode()函数获取一个JSON编码的字符串作为第一个参数，将这个值解码到一个PHP变量中。
通常，json_decode()函数根据参数的不同会返回不同的结果，如果JSON对象的顶层元素是一个字典，将会返回一个\stdClass的对象；如果是一个数组，将会返回一个索引数组。对于某些标量值，像一些简单字符串&amp;rdquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;,&amp;ldquo;null&amp;rdquo;，将会返回标量值或NULL。在错误的时候将会返回Null。
$json_string = &#39;{&amp;quot;name&amp;quot;:&amp;quot;Jeff&amp;quot;, &amp;quot;age&amp;quot;:20, &amp;quot;active&amp;quot;:true, &amp;quot;colors&amp;quot;:[&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]}&#39;; $object = json_decode($json_string); //返回一个对象 printf(&amp;quot;Hello %s, You are %s years old.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-16.html</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-16.html</guid>
      <description>JOIN JOIN可视化效果 如果您是一个面向视觉的人，这个venn图可以帮助您理解MySQL中存在的不同类型的连接。
与子查询join(&amp;ldquo;派生&amp;rdquo;表) SELECT x,... FROM ( SELECT y, ... FROM ...) AS a JOIN tbl ON tbl.x = a.y WHERE ...  这将会执行一个子查询放入一个临时表，然后join这个临时tbl。
在5.6之前，临时表上面不能有索引，因此这可能是非常低效：
SELECT ... FROM ( SELECT y, ... FROM ... ) AS a JOIN ( SELECT x, ... FROM ... ) AS b WHERE ...  在5.6，优化器可以计算出最好的索引然后在运行中创建它(这会有一些开销，所以仍然不是&amp;rdquo;完美的&amp;rdquo;)。
另外通用的方式是在子查询中创建一些东西：
SELECT @n := @n + 1, ... FROM ( SELECT @n:=0 ) AS initialize JOIn the_real_table ORDER BY .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-30.html</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-30.html</guid>
      <description>输出缓存    方法 详细说明     ob_start() 开启输出缓存，任何这个位置之后的输出（处理http头）都会被捕获不会直接显示   ob_get_contents() 返回ob_start()捕获的内容   ob_end_clean() 清空输出缓冲区并为当前嵌套级别关闭它   ob_get_clean() 执行ob_get_contents()和ob_end_clean()两个操作   ob_get_level() 返回输出缓冲区的当前嵌套级别   ob_flush() 在不结束缓存的情况下，输出缓存的内容并发送给浏览器   ob_implict_flush() 开启隐式刷新，在每次输出之后都会刷新   ob_end_flush() 刷新内容缓冲区并将其发送到浏览器，同时结束缓冲区    获取内容并清空 输出缓存允许你把一些文本内容(text，html)存储到一个变量中，然后在脚本结束之后一次性发送给浏览器。默认情况下，PHP解析内容之后会直接发送给浏览器：
&amp;lt;?php //开启缓存 ob_start(); //输出内容 print &amp;quot;Hello&amp;quot;; //可以跳出php ?&amp;gt; &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt; &amp;lt;?php //获取缓存内容并情况缓存 $content = ob_get_clean(); # $content = ob_get_contents(); # $did_clear_buffer = ob_end_clean(); print($content); //Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;  在ob_start()和ob_get_clean()之间的内容输出会被放到变量$content中。调用ob_get_clean()相当于同时调用了ob_get_contents()和ob_end_clean()。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-15.html</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-15.html</guid>
      <description>ERROR 1055 最新版本的MySQL开始为之前的一些查询产生1055的错误。这个主题就是来介绍一下这样的错误。MySQL团队一直在努力让GROUP BY的扩展失效，或者至少让开发人员便于编写这样的查询。
无用GROUP BY返回不可预测的结果：墨菲定律 SELECT item.item_id, users.category, COUNT(*) number_of_uses FROM item JOIN uses ON item.item_id = uses.item_id GROUP item.item_id  将会显示 item表的行，并且显示表uses中关联的行数。也会显示uses.category中的值。
这个查询在(ONLY_FULL_GROUP_BY标识出现之前)MySQL中可以执行。这里使用了非标准的GROUP BY。
但是这有个问题：如果在JOIN语句的ON条件中匹配到了多个uses记录，那么MySQL将会从这些记录中返回一行的category字段值。哪一条？查询优化器，应用的用户都不能提前知道。准确的说：结果是不可预期的。MySQL将会返回任何想要返回的值。
*不可预期就是随机的*，有一个显著的区别。有人希望每次都有一个随机的选择。因此，如果一个选择的随机的，你可以在调试或测试中观察到这个情况。不可预期的结果是坏的：MySQL每次返回相同的结果，知道不相同了。有时候在新版本的MySQL中会有不同的结果。有时候这是导致问题的增长的表。什么会出问题，什么将会出问题，什么时候出问题你不知道。这叫做墨菲定律。
MySQL团队在努力让开发者更难犯这个错误。新版本的MySQL有一个叫做ONLY_GROUP_BY的sql_mod标签。当这个标识设置了，MySQL将会返回一个1055错误， 拒绝运行这个查询。
无用SELECT * ，如果修复 有时候有一个像下面这样的查询，在SELECT中使用*：
SELECT item.*, COUNT(*) number_of_uses FROM item JOIN uses ON item.item_id = uses.item_id GROUP BY item.item_id  当设置了ONLY_FULL_GROUP_BY，这样的查询就需要优化了。
要做优化的话，需要使用一个带有GROUP BY子句的子查询，让这个子查询返回每个item_id对应的number_of_uses字段。这个子查询很短也很简洁，因为它只需要查询uses表。
SELECT item_id, COUNT(*) number_of_uses FROM uses GROUP BY item_id;  然后我们和item表一起使用这个子查询：
SELECT item.*,usecount.number_of_uses FROM item JOIN ( SELECT item_id, COUNT(*) number_of_uses FROM uses GROUP BY item_id ) usecount ON item_item_id = usecount.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-29.html</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-29.html</guid>
      <description>Cookie    参数 详细说明     name cookie的名称。这个也是你可以从$_COOKIE中获取值的名称。这个是唯一必须的参数   value cookie中存储的值。这个数据可以从浏览器中访问，所以不要在这放敏感信息·   expire 一个代表cookie过期时间的Unix的时间戳。如果过期时间设置为0，cookie将会在session失效时同时失效。如果设置一个比当前时间早的时间戳，cookie会立即失效。   path cookie的范围。如果设置为/这个cookie会在整个域名下有效。如果设置为/somePath/cookie将会只在这个路径和这个路径的子路径中有效。默认cookie会设置为当前问文件的路径   domain cookie有效的域名和子域名。如果设置为一级域名stackoverflow.com，这个cookie会在这个域名和子域名中有效。如果设置为sub.stackoverflow.com，这个cookie只会在这个子域名和子域名的子域名下面有效。   secure 如果设置为true，这个cookie只有当客户端和服务端为https时才会设置。   httponly 指明这个cookie只能通过http/s协议进行设置，不能使用JavaScript这样的客户端语音设置。只在PHP5.2之后有效    一个HTTP的cookie就是：当用户浏览器浏览的时候，一些从服务器发送到用户端，并存储在用户电脑浏览器下面的数据。
修改cookie 可以使用setcookie来修改cookie中存储的值：
setcookie(&#39;user&#39;, &#39;John&#39;, time()+86400, &#39;/&#39;);   cookie是HTTP头的一部分，所有setcookie()方法需要在发送数据到浏览器之前调用。当修改cookie的时候，需要保证path和domain的参数和原来cookie的值一致，否则将会创建一个新的cookie。当你发送cookie的时候，cookie的值部分会被自动的进行urlencode操作。当接收cookie的时候，会被自动的decode并且赋值给cookie名称相同的变量中。
 设置cookie 使用setcookie方法来设置一个cookie。因为cookie是HTTP头的一部分，所以你必须在发送数据到浏览器之前设置cookie。例如：
setcookie(&#39;user&#39;, &#39;Tom&#39;, time( + 86400), &#39;/&#39;);  参数说明：
 创建一个名称为user的cookie (可选)为这个cookie设置值Tom (可选)这个cookie将会在1天之后过期 (可选)这个cookie在整个站点/中都有效 (可选)cookie只能使用HTTPS传输 (可选)cookie不能被类似JavaScript的脚本语言访问   创建或修改一个cookie只能在(path和domain指定的)子请求生效，在$_COOKIE也不是立即生效的。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-14.html</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-14.html</guid>
      <description>GROUP BY    参数 详情     expression1, expression2,&amp;hellip;expression_n 没有包含在聚合函数中的表达式必须是GROUP BY中的表达式   aggregate_function 像SUM COUNT MIN MAX 或者 AVG这样的函数   tables 你希望获取数据的表。在FROM语句中至少包含一个表   WHERE condition 可选的。要选择的记录必须满足的条件。    HAVING SELECT department, COUNT(*) AS &amp;quot;Man_Power&amp;quot; FROM employees GROUP BY department HAVING COUNT(*) &amp;gt;= 10;  使用GROUP BY … HAVING来过滤聚合记录类似于使用SELECT … WHERE过滤单个记录。
你也可以使用HAVING Man_Power &amp;gt;= 10因为在HAVING已经能够理解这些别名。
GROUP_CONCAT GROUP_CONCAT用来拼接表达式的值，而不是每个列一个结果。这意味着选择的多列会把作为一列返回&amp;rdquo;Name(1):Score(*)&amp;ldquo;。
Name Score Adam A+ Adam A- Adam B Adam C+ Bill D- John A- SELECT Name, GROUP_CONCAT(Score ORDER BY Score DESC SEPERATOR &amp;quot; &amp;quot;) AS Grades FROM Grade GROUP BY Name  结果</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-28.html</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-28.html</guid>
      <description>Session session_start() 开启PHP的session，我们可以给session_start函数传一个session的选项数组。例如：
&amp;lt;?php if(version_compare(PHP_VERSION, &#39;7.0.0&#39;) &amp;gt;= 0) { session_start([ &#39;cache_limiter&#39; =&amp;gt; &#39;private&#39;, &#39;read_and_close&#39; =&amp;gt; true, ]); } else { session_start(); }  这个功能在php.ini提供了新的配置项session.lazy_write，这个值默认是true，当session修改的时候session的数据将会被重写。
查看手册。
Session锁 正如我们知道的PHP会把session数据希尔服务器的一个文件中。当一个使用session_start启动session的脚本接收到一个请求的时候，PHP将会锁定这个session文件，从而阻止/等待同一session_id的其他请求。因此其他请求将会在session_start的位置阻塞，直到这个session文件释放锁定。
这个session文件将会被锁定，直到脚本执行完毕或者session手动关闭了。为了避免这种情况(避免多个请求被阻塞)。我们开启一个session并且当操作完毕之后关闭这个session，这样就会释放文件锁，其他的请求就可以继续进行。
// php &amp;lt; 7.0 // start session session_start(); // write data to session $_SESSION[&#39;id&#39;] = 123; // session file is locked, so other requests are blocked // close the session, release lock session_write_close();  现在有些人会想，如果session关闭，我们如何读取到session值。在session关闭后，session仍然是可用的。所以，我们仍然可以读取session数据。
echo $_SESSION[&#39;id&#39;]; //123  在PHP7.0之后，我们可以使用只读session，读写session，延迟写session，这样我们就没有必要使用session_write_close()。
操作session数据 $_SESSION就是一个数组，所以你可以像普通数组一样检索和操作它。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十三)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-13.html</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-13.html</guid>
      <description>ORDER BY 语境 下面的SELECT语句包含指定的顺序：
SELECT ... FROM ... WHERE ... GROUP by ... HAVING ... ORDER BY ... LIMIT ... OFFSET ...; (SELECT ... )UNION ( SELECT ... ) ORDER BY ... --排序union之后的结果 SELECT ... GROUP_CONCAT(DISTINCT x ORDER BY ... SEPARATOR ... ) ... ALTER TABLE ... ORDER BY ... -- 对MyISAM可能有用，对InnoDB无  基础用法 ORDER BY x
x可以是任何数据类型
 NULL比非NULL值优先 默认是ASC，升序 字符串(VARCHAR等)按照定义时的COLLATION来排序 ENUM按照定义时的顺序排序  升序/降序 ORDER BY x ASC -- 和默认行为一样 ORDER BY x DESC --降序 ORDER BY lastname,firstname --两列排序 ORDER BY submit_date DESC --最新的 ORDER BY submit_date DESC, id ASC -   ASC = Ascending DESC=Descending NULL首先出现，即使是降序 在上面的例子中，增加索引 INDEX(x) INDEX(lastname, firstname) INDEX(submit_date)可以提升性能  一些技巧 ORDER BY FIND_IN_SET(card_type, &amp;quot;MASTER-CARD, VISA, DISCOVER&amp;quot;) -- MASTER-CARD先 ORDER x IS NULL, x -- 按照x排序，NULL放最后  自定义排序</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-27.html</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-27.html</guid>
      <description>命名空间 声明命名空间 一个命名空间可以像下面这样：
 namespace MyProject 声明一个命名空间MyProject namespace MyProject\Security\Cryptography 声明一个嵌套的命名空间 namespace MyProject {…} 声明一个花括号包围的命名空间  虽然你可以在一个文件中声明多个命名空间，但是强烈建议一个文件只声明一个命名空间：
namespace First { class A { ... }; // Define class A in the namespace First. } namespace Second { class B { ... }; // Define class B in the namespace Second. } namespace { class C { ... }; // Define class C in the root namespace. }  每当你声明了一个命名空间，你在之后定义的类都在这个命名空间里面：
namespace MyProject\Shapes; class Rectangle { .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十二)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-12.html</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-12.html</guid>
      <description>UPDATE JOIN语句更新 考虑有一个生存表叫做questions_mysql和一个表示批量导入CSV数据的最后一个记录iwtQuestions使用LOAD_DATA_INFILE。工作表在导入前被截断，数据被导入，并且这个过程在这里不显示。
更新生产表数据使用一个和导入数据表的join语句。
UPDATE questions_mysql q JOIN iwtQuestions i ON i.qId = q.qId SET q.closeVotes = i.closeVotes, q.votes = i.votes, q.answers = i.answers, q.views = i.views;  这里别名q和i是变量使用表名的简写。这简化开发和可读性。
主键qId代表题目id。这里join匹配的四个列会被更新。
基本更新 更新一行
UPDATE customers SET email=&#39;luke_smith@email.com&#39; WHERE id=1;  这个查询语句更新customers表中id为1的记录的email字段的内容，这里修改为luke_smith@email.com。数据表中老内容和新内容在下面显示了：
更新所有行
UPDATE customers SET lastname=&#39;smith&#39;;  这个查询更新customers表中所有记录的lastname字段为smith。下面是老内容和新内容的对比：
注意：在UPDATE语句中使用WHERE是很必要的。如果你没有使用条件语句的话，表中所有记录都会被更新。在上面例子中customers表中所有记录的lastname都更新为smith。
批量更新 使用不同的值更新多行时，可以使用批量更新：
UPDATE people SET name = (CASE id WHEN 1 THEN &#39;Karl&#39; WHEN 2 THEN &#39;Tom&#39; WHEN 3 THEN &#39;Mary&#39; END) WHERE id IN (1, 2, 3);  这里使用一条查询更新多条记录而不是每行使用一条查询。这个CASE语句需要包含WHERE语句中的所有制。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-26.html</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-26.html</guid>
      <description>类和对象 类和对象通过将相同功能代码组合起来来提高代码的效率和减少代码的重复。
一个类用来定义一组生成对象的数据结构和行为。然后通过这个结构生成多个对象。
类常量 类常量提供了在程序中保存固定值的方式。也就是，他们提供了一种将名称(以及相关的编译时检查)赋予类似3.14和apple这样值的方法。类常量只能使用const关键字定义，不能使用define这个方法。
例如下面这个例子，定义了π在程序中的简短表示。在类中使用const来将这些值保存下来：
class MathValues { const PI = M_PI; const PHI = 1.61803; } $area = MathValues::PI * $radius * $radius;  类常量使用双冒号运算符(所谓的作用域解析运算符)来访问，很像静态变量。但是和静态变量不同的是，类常量是在编译时确定的，不能进行赋值操作(例如MathValues::PI = 7将会产生致命错误)。
类常量可以用来定义类内部的内容，这些内容稍后可能需要更改(但更改频率不足以保存到数据库)。我们可以在内部使用self域名解析器来处理它(在实例和静态实现中都有效)。
class Labor { const LABOR_UNITS = 0.26; // const LABOR_COST = 12.75; public function getLaborConst($number_units) { return (self::LABOR_UNITS * self::LABOR_COST) * $number_units; } }  在PHP5.6之前，类常量只需要包含标量值。
在PHP5.6我们可以在常量定义使用表达式，这包括：数学运算，字符串拼接。
class Labor { const LABOR_COSTS = 12.75 * 0.26; public function getLaborCost($number_units) { return self::LABOR_COSTS * $number_units; } }  在PHP7，我们可以使用define定义常量的值为数组。</description>
    </item>
    
    <item>
      <title>Java专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/java-section-1.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/java-section-1.html</guid>
      <description>开始学习java    Java SE 版本 代码名称 结束时间 发布日期     Java SE 10 None future 2018-03-20   Java SE 9 None future 2017-07-27   Java SE 8 Spider future 2014-03-18   Java SE 7 Dophin 2015-04-14 2011-07-28   Java SE 6 Mustang 2013-04-16 2006-12-23   Java SE 5 Tiger 2009-11-04 2004-10-04   Java SE 1.4 Merlin prior to 2009-11-04 2002-02-06   Java SE 1.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十一)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-11.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-11.html</guid>
      <description>DELETE    参数 详情     LOW_PRIORITY 如果提供了LOW_PRIORITY，删除操作只有在没有其他进程从数据表上读取数据的时候才会执行   IGNORE 如果提供了IGNORE，任何删除时遇到的错误都将忽略   table 你想要删除记录的表   WHERE conditions 指定要删除数据的条件表达式。如果没有指定条件的话，所有的表记录都会被删除。   ORDER BY expression 如果提供了ORDER BY，将会按照顺序删除记录   LIMIT 控制删除的最大记录数量。提供的number_rows将会被删除。    多表删除 MySQL的DELETE语句可以用于JOIN语句，允许指定需要删除的表。这用来避免嵌套语句很有用。下面是一个表：
create table people ( id int primary key, name varchar(100) not null, gender char(1) not null ); insert into people(id, name, gender) values (1, &#39;Kathy&#39;, &#39;f&#39;),(2, &#39;John&#39;, &#39;m&#39;),(3,&#39;Paul&#39;,&#39;m&#39;),(4,&#39;Kim&#39;,&#39;f&#39;); create table pets ( id int auto_increment primary key, ownerId int not null, name varchar(100) not null, color varchar(100) not null ); insert into pets(ownerId, name, color) values (1, &#39;Rover&#39;, &#39;beige&#39;), (2, &#39;Bubbles&#39;, &#39;purple&#39;), (3, &#39;Spot&#39;, &#39;black and white&#39;), (1, &#39;Rover2&#39;, &#39;white&#39;); id name gender 1 Kathy f 2 John m 3 Paul m 4 Kim f id ownerId name color 1 1 Rover beige 2 2 Bubbles purple 3 3 black and white 4 1 Rover2 white  如果你想要删除Paul的宠物：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-25.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-25.html</guid>
      <description>字符串解析 分割字符串 explode和strstr是用来是用分隔符获取字符串子串的方法。
一个字符串包含使用相同分隔符分割的几部分，可以使用explode将字符串分成几部分：
$fruits = &amp;quot;apple,pear,grapefruit,cherry&amp;quot;; print_r(explode(&#39;,&#39;, $fruits)); // [&#39;apple&#39;, &#39;pear&#39;, &#39;grapefruit&#39;, &#39;cherry&#39;]  这个方法支持一个参数，用来限制分割的子串数量：
$fruits = &#39;apple,pear,grapefruit,cherry&#39;; print_r(explode(&#39;,&#39;,$fruits,0)); // [&#39;apple,pear,grapefruit,cherry&#39;]  如果这个参数是0，将会按照1处理。
如果这个限制参数是大于0的值，将会返回最多包含这个值的子串，其中最后一个子串包含所有剩余的部分。
print_r(explode(&#39;,&#39;,$fruits,2)); // [&#39;apple&#39;, &#39;pear,grapefruit,cherry&#39;]  如果这个参数为负数，将会返回处理最后这几个子串之外的其他子串：
print_r(explode(&#39;,&#39;,$fruits,-1)); // [&#39;apple&#39;, &#39;pear&#39;, &#39;grapefruit&#39;]  explode可以使用list来把子串放入不同的变量中：
$email = &amp;quot;user@example.com&amp;quot;; list($name, $domain) = explode(&amp;quot;@&amp;quot;, $email);  但是要保证explode返回足够的值，否则将会参数index未定义的错误。
strstr将会把字符串分为两部分，然后根据第二个参数确定返回哪部分，默认返回后面的部分：
$string = &amp;quot;1:23:456&amp;quot;; echo json_encode(explode(&amp;quot;:&amp;quot;, $string)); // [&amp;quot;1&amp;quot;,&amp;quot;23&amp;quot;,&amp;quot;456&amp;quot;] var_dump(strstr($string, &amp;quot;:&amp;quot;)); // string(7) &amp;quot;:23:456&amp;quot; var_dump(strstr($string, &amp;quot;:&amp;quot;, true)); // string(1) &amp;quot;1&amp;quot;  子串 substr返回字符串指定开始位置和指定长度的子字符串。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-10.html</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-10.html</guid>
      <description>INSERT ON DUPLICATE KEY UPDATE INSERT INTO `table_name` (`index_field`, `other_field_1`, `other_filed_2`) VALUES (`index_value`, `insert_value`, `other_value`) ON DUPLICATE KEY UPDATE `other_field_1` = &#39;update_value&#39;, `other_field_2` = VALUES(`other_field_2`);  这将会在table_name中插入指定的值，但是当唯一键存在的时候，将会更新other_field_1的值为一个新值。
有时候，但重复主键时使用VALUES()来获取原本的值，而不是更新为一个新值。这种方式下，你可以使用INSERT和UPDATE设置不同的值。在上面的例子中，other_field_1在INSERT的时候设置为insert_value或者在UPDATE的时候设置为update_value。但是other_field_2将一直设置为other_value。
对于插入重复Key更新(IODKU)工作的至关重要的一样就是表 包含唯一的键，这将会是造成重复的原因。这个唯一的键可以是主键，也可以不是。它可以是单列的唯一键，也可以是多了的组合键。
插入多个行 INSERT INTO `my_table` (`field_1`, `field_2`) VALUES (&#39;data_1&#39;, &#39;data_2&#39;), (&#39;data_1&#39;, &#39;data_3&#39;), (&#39;data_4&#39;, &#39;data_5&#39;);  这是一次性添加多条记录的INSERT语句。
这种匹配插入数据的操作比一条一条的插入数据快的多。特别是一次插入100条数据是单条数据插入的10倍。
忽略已存在的行
在插入大行数据集时，在某些情况下，最好跳过通常由于列限制(如重复主键)而导致插入失败的情况。这可以通过INSERT IGNORE来实现这个功能。
假设有下面这样的数据：
SELECT * FROM `people`; --- Produces: +----+------+ | id | name | +----+------+ | 1 | john | | 2 | anna | +----+------+ INSERT IGNORE INTO `people` (`id`, `name`) VALUES (&#39;2&#39;, &#39;anna&#39;), -- 没有IGNORE的话，这行将会产生错误 (&#39;3&#39;， &#39;mike&#39;); SELECT * FROM `people`; --- Produces: +----+--------+ | id | name | +----+--------+ | 1 | john | | 2 | anna | | 3 | mike | +----+--------+  最重要的事是记住INSERT IGNORE也会静静的跳过那些错误，下面是MySQL文档的说明：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-24.html</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-24.html</guid>
      <description>字符串格式 字符串插值 你可以使用字符串插值在字符串中插入一个变量。字符串插值只在双引号字符串和heredoc表达式中有效。
$name = &#39;Joel&#39;; //$name会解析为Joel echo &amp;quot;&amp;lt;p&amp;gt;Hello $name, Nice to see you.&amp;lt;/p&amp;gt;&amp;quot;; //将会输出&amp;lt;p&amp;gt;Hello Joel, Nice to see you.&amp;lt;/p&amp;gt; //单引号，变量不会解析 echo &#39;Hello $name, Nice to see you.&#39;; //输出：Hello $name, Nice to see you.  复杂（花括号）语法提供了另一种在字符串中插入变量的语法，就是在变量的周围加上{}。这在变量和文本在一起时是很有用的，避免可能存在的变量和文本引起的歧义。
$name = &#39;Joel&#39;; // Example using the curly brace syntax for the variable $name echo &amp;quot;&amp;lt;p&amp;gt;We need more {$name}s to help us!&amp;lt;/p&amp;gt;&amp;quot;; #&amp;gt; &amp;quot;&amp;lt;p&amp;gt;We need more Joels to help us!&amp;lt;/p&amp;gt;&amp;quot; // This line will throw an error (as `$names` is not defined) echo &amp;quot;&amp;lt;p&amp;gt;We need more $names to help us!</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(九)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-09.html</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-09.html</guid>
      <description>MySQL的注释 增加注释 有多种类型的注释：
# 注释到行尾 -- 注释到行尾 /* 注释符号内部 */ /* 多行注释 */  例子：
SELECT * FROM t1; --这是一个注释 CREATE TABLE stack ( /* username varchar(30), */ id int );  —符号要求在符号后面，注释前面有一个空格，否则将认为是一个命令，并且引发一个错误。
#注释正常 /*注释正常*/ --注释错误  表定义注释 CREATE TABLE menagerie.bird( bird_id INT NOT NULL AUTO_INCREMENT, species VARCHAR(300) DEFAULT NULL COMMENT &#39;字段注释&#39;, INDEX idx_species(species) COMMENT &#39;索引&#39;， PRIMARY KEY (bird_id) ) ENGINE=InnoDB COMMENT &amp;quot;表注释&amp;quot;;  在COMMENT后面添加一个=是可选的。查看手册。
这些注释不像其他的注释，保存在schema中，可以使用SHOW CREATE TABLE或从information_schema中获取。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-23.html</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-23.html</guid>
      <description>控制结构备用语法 if/else语句 &amp;lt;?php if ($condition): do_something(); elseif ($another_condition): do_something_else(); else: do_something_different(); endif; ?&amp;gt; &amp;lt;?php if ($condition): ?&amp;gt; &amp;lt;p&amp;gt;Do something in HTML &amp;lt;/p&amp;gt; &amp;lt;?php elseif ($another_condition): ?&amp;gt; &amp;lt;p&amp;gt;Do something else in HTML&amp;lt;/p&amp;gt; &amp;lt;?php else: ?&amp;gt; &amp;lt;p&amp;gt;Do something different in HTML &amp;lt;/p&amp;gt; &amp;lt;?php endif; ?&amp;gt;  for &amp;lt;?php for ($i = 0; $i &amp;lt; 10; $i++): do_something($i); endfor; ?&amp;gt; &amp;lt;?php for ($i=0; $i &amp;lt; 10; $i++): ?&amp;gt; &amp;lt;p&amp;gt;Do something in HTML with &amp;lt;?</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(八)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-08.html</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-08.html</guid>
      <description>变量 设置变量 有一些方法来设置变量：
 可以使用SET将变量设置为特定的、字符串、数字和日期  SET @var_string = &amp;quot;my_var&amp;quot;; SET @var_num = &#39;2&#39;; SET @var_date = &#39;2015-07-20&#39;;   你可以使用下面的方法设置变量为select语句的结果：  Select @var := &#39;123&#39;; (注意：当你没有使用SET设置变量的时候，你需要使用:=，因为在其他的语句(select, update)中，&amp;quot;=&amp;quot;是用来比较的，所以当你在等号前面增加一个冒号的时候，这表明这不是一个比较语句，而是一个SET语句)   你可以使用INTO设置一个变量作为select语句的返回值  (当我需要动态选择要查询的分区时，这是特别有用的)
SET @start_date = &#39;2015-07-20&#39;; SET @end_date = &#39;2016-01-31&#39;; #这获取年月来确定使用的分区 SET @start_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @start_date)); SET @end_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @end_date)); #把分区放入变量 SELECT GROUP_CONCAT(partition_name) FROME information_schema.partitions p WHERE table_name=&#39;partitioned_table&#39; AND SUBSTRING_INDEX(partition_name, &#39;P&#39;, -1) BETWEEN @start_yearmonth AND @end_yearmonth INTO @partitions; #把查询放入变量。因为MySQL不会把我们的变量任务是一个变量，所有我们需要拼接语句并执行这个语句 SET @query = CONCAT(&#39;CREATE TABLE part_of_partitioned_table(PRIMARY KEY(id)) SELECT partitioned_table.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-22.html</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-22.html</guid>
      <description>函数式编程 PHP的函数式编程依赖于函数。PHP中的函数提供了组织和重用代码段的功能。函数简化了编码过程，防止冗余的代码，并使代码编译维护。这个主题描述了PHP中函数、形参，实参，返回语句和作用域的声明和使用。
闭包 闭包就是一个不能外部访问的匿名函数。
当声明一个匿名函数，你也就创建了这个函数的&amp;rdquo;命名空间&amp;rdquo;。它现在只有在这个命名空间可以访问。
$externalVariable = &amp;quot;Hello&amp;quot;; $secondExternalVariable = &amp;quot;Foo&amp;quot;; $myFunction = function() { var_dump($externalVariable, $secondExternalVariable); //返回错误，因为变量没有定义 };  这个函数没有访问外部变量的权限。想要使用外部的变量，你可以使用use()来将外部变量放入闭包函数内部：
$myFunction = function() use($externalVariable, $secondExternalVariable) { var_dump($externalVariable, $secondExternalVariable); };  这主要由于PHP严格变量范围：如果一个变量没有在命名空间中定义，并且没有使用global引入进来，这个变量就没有定义。
也要注意：
 从父命名空间继承变量和使用全局变量是不一样的。全局变量在全局命名空间中，不论函数在哪里执行。闭包函数的父命名空间是闭包定义的地方(而不是函数实际调用的地方)。
 查看PHP手册。
在PHP中，闭包使用早期绑定方法。这意味着使用use关键字传递给闭包命名空间的变量的值是闭包定义时的值。
想要修改这种行为的话，可以使用引用传值：
$rate = .05; $calculateTax = function($value) use ($rate) { return $value * $rate; } $rate = .1; print $calculateTax(100); //5 $rate = .05; $calculateTax = function($value) use (&amp;amp;$rate) { return $value * $rate; } $rate = .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(七)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-07.html</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-07.html</guid>
      <description>创建数据库    参数 详情     CREATE DATABASE 创建一个指定名称的数据库   CREATE SHEMA CREATE DATABASE 的别名   IF NOT EXISTS 如果指定的数据库存在的话，使用这个语句避免出现错误   create_specification create_specification指定的数据库的特征：像CHARACTER SET和COLLATE(数据库排序特征)    创建数据库，用户和授权 创建数据库。注意可以使用别名SCHEMA。
CREATE DATABASE Baseball; --创建名称为Baseball的数据库  如果数据库已经存在了，将会返回错误1007。想要避免这个错误，使用：
CREATE DATABASE IF NOT EXISTS Baseball;  相似的：
DROP DATABASE IF EXISTS Baseball; --当数据库存在时删除数据库 DROP DATABASE xyzl; --数据库如果不存在，返回1008错误  因为可以存在上面的错误，所以DDL语句通常和IF EXISTS一起使用。
用户创建数据库时，可以同时设置默认的字符集和排序规则，例如：
CREATE DATABASE Baseball CHARACTER SET utf8 COLLATE utf8_general_ci; SHOW CREATE TABLE Baseball; +----------+-------------------------------------------------------------------+ | Database | Create Database | +----------+-------------------------------------------------------------------+ | Baseball | CREATE DATABASE `Baseball` /*!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-21.html</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-21.html</guid>
      <description>函数 可变长度参数 Version&amp;gt;=5.6
PHP5.6提供了可变长度的参数列表。在变量名前添加…运算符表示这个变量是可变参数。这个变量将会包含这个位置之后所有参数的一个数组。
function variadic_func($nonVariadic, ...$variadic) { echo json_encode($variadic); } variadic_func(1, 2, 3, 4); // prints [2,3,4]  可以在...符号前面添加类型名称：
function foo(Bar ...$bars) {}  &amp;amp;可以添加在…之前，变量名称之后，就像下面这个例子：
class Foo{} function a(Foo &amp;amp;...$foos){ $i = 0; foreach($foos as &amp;amp;$foo){ // note the &amp;amp; $foo = $i++; } } $a = new Foo; $c = new Foo; $b =&amp;amp; $c; a($a, $b); var_dump($a, $b, $c);  这将会输出：
int(0) int(1) int(1)  另一方面，可以解压缩数组（或Traversable）以便以参数列表的形式传递给函数：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-06.html</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-06.html</guid>
      <description>Limit和Offset Limit和Offset的关系 假设有下面这样的users表：
   id username     1 User1   2 User2   3 User3   4 User4   5 User5    为了限制SELECT查询中返回的结果集数量，可以使用LIMIT语句加上一个或两个整数作为参数(0也可以)。
LIMIT语句一个参数
当只提供了一个参数，这将只会限制返回的行数：
SELECT * FROM users ORDER BY id ASC LIMIT 2; id username 1 User1 2 User2  如果参数是0的话，将会返回0个值。
还需要注意，这里ORDER BY语句是很重要的，用来指定第一行的结果(当按照另一列排序时)。
LIMIT使用两个参数
当LIMIT语句使用两个参数时：
 第一个参数表示从结果集中显示的行-这个值通常是offset，因为这个值表示受约束结果集的开始之前的行。这个值允许是0，表示非约束结果集的第一行。 第二个参数表示结果集要显示的最大结果数量。  查看下面的查询：
SELECT * FROM users ORDER BY id ASC LIMIT 2,3; id username 3 User3 4 User4 5 User5  注意当第一个参数为0时，这个结果集等价于只传入了一个参数。这意味着下面两个语句由相同的结果：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-20.html</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-20.html</guid>
      <description>循环 循环是编程语言非常重要的部分。这允许程序员创作循环执行几次的代码片段或者迭代处理。循环的次数可以是显示的(例如6次)，或者循环直到遇到了某个条件。
这个主题包括不同类型的循环结构，他们关联的控制结构，他们潜在的应用。
continue  continue中断一个循环中当前的迭代，但是不会中断这个循环。
 就像break语句一样，continu语句是在循环体内部的。当执行了continu语句，将会立即跳到循环条件判断语句。
在下面的例子中，循环根据数组的值输出指定的信息，但是跳过指定的值。
$list = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]; foreach ($list as $value) { if ($value == &#39;banana&#39;) { continue; } echo &amp;quot;I love to eat {$value} pie.&amp;quot; . PHP_EOL; }  这将会输出：
I love to eat apple pie. I love to eat cherry pie;  continue也可以用来中断外部循环通过为continue提供中断循环的级数。例如，data的数据向下面一样，为了找到花费小于5的水果派：
$data = [ [&#39;Fruit&#39; =&amp;gt; &#39;Apple&#39;, &#39;Color&#39; =&amp;gt; &#39;Red&#39;, &#39;Cost&#39; =&amp;gt; 1], [&#39;Fruit&#39; =&amp;gt; &#39;Banana&#39;, &#39;Color&#39; =&amp;gt; &#39;Yellow&#39;, &#39;Cost&#39; =&amp;gt; 7], [&#39;Fruit&#39; =&amp;gt; &#39;Cherry&#39;, &#39;Color&#39; =&amp;gt; &#39;Red&#39;, &#39;Cost&#39; =&amp;gt; 2], [&#39;Fruit&#39; =&amp;gt; &#39;Grape&#39;, &#39;Color&#39; =&amp;gt; &#39;Green&#39;, &#39;Cost&#39; =&amp;gt; 4] ]; foreach($data as $fruit) { foreach($fruit as $key =&amp;gt; $value) { if ($key == &#39;Cost&#39; &amp;amp;&amp;amp; $value &amp;gt;= 5) { continue 2; } } var_dump($fruit); }  当continue 2;执行的时候，程序立即跳转到$data as $fruit，然后开始执行下一个外部循环，调过了其他的代码(包括内部循环的条件语句)。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-05.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-05.html</guid>
      <description>NULL NULL的使用  不知道的数据：像end_date，rating 可选的数据：像middle_initial(尽管空字符是更加合适的) 0/0：某些运算的结果，像0除以0 NULL不等于空字符&amp;rdquo;&amp;ldquo;或者0 其他？  验证NULL  IS NULL或IS NOT NULL：= NULL将不会像你预期的一样 x &amp;lt;=&amp;gt; y是一种&amp;rdquo;null安全&amp;rdquo;的比较  在LEFT JOIN语句中检查a中的行在b中没有合适的行对应。
SELECT ... FROM a LEFT JOIN b ON ... WHERE b.id IS NULL:  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</guid>
      <description>控制结构 if else if语句允许当满足条件时，执行一段代码。当你想条件不满足时执行另外的代码可以使用if else。
if ($a &amp;gt; $b) { echo &amp;quot;a is greater than b&amp;quot;; } else { echo &amp;quot;a is not greater than b&amp;quot;; }  查看PHP手册。
三元运算符是if-else的短语法 三元预算符根据条件是true还是false来执行一些条件。这是一个比较预算符，通常用来将if-else语句变成简单的格式。这允许快速测试一个条件，然后通常用来替换多行的if语句，让你的代码更加紧凑。
下面就是一个三元运算符的例子，这里$a=1,$b=2:
echo ($a &amp;gt; $b) ? &amp;quot;a is greated than b&amp;quot; : &amp;quot;a is not greater than b&amp;quot;;  输出：a is not greater than b
控制结构备用语法 PHP提供了控制结构备用的语法：if while for foreach switch。
和普通的语法相比，不同的地方在于：这里使用:来代替开始花括号，使用endif; endwhile; endfor; endforeach; endswitch;来代替结束花括号。有关各个示例，请参阅有关控制结构的备用语法的主题。
if ($a == 42): echo &amp;quot;The answer to life, the universe and everything is 42.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-04.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-04.html</guid>
      <description>倒引号 倒引号用法 有很多例子在查询中使用倒引号，但是还是有很多人不清楚在什么时候或什么地方使用倒引号`。
倒引号主要用于防止一个调用&amp;rdquo;MySQL保留字&amp;rdquo;的错误。当你使用PHPmyAdmin创建一个表的时候，可能会遇到一个警告或提示：你正在使用MySQL的保留字。
例如，你创建一个包含字段&amp;rdquo;group&amp;rdquo;的表，你会遇到这个警告。这是因为你可能会使用下面的查询：
SELECT student_name, AVG(test_score) FROM student GROUP BY group;  为了确保你的查询不会出现错误，你可以在关键字上面增加倒引号：
SELECT student_name, AVG(test_score) FROM student GROUP BY `group`;  表
不仅仅列名需要添加倒引号，表名也需要添加倒引号。例如，当你需要JOIN多个表的时候：
SELECT `users`.`username`, `groups`.`group` FROM `users`;  易于阅读
正如你看到的，在表名或列表两边添加倒引号，也让查询更加容易阅读。
例如当你在书写全是小写时的查询时：
select student_name, AVG(test_score) from student group by group select `student_name`, AVG(`test_score`) from `student` group by `group`  查看MySQL关键字和保留字的手册。带有(R)标识的是保留字。其他的都是关键字。保留字需要特别小心。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</guid>
      <description>操作日期和时间 获取两个时间的差 最可行的方法是使用DateTime类。例如：
&amp;lt;?php //创建一个指定时间的对象 2年前 $twoYearAgo = new DateTime(&#39;2017-04-29 22:00:00&#39;); //创建一个当前时间的对象 $now = new DateTime(&#39;2019-04-29 22:00:00&#39;) //计算差 $diff = $now-&amp;gt;diff($twoYearAgo); //获取diff结果中的数据 $yearsDiff = $diff-&amp;gt;y; $monthsDiff = $diff-&amp;gt;m; $daysDiff = $diff-&amp;gt;d; $hoursDiff = $diff-&amp;gt;h; $minsDiff = $diff-&amp;gt;i; $secondsDiff = $diff-&amp;gt;s; //差别的天数 $totalDaysDiff = $diff-&amp;gt;days; var_dump($diff);  另外比较两个日期也是很简单的，直接使用比较运算符：
&amp;lt;?php // Create a date time object, which has the value of ~ two years ago $twoYearsAgo = new DateTime(&amp;quot;2014-01-18 20:05:56&amp;quot;); // Create a date time object, which has the value of ~ now $now = new DateTime(&amp;quot;2016-07-21 02:55:07&amp;quot;); var_dump($now &amp;gt; $twoYearsAgo); // prints bool(true) var_dump($twoYearsAgo &amp;gt; $now); // prints bool(false) var_dump($twoYearsAgo &amp;lt;= $twoYearsAgo); // prints bool(true) var_dump($now == $now); // prints bool(true)  转换日期格式 基本 最简单的转换日期的格式是联合使用strtotime和date。strtotime函数会把一个字符串时间转换为一个Unix时间戳。这个Unix的时间戳可以使用函数date转换为一个新的格式：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-03.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-03.html</guid>
      <description>SELECT SELECT语句用来从一个或多个表中获取搜索到的行。
DISTINCT 在SELECT后面添加DISTINCT表示删除重复的行。
CREATE TABLE `car` ( `car_id` INT UNSIGNED NOT NULL PRIMARY KEY, `name` VARCHAR(20), `price` DECIMAL(8,2) ); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (1, &#39;Audi A1&#39;, &#39;20000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (2, &#39;Audi A1&#39;, &#39;15000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (3, &#39;Audi A2&#39;, &#39;40000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (4, &#39;Audi A2&#39;, &#39;40000&#39;); SELECT DISTINCT `name`, `price` FROM CAR; ----------------- name | price Audi A1 | 20000.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</guid>
      <description>Datetime类 可变到不可变 从PHP5.6之前的可变版本到现在的不可变版本。
在PHP5.6之后创建一个\DateTimeImmutable类：
\DateTimeImmutable::createFromMutable($concrete);  在PHP5.6之前：
\DateTimeImmutable::createFromFormat(\DateTime::ISO8601, $mutable-&amp;gt;format(\DateTime::ISO8601), $mutable-&amp;gt;getTimezone());  加减日期间隔 我们可以使用DateInterval在DateTime对象上增加或减少一定时间间隔。
下面的例子，我们在对象上增加7天，然后打印输出到屏幕上面：
$now = new DateTime();// empty argument returns the current date $interval = new DateInterval(&#39;P7D&#39;);//this objet represents a 7 days interval $lastDay = $now-&amp;gt;add($interval); //this will return a DateTime object $formatedLastDay = $lastDay-&amp;gt;format(&#39;Y-m-d&#39;);//this method format the DateTime object and returns a String echo &amp;quot;Samara says: Seven Days. You&#39;ll be happy on $formatedLastDay.&amp;quot;;  这将会输出(在2019-04-29时运行)：
  Samara says: Seven Days.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-02.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-02.html</guid>
      <description>数据格式 CHAR(n) CHAR(n)是包含固定长度的n个字符的字符串。如果CHARACTER SET utf8mb4，这意味着它完全占用4个字节，不管里面包含什么文本。
大多数使用情况下CHAR(n)处理包含英文字符的字符串，因此应该设置ascii字符集(latin1也可以)。
country_code CHAR(2) CHARACTER SET ascii, postal_code CHAR(6) CHARACTER SET ascii, uuid CHAR(39) CHARACTER SET ascii, -- more discussion elsewhere  DATE DATETIME TIMESTAMP YEAR TIME DATE处理日期不包含时间部分。格式是&#39;YYYY-MM-DD&#39;，范围是1000-01-01到9999-12-31。
DATETIME是包含时间的日期格式&#39;YYYY-MM-DD HH:MM:SS&#39;。范围是1000-01-01 00:00:00到9999-12-31 23:59:59。
TIMESTAMP是整数类型的时间格式，包括日期和时间两部分。使用的范围是1970-01-01 00:00:01到2038-01-19 03:14:07 UTC (使用4个字节)
YEAR表示年份，范围从1901到2155(使用1个字节)
TIME表示一个&amp;rsquo;HH:MM:SS&amp;rsquo;格式的时间。范围从-838:59:59到838:59:59。
存储大小：
   数据类型 MySQL5.6.4之前 MySQL5.6.4及之后     YEAR 1字节 1字节   DATE 3字节 3字节   TIME 3字节 3字节+分数秒存储   DATETIME 8字节 5字节+分数秒存储   TIMESTAMP 4字节 4字节+分数秒存储    分数秒(5.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</guid>
      <description>一次处理多个数组 数组交集 array_intersect将会将所有数组中共有的值放入一个数组中。
$array_one = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]; $array_two = [&#39;two&#39;, &#39;three&#39;, &#39;four&#39;]; $array_three = [&#39;two&#39;, &#39;three&#39;]; $intersect = array_intersect($array_one, $array_two, $array_three); // $intersect contains [&#39;two&#39;, &#39;three&#39;]  第一个数组的key将会被保留，数字索引不会。
array_intersect只会检查数组的值，array_intersect_assoc将会对key也进行比较：
$array_one = [1 =&amp;gt; &#39;one&#39;,2 =&amp;gt; &#39;two&#39;,3 =&amp;gt; &#39;three&#39;]; $array_two = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;, 3 =&amp;gt; &#39;two&#39;, 4 =&amp;gt; &#39;three&#39;]; $array_three = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;]; $intersect = array_intersect_assoc($array_one, $array_two, $array_three); // $intersect contains [1 =&amp;gt;&#39;one&#39;,2 =&amp;gt; &#39;two&#39;]  array_intersect_key将会检查数组的key，将会返回数组中都存在的key：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(一)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-01.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-01.html</guid>
      <description>开始学习MySQL 版本历史
   1.0 1995-05-23     3.19 1996-12-01   3.20 1997-01-01   3.21 1998-10-01   3.22 1999-10-01   3.23 2001-01-22   4.0 2003-03-01   4.1 2004-10-01   5.0 2005-10-01   5.1 2008-11-27   5.5 2010-11-01   5.6 2013-02-01   5.7 2015-10-01    开始 创建MySQL数据库 CREATE DATABASE mydb;  返回：
 Query OK, 1 row affected (0.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</guid>
      <description>操作数组 筛选数组 从数组中筛选值，并且把按照筛选条件找出的值放入一个新数组中，可以使用array_filter函数。
筛选非空数组 一个简单例子来筛选非空的值：
$myArray = [1, 0, 2, null, 3, &#39;&#39;, 4, [], 5, 6, 7, 8]; $nonEmpties = array_filter($myArray); //[1, 2, 3, 4, 5, 6, 7, 8];  使用回调筛选 我们可以定义我们自己的筛选规则。这里假设我们想要偶数值：
$myArray = [1, 2, 3, 4, 5, 6, 7, 8]; $evenNumbers = array_filter($myArray, function($number) { return $number % 2 === 0; })  array_filter的第一个参数是等待筛选的数组，第二个参数是定义筛选规则的回调函数。
按索引筛选 Version &amp;gt;= 5.6
array_filter的第三个参数是用来决定哪个值传递给回调函数。这个参数有两个选项：ARRAY_FILTER_USE_KEY 或 ARRAY_FILTER_USE_BOTH。这决定回调函数的参数是数组的key还是key和值都有。例如，你想要使用索引而不是值：
$numbers = [16,3,5,8,1,4,6]; $even_indexed_numbers = array_filter($numbers, function($index) { return $index % 2 === 0; }, ARRAY_FILTER_USE_KEY);  筛选结果数组的索引 注意：array_filter函数会保留原本数组的key。一个常见的错误是使用for循环处理筛选后的数组：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</link>
      <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</guid>
      <description>对数组操作 对数组每个元素进行函数处理 对数组每一个元素进行函数的处理，使用array_map函数。这将会返回一个新的数组。
$array = array(1,2,3,4,5); //each array item is iterated over and gets stored in the function parameter. $newArray = array_map(function($item) { return $item + 1; }, $array);  返回的新数组$newArray的值是array(2,3,4,5,6)。
除了使用匿名函数外，还可以使用一个命名的函数。上面的例子也可以写成下面这样：
function addOne($item) { return $item + 1; } $array = array(1, 2, 3, 4, 5); $newArray = array_map(&#39;addOne&#39;, $array);  如果这个命名函数是一个类的方法，在使用的时候需要保护类的一个对象：
class Example { public function addOne($item) { return $item + 1; } public function doCalculation() { $array = array(1, 2, 3, 4, 5); $newArray = array_map(array($this, &#39;addOne&#39;), $array); } }  另外的对数组每个元素使用方法的函数是array_walk()和array_walk_recursive()。在这些函数中使用的调用函数解释数组每个元素的键/值作为参数。这两个函数不返回一个新的数组，而是函数执行成功与否的布尔值。例如：打印一个简单数组的每个元素：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</guid>
      <description>数组迭代 一次迭代多个数组 有时候两个数组由相同的长度，需要一起迭代处理：
$people = [&#39;Tim&#39;, &#39;Tony&#39;, &#39;Turanga&#39;]; $foods = [&#39;chicken&#39;, &#39;beef&#39;, &#39;slurm&#39;];  array_map可以简单的实现这个要求：
array_map(function($person, $food) { retrun &amp;quot;$person likes $food\n&amp;quot;; }, $people, $foods);  这将会输出：
Tim likes chicken Tony likes beef Turanga likes slurm  这可以通过索引来实现：
assert(count($people) === count($foods)); for ($i = 0; $i &amp;lt; count($people); $i++) { echo &amp;quot;$people[$i] likes $foods[$i]\n&amp;quot;; }  如果没有递增的索引值，需要使用array_values($array)[$i]来代替$array[$i]。
如果两个数组拥有相同的索引，可以使用foreach来处理其中的一个数组：
foreach ($people as $index =&amp;gt; $person) { $food = $foods[$index]; echo &amp;quot;$person likes $food\n&amp;quot;; }  不同的数组只有当它们的长度一样，并且拥有一样的key时，才可以这么处理。这意味着要么多个数组是数字递增的，要么它们是相同的key按照相同的顺序排列的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</link>
      <pubDate>Fri, 12 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</guid>
      <description>数组    参数 详情     Key key是数组唯一的标识和索引。可以是string和integer。因此有效的key包括foo 5 10 a2b   Value 对于每个key都有一个值和其对应（否知就是null，在访问是会出问题）。这个值没有严格限制的类型    一个数组就是存储任意个元素到单独一个值中的数据结构。PHP中的数组实际是一个有序的映射，其中映射是一种键值关联的结构。
数组初始化 一个数组可以是空的。
//空数组 $foo = array(); //从PHP5.4的简短格式 $foo = [];  一个数组可以初始化，并且有值：
//创建3个值的简单数组 $fruit = array(&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;); //5.4之后的简短格式 $fruit = [&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;];  一个数组可以带有自定义索引的值（这时数组叫关联数组）：
//简单关联数组 $fruit = array( &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ); //也可以在之后赋值 $fruit[&#39;first&#39;] = &#39;apples&#39;; //短格式 $fruit = [ &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ];  如果一个变量之前没有用过，PHP将自动创建。虽然方便了，但也让代码更加难读了：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</guid>
      <description>引用 引用赋值 这是引用使用的第一个阶段。实际你在引用赋值的时候，这里允许你两个变量拥有相同的值。
$foo = &amp;amp;$bar;  $foo和$bar是相等的。它们指向相同的地址，而不是不同的地址。
你也可以在array()语言结构中使用引用赋值。并不是严格的引用赋值：
$foo = &#39;hi&#39;; $bar = array(1, 2); $array = array(&amp;amp;$foo, &amp;amp;$bar[0]);   注意：数组里面的引用是非常危险的一种行为。使用右侧引用对左侧进行普通赋值不会将左边变为引用。但是数组中这样的赋值引用将会被保留。在函数中，数组作为值传递时也有这个问题。
 引用赋值不限制在变量和数组中。在函数和所有&amp;rdquo;引用传递的值&amp;rdquo;都可以。
function incrementArray(&amp;amp;$arr) { foreach ($arr as $$val) { $var++; } } function &amp;amp;getArray() { statice $arr = [1, 2, 3]; return $arr; } incremetnArray(getArray()); var_dump(getArray()); //[2,3,4]  赋值是上面函数定义的关键点。不能通过引用传递表达式，只能传递值/变量。
返回引用 偶尔会出现让你通过引用隐藏返回的情况。
 引用返回在函数定义的参数是引用变量的时候非常有用。不要用返回引用来提升性能。PHP引擎会自动处理这些问题。只有在您有有效的技术原因时才返回引用。
 查看返回引用的PHP文档。
有很多不同的方式可以返回引用，包括下面的例子：
function parent(&amp;amp;$var) { echo $var; $var = &amp;quot;updated&amp;quot;; } function &amp;amp;child() { static $a = &amp;quot;test&amp;quot;; return $a; } parent(child()); //返回test parent(child()); //返回updated  引用返回不仅限于函数引用。您还可以隐式调用函数：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</guid>
      <description>运算符 一个运算符就是处理一个或多个值(或表达式，编程术语)，然后产生一个新的值(把本身构造成表达式)的符号。
可以根据运算符操作的数量把它们进行分组。
空合并运算符?? 空合并运算符是PHP7新增加的运算符。如果第一个操作数设置了并不为null，就返回这个运算符。否则返回第二个运算符的值。
下面是一个例子：
$name = $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面这个例子是等价的：
if (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  也和下面等价：
$name = isset($_POST[&#39;name&#39;]) ? $_POST[&#39;name&#39;] : &#39;nobody&#39;;  这个操作符也可以连着使用，从左到右进行处理：
$name = $_GET[&#39;name&#39;] ?? $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面是等价的:
if (isset($_GET[&#39;name&#39;])) { $name = $_GET[&#39;name&#39;]; } elseif (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  注意在字符串中使用空合并运算符，不要忘了使用括号：
$firstName = &amp;quot;John&amp;quot;; $lastName = &amp;quot;Doe&amp;quot;; echo $firstName ?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</guid>
      <description>类型 类型比较符 两种类型的比较符：松散比较符==和严格比较符===。严格比较符要求比较符两端的变量的类型和值都要相同。
// Loose comparisons var_dump(1 == 1); // true var_dump(1 == &amp;quot;1&amp;quot;); // true var_dump(1 == true); // true var_dump(0 == false); // true // Strict comparisons var_dump(1 === 1); // true var_dump(1 === &amp;quot;1&amp;quot;); // false var_dump(1 === true); // false var_dump(0 === false); // false // Notable exception: NAN — it never is equal to anything var_dump(NAN == NAN); // false var_dump(NAN === NAN); // false  你也可以使用严格比较符的相对于的反比较符!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</guid>
      <description>代码注释 单行注释 单行注释使用//或#开头。当遇到的时候，所有符号右边的文本都被PHP解析器忽略。
// This is a comment # This is also a comment echo &amp;quot;Hello World!&amp;quot;; // This is also a comment, beginning where we see &amp;quot;//&amp;quot;  多行注释 多行注释可以用来注释大块的代码，使用/*做开始，*/做结尾。
/* This is a multi-line comment. It spans multiple lines. This is still part of the comment. */  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</guid>
      <description>魔术常量 __FUNCTION__和__METHOD__的不同 __FUNCTION__只返回函数的名称，__METHOD__返回带有类名的函数名称：
&amp;lt;?php class trick { public function doit() { echo __FUNCTION__; } public function doitagain() { echo __METHOD__; } } $obj = new trick(); $obj-&amp;gt;doit(); // Outputs: doit $obj-&amp;gt;doitagain(); // Outputs: trick::doitagain  __CLASS__、get_class和get_called_class的不同 __CLASS__和get_class没有参数情况下的结果一样，都是这两者定义所在的类的名称(调用这个常量或方法的地方)。
相反，get_class($this)和get_called_class()函数都会返回实际调用的类的名称。
&amp;lt;?php class Definition_Class { public function say(){ echo &#39;__CLASS__ value: &#39; . __CLASS__ . &amp;quot;\n&amp;quot;; echo &#39;get_called_class() value: &#39; . get_called_class() . &amp;quot;\n&amp;quot;; echo &#39;get_class($this) value: &#39; . get_class($this) . &amp;quot;\n&amp;quot;; echo &#39;get_class() value: &#39; .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</link>
      <pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</guid>
      <description>常量 定义常量 常量可以使用const语句或者define函数定义。惯例是使用全大写字母作为常量的名称。
明确值定义常量 const PI = 3.14; //float define(&amp;quot;EARTH_IS_FLAT&amp;quot;, false); //boolean const UNKNOWN = null; //null define(&amp;quot;APP_ENV&amp;quot;, &amp;quot;dev&amp;quot;); //string const MAX_SESSION_TIME = 60 * 60; //integer，标量表达式也是可以的 const APP_LANGUAGES = [&amp;quot;de&amp;quot;, &amp;quot;en&amp;quot;]; //数组 define(&amp;quot;BETTER_APP_LANGUAGES&amp;quot;, [&amp;quot;lu&amp;quot;, &amp;quot;de&amp;quot;]); //数组  用常量定义常量 如果你有一个常量，你可以用这个常量定义另外的常量。
cosnt TAU = PI * 2; define(&amp;quot;EARTH_IS_ROUND&amp;quot;, !EARTH_IS_FLAT); define(&amp;quot;MORE_UNKNOWN&amp;quot;, UNKNOWN); define(&amp;quot;APP_ENV_UPPERCASE&amp;quot;, strtoupper(APP_ENV)); //字符串操作也是可以的 //上面的示例(函数调用)不适合const语句 //cosnt TIME = time(); 出现致命错误，不是标量表达式 define(&amp;quot;MAX_SESSION_TIME_IN_MINUTES&amp;quot;, MAX_SESSION_TIME / 60); const APP_FUTURE_LANGUAGES = [-1 =&amp;gt; &#39;es&#39;] + APP_LANGUAGES; //数组操作 define(&amp;quot;APP_BETTER_FUTURE_LANGUAGES&amp;quot;, array_merge([&#39;fr&#39;], APP_BETTER_LANGUAGES));  保留常量 一些常量名称是被PHP保留的，不能被重新定义。下面的例子都是失败的：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</link>
      <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</guid>
      <description>输出变量的值 创建一个动态的、交互的PHP项目，输出变量和他们的值是有用的。PHP提供了多个变量值的输出方法。这里主要介绍标准的输出方法和这些方法的使用场景。
echo和print echo和print是语言结构，不是函数。这意味着它们不想函数那样需要括号在参数的周围(当然也可以在参数的周围添加括号，这样也没有什么问题)。这将会输出变量、常量和表达式的字符串格式。不能用来输出数组和对象。
 把字符串joel赋值给变量$name   $name = &#39;joel&#39;;   使用echo和print来输出$name的值   echo $name; #&amp;gt; Joel print $name; #&amp;gt; Joel   括号不是要求的，但是可以使用   echo($name); #&amp;gt; Joel print($name); #&amp;gt; Joel   使用多个参数(只有echo支持)   echo $name, &amp;quot;Smith&amp;quot;; #&amp;gt; JoelSmith echo($name, &amp;quot; &amp;quot;, &amp;quot;Smith&amp;quot;); #&amp;gt; Joel Smith   print不像echo，是一个返回值为1的表达式，可以被用在更多的地方   print(&amp;quot;hey&amp;quot;) &amp;amp;&amp;amp; print(&amp;quot; &amp;quot;) &amp;amp;&amp;amp; print(&amp;quot;you&amp;quot;); #&amp;gt; you11   下面和上面是相等的   print (&amp;quot;hey&amp;quot; &amp;amp;&amp;amp; (print (&amp;quot; &amp;quot; &amp;amp;&amp;amp; print &amp;quot;you&amp;quot;))); #&amp;gt; you11  echo的简短写法 在outside of PHP tags，echo的简短写法是有效的。使用&amp;lt;?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</guid>
      <description>超全局变量 超全局变量是内建的在任何地方都一直有效的变量。
一些预定义的PHP变量叫做&amp;rdquo;超全局变量&amp;rdquo;，这意味着这些变量在一个脚本的任何作用域都是有效的。不用在函数或方法内使用global $variable来访问这些变量。
超全局变量解释 简介 简单来说，这些变量就是在你的脚本中全部作用域有效的变量。
这意味着没有必要把它们作为参数传递给你的函数，或者为了让不同的作用域访问这些变量把他们存放在块作用域之外。
什么是超全局变量？ 如果你认为它们就像超级英雄一样-它们不是的。
在PHP 7.1.3之后，有9个超全局变量，下面是它们的列表：
 $GLOBALS：包含所有的全局变量 $_SERVER：服务器和执行环境的信息 $_GET：HTTP GET的变量 $_POST：HTTP POST的变量 $_FILES：HTTP文件上传变量 $_COOKIE：HTTP的Cookie $_SESSION：Session变量 $_REQUEST：HTTP的请求变量 $_ENV：环境变量  查看文档。
更多信息 这里是它的参考资料。
是时候解释这些超全局变量了。
$GLOBALS  一个定义了当前脚本定义的所有全局作用域的变量的关联数组。变量名就是这个数组的键。
 代码：
$myGlobal = &amp;quot;global&amp;quot;; function test() { $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&#39;myGlobal&#39;]); } test(); var_dump($myLocal); var_dump($myGlobal);  输出：
string &#39;local&#39; (length=5) string &#39;global&#39; (length=6) null string &#39;global&#39; (length=6)  在上面的例子中$myLocal第二次没有显示因为这个变量定义在函数test()内部，当函数关闭之后这个变量就销毁了。
变为全局 实现这个有两种方法。
第一种方法：global关键字
function test() { global $myLocal; $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&amp;quot;myGloabl&amp;quot;]); }  这个关键字global放到变量前面，强制这个变量变为全局作用域变量。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-66.html</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-66.html</guid>
      <description>陷阱 赋值时空格 赋值时出现空格：
foo = &#39;bar&#39; # incorrect foo= &#39;bar&#39; # incorrect foo=&#39;bar&#39; # correct  前两个会出现语法错误(或者执行一个错误的命令)。最后一个会正确的为变量foo设置值bar。
失败的命令不停止脚本执行 在大多数的脚本语言中，如果一个函数错了，将会抛出一个异常并且终止程序的执行。Bash没有异常，但是有退出码。一个非零的退出码代表出现了错误，但是这并不会终止程序的执行。
这可能会导致危险（尽管诚然是人为的）情况，如：
#!/bin/bash cd ~/non/existent/directory rm -rf *  如果cd命令失败了，Bash会忽略失败，并且继续执行下面的命令。将会清除你运行命令文件夹的所有文件。
最好的方法是使用set命令：
#!/bin/bash set -e cd ~/non/existent/directory rm -rf *  set -e告诉Bash如果遇到一个非零的返回值，直接终端执行。
缺少文件中的最后一行 C标准规定文件要以新行结束，所以如果EOF出现在行尾，那么某些命令可能不会遗漏这行。例如：
$ echo &#39;one\ntwo\nthree\c&#39; &amp;gt; file.txt $ cat file.txt one two three $ while read line ; do echo &amp;quot;line $line&amp;quot; ; done &amp;lt; file.txt one two  想要修复这个问题的话，就测试最后一行是否为空，不为空继续执行：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</guid>
      <description>变量作用域 变量作用域表示变量可以被访问到的代码范围。这也经常被称为可见性。PHP的块作用域是函数，类定义的。一个全局作用域变量在整个应用都是有效的。
超全局变量 超全局变量是PHP定义的，可以在任何地方使用而不需要使用global关键字。
&amp;lt;?php function getPostValue($key, $default = NULL) { // $_POST is a superglobal and can be used without // having to specify &#39;global $_POST;&#39; if (isset($_POST[$key])) { return $_POST[$key]; } return $default; } // retrieves $_POST[&#39;username&#39;] echo getPostValue(&#39;username&#39;); // retrieves $_POST[&#39;email&#39;] and defaults to empty string echo getPostValue(&#39;email&#39;, &#39;&#39;);  静态属性和变量 定义为public的静态类属性和全局变量的功能类似。在任何类定义的地方都可以访问他们。
class SomeClass { public static int $counter = 0; } // The static $counter variable can be read/written from anywhere // and doesn&#39;t require an instantiation of the class SomeClass::$counter += 1;  可以在函数内部定义静态变量。这些静态变量可以在多次调用之间保持存在，这个定义在函数中的普通变量不同。这可以非常简单的实现单例模式。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-65.html</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-65.html</guid>
      <description>设计模式 在bash中完成一些常见的设计模式。
发布订阅模式 当项目变为一个库时，添加新功能会变得很困难。函数名、变量和参数通常需要在使用它们的脚本中进行更改。在这样的场景中，分离代码并使用事件驱动的设计模式是很有帮助的。在所述模式中，外部脚本可以订阅事件。当触发（发布）该事件时，脚本可以执行它在该事件中注册的代码。
pubsub.sh #!/usr/bin/env bash # # Save the path to this script&#39;s directory in a global env variable # DIR=&amp;quot;$( cd &amp;quot;$( dirname &amp;quot;${BASH_SOURCE[0]}&amp;quot; )&amp;quot; &amp;amp;&amp;amp; pwd )&amp;quot; # # Array that will contain all registered events # EVENTS=() function action1() { echo &amp;quot;Action #1 was performed ${2}&amp;quot; } function action2() { echo &amp;quot;Action #2 was performed&amp;quot; } # # @desc :: Registers an event # @param :: string $1 - The name of the event.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</guid>
      <description>变量 变量的变量 可以通过动态的变量名字访问变量。任务允许被动态访问的变量的名字都可以放到另一个变量内。这样的变量就叫做变量的变量。
想要把一个变量放到另一个变量里面，可以在变量的前面添加一个额外的$符。
$variableName = &#39;foo&#39;; $foo = &#39;bar&#39;; //下面这些都是等价的，都会输出bar echo $foo; echo ${$variableName}; echo $$variableName; //下面相似的 $variableName = &#39;foo&#39;; $$variableName = &#39;bar&#39;; //下面的语句也会输出bar echo $foo; echo ${$variableName}; echo $$variableName;  变量的变量对于映射函数/方法非常有用。
function add($a, $b) { return $a + $b; } $funcName = &#39;add&#39;; echo $funcName(1, 2); // outputs 3  这在PHP的类里面是特别有用的：
class myClass { public function __construct() { $functionName = &#39;doSomething&#39;; $this-&amp;gt;$functionName(&#39;Hello World&#39;); } private function doSomething($string) { echo $string; // Outputs &amp;quot;Hello World&amp;quot; } }  可以单并不要求把变量$variableName放到{}里面：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-64.html</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-64.html</guid>
      <description>解码URL 简单例子 编码URL
 http%3A%2F%2Fwww.foo.com%2Findex.php%3Fid%3Dqwerty
 使用命令解码URL
echo &amp;quot;http%3A%2F%2Fwww.foo.com%2Findex.php%3Fid%3Dqwerty&amp;quot; | sed -e &amp;quot;s/%\([0-9A-F][0-9A- F]\)/\\\\\x\1/g&amp;quot; | xargs -0 echo -e  输出：
 http://www.foo.com/index.php?id=qwerty
 使用printf解码字符串 #!bin/bash $ string=&#39;Question%20- %20%22how%20do%20I%20decode%20a%20percent%20encoded%20string%3F%22%0AAnswer%20%20%20- %20Use%20printf%20%3A)&#39; $ printf &#39;%b\n&#39; &amp;quot;${string//%/\\x}&amp;quot; # the result Question - &amp;quot;how do I decode a percent encoded string?&amp;quot; Answer - Use printf :)  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</guid>
      <description>开始使用PHP PHP 7.x
   版本 支持截止时间 发版时间     7.1 2019-12-01 2016-12-01   7.0 2018-12-03 2015-12-03    PHP 5.x
   版本 支持截止时间 发版时间     5.6 2018-12-31 2014-08-28   5.5 2016-07-21 2013-06-20   5.4 2015-09-03 2012-03-01   5.3 2014-08-14 2009-06-30   5.2 2011-01-06 2006-11-02   5.1 2006-08-24 2005-11-24   5.0 2005-09-05 2004-07-13    PHP 4.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-63.html</link>
      <pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-63.html</guid>
      <description>Parallel    选项 详情     -j n 同时运行n个任务   -k 保持相同的顺序   -X 上下文替换的多个参数   —colsep regexp 在regexp上拆分输入以进行位置替换   {} {.} {/} {/.} {#} 替换字符串   {3} {3.} {3/} {3/.} 位置替换字符串   -S sshlogin 例如 foo@server.example.com   —trc {} .bar —transfer —return {}.bar —cleanup的简短格式   &amp;ndash;onall 在所有sshlogins上运行带有参数的给定命令   &amp;ndash;nonall 在所有sshlogins上运行没有带参数的给定命令   &amp;ndash;pipe 将stdin（标准输入）拆分为多个任务   —recend str 记录&amp;ndash;pipe的结束分隔符。   —recstart str 记录—pipe的开始分隔符。    GUN Linux上面的任务可以使用GNU parallel并行执行。一个任务可以是一个命令或需要运行输入每行的小脚本。特别的输入就是一列文件，一列host，一列用户，一列URL，一列表等。一个任务也可以是从管道中读取的命令。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十二)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-62.html</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-62.html</guid>
      <description>bash网络操作 Bash通常用于服务器和集群的管理和维护工作。与网络操作使用的典型命令有关的信息，何时使用哪个命令用于哪个目的，以及应包括其独特和/或有趣应用程序的示例/示例。
网络命令 ifconfig  上面的命令会显示机器所有活动的接口，提供下面的信息：
 接口的IP地址 接口的MAC地址 广播地址 发送和接收字节  一些例子：
ifconfig -a  上面的例子也会显示无效的接口。
ifconfig eth0  上面的命令将会只显示eth0接口。
ifconfig etho0 192.168.1.100 netmask 255.255.255.0  上面的命令将会把静态ip地址赋值给eth0接口。
ifup ehth0  上面的命令会开启eth0
ifdown eth0  上面的命令会禁止eth0接口
ping  上面的命令(Packet Internet Grouper)用于测试两个节点之间的链接。
ping -c2 8.8.8.8  上面的命令将ping或测试与谷歌服务器的连接2秒
traceroute  以上命令用于故障排除，以找出到达目的地所花费的跳数。
netstat  上面的命令将会获取连接信息和他们的状态
dig www.baidu.com  上面的命令(域信息分组器)查询DNS相关信息
nslookup www.baidu.com  上面的命令查询DNS信息，并找出网站名称对应的IP地址。
route  上面的命令用来检测网络路由信息。只是显示你的路由表。
router add default gw 192.168.1.1 eth0  上面的命令会将eth0接口的默认网络路由添加到路由表192.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十一)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-61.html</link>
      <pubDate>Fri, 29 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-61.html</guid>
      <description>eval命令 首先最重要的是：知道你正在做什么。第二，虽然你应该避免使用eval，但是它的使用让代码更加干净，那就继续使用。
使用eval 例如，考虑将$@的内容设置为给定变量的内容：
a=(1 2 3) eval set -- &amp;quot;${a[@]}&amp;quot;  这个代码通常伴随着getopt或getopts将$@设置为上述选项分析器的输出。但是你也可以用这个创建一个简单的pop函数，这个函数可以简单的直接操作变量，而不用将变量存储在原始变量中：
isnum() { # is argument an integer? local re=&#39;^[0-9]+$&#39; if [[ -n $1 ]]; then [[ $1 =~ $re ]] &amp;amp;&amp;amp; return 0 return 1 else return 2 fi } isvar() { if isnum &amp;quot;$1&amp;quot;; then return 1 fi local arr=&amp;quot;$(eval eval -- echo -n &amp;quot;\$$1&amp;quot;)&amp;quot; if [[ -n ${arr[@]} ]]; then	return 0 fi return 1 } pop() { if [[ -z $@ ]]; then return 1 fi local var= local isvar=0 local arr=() if isvar &amp;quot;$1&amp;quot;; then # let&#39;s check to see if this is a variable or just a bare array var=&amp;quot;$1&amp;quot; isvar=1 arr=($(eval eval -- echo -n &amp;quot;\${$1[@]}&amp;quot;)) # if it is a var, get its contents else arr=($@) fi # we need to reverse the contents of $@ so that we can shift # the last element into nothingness arr=($(awk &amp;lt;&amp;lt;&amp;lt;&amp;quot;${arr[@]}&amp;quot; &#39;{ for (i=NF; i&amp;gt;1; --i) printf(&amp;quot;%s &amp;quot;,$i); print $1; }&#39; # set $@ to ${arr[@]} so that we can run shift against it.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-60.html</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-60.html</guid>
      <description>select关键字 select关键字可以用来在菜单格式中获取输入参数。
获取参数 假设你想要用户选择菜单的关键字，你可以创建下面类似的脚本：
#! /usr/bin/env bash select os in &amp;quot;linux&amp;quot; &amp;quot;windows&amp;quot; &amp;quot;mac&amp;quot; do echo &amp;quot;{$os}&amp;quot; break done  解析：这里select关键字循环元素列表，在命令行的提示中显示这些元素，以供用户选择。注意break关键字将会中断循环，一旦用户做了选择。否则循环将不会结束。
结果：一旦开始运行脚本，菜单的选项将会显示，用户将被提示进行一个选择，一旦选择了，这个值将会显示，并且返回命令提示。
&amp;gt;bash select_menu.sh 1) linux 2) windows 3) mac #? 3 mac &amp;gt;  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十九)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-59.html</link>
      <pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-59.html</guid>
      <description>CGI脚本 请求方法：GET 使用GET请求一个CGI脚本是非常方便的。
首先你需要脚本的encoded url。然后你在变量后面添加?。
 每个变量有=分割的两个部分。第一部分是对每个变量唯一的值，第二部分是变量的值
 变量使用&amp;amp;分隔
 字符串的总长度不要超过255个字符
 变量的名称和值需要是html编码的(替换&amp;lt;/ /?:@&amp;amp;=+$)
  注意：当使用html表格时，请求方法可以自己产生。使用Ajax你可以使用encodeURI和encodeURIComponent来编码信息
例子：
http://www.example.com/cgi-bin/script.sh?var1=Hello%20World!&amp;amp;var2=This%20is%20a%20Test.&amp;amp;  服务器只能通过跨源资源共享(CORS)来进行请求，这样请求更加安全。在这个例子中，我们使用CORS来确定使用的数据类型。
有多中数据类型我们可以选择，通常是：
 text/html text/plain application/json  当发生一个请求，服务器会创建很多环境变量。现在最重要的环境变量是$REQUEST_METHOD和$QUERY_STRING
这里REQUEST_METHOD必须是GET。这个QUERY_STRING`包含所有html编码的数据。
#!/bin/bash # CORS is the way to communicate, so lets response to the server first echo &amp;quot;Content-type: text/html&amp;quot; # set the data-type we want to use echo &amp;quot;&amp;quot; # we don&#39;t need more rules, the empty line initiate this. # CORS are set in stone and any communication from now on will be like reading a html-document.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十八)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-58.html</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-58.html</guid>
      <description>全局和本地变量 默认的，你在脚本中声明的自己的变量，在每个方法，脚本甚至shell外部都是全局的。
如果你想要变量是方法本地的，在方法内部使用local关键字，这些值将只能在方法中访问。
全局变量 var=&amp;quot;hello&amp;quot; function foo(){ echo $var } foo  将会输出&amp;rdquo;hello&amp;rdquo;。这在另一种方式也是可以的：
function foo() { var=&amp;quot;hello&amp;quot; } foo echo $var  将也会输出&amp;rdquo;hello&amp;rdquo;
本地变量 function foo(){ local var var = &amp;quot;hello&amp;quot; } foo echo var  将什么都不会输出，var是方法内部的变量，在方法外部是不可见的。
混合使用 var=&amp;quot;hello&amp;quot; function foo() { local var=&amp;quot;sup?&amp;quot; echo &amp;quot;inside function, var=$var&amp;quot; } foo echo &amp;quot;outside function, var=$var&amp;quot;  将会输出：
inside function, var=sup? outside function, var=hello  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十七)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-57.html</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-57.html</guid>
      <description>cut命令    选项 详情     -b LIST, —bytes=LIST 打印LIST参数中的字节列表   -c LIST, —characters=LIST 打印参数LIST中指定位置的字符   -f LIST, —fields=LIST 打印字段或者列   -d DELIMITER 用来分割字段或列    在Bash，cut命令用来把文件分割到小的部分。
显示文件第一列 假设你有像下面的文件
John Smith 31 Robert Jones 27 ...  这个文件有空格分割的3列。值选择第一列使用下面的命令：
cut -d &#39; &#39; -f1 filename  这里-d标识指定了分隔符，或者什么分割了结果。f标识指定获取的列或自动的数。这将会输出下面的结果：
John Robert ...  显示文件x-y的列表 有时候，需要显示一个文件的指定范围的列。假设你有
Apple California 2017 1.00 47 Mango Oregon 2015 2.30 33  选择前3列表：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十六)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-56.html</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-56.html</guid>
      <description>Windows 10的bash readme 最简单的在Windows上使用Bash的方式是按照Windows版本的Git。这带有Git Bash，这是一个真正的Bash。你可以使用下面的顺序打开
Start &amp;gt; All Programs &amp;gt; Git &amp;gt; Git Bash
命令像grep ls find sed vi等等都是可以使用的
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（六十一）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-61.html</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-61.html</guid>
      <description>diff-tree 比较通过两个树对象找到的blob的内容和模式。
获取指定提交的文件修改 git diff-tree --no-commit-id --name-only -r COMMIT_ID  使用 git diff-tree [--stdin] [-m] [-c] [--cc] [-s] [-v] [--pretty] [-t] [-r] [--root] [&amp;lt;common-diff- options&amp;gt;] &amp;lt;tree-ish&amp;gt; [&amp;lt;tree-ish&amp;gt;] [&amp;lt;path&amp;gt;...]     选项 含义     -r 递归的进行diff   &amp;ndash;root 包括初始提交作为/dev/null的diff    选项    选项 详情     -z 输出diff-raw，以NUL结尾   -p 输出补丁格式   -u -p的别名   —patch-with-raw 输出补丁和diff-raw格式   &amp;ndash;stat 显示diffstat而不是patch。   &amp;ndash;numstat 显示数字diffstat而不是patch。   —patch-with-stat 输出一个补丁并预先准备其diffstat。   —name-only 显示修改文件的名称   —name-status 显示修改文件的名称和状态   —full-index 在索引行显示完整的对象名称   —abbrev= 在对象名称的缩写版本的树和区分RAW头。   -R 交换输入文件对。   -B 检测完全重写。   -M 检查重命名   -C 检查复制   —find-copies-harder 尝试将未更改的文件作为副本检测的候选文件。   -l 将重命名尝试限制为最多个路径。   -O 根据重新排序差异。   -S 查找仅一侧包含字符串的文件对。   —pickaxe-all 使用-s并找到hit时显示所有文件diff。   -a —text 把所有的文件当做字符串    参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十五)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-55.html</link>
      <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-55.html</guid>
      <description>cut命令    转义符 含义     -f, —fields 基于字段的选择   -d, —delimiter 基于字段选择的分隔符   -c, —characters 基于字符选择，分隔符忽略或者错误   -s, —only-delimited 禁止使用不带分隔符的行（按其他方式打印）   —complemment 反向选择（提取除指定字段/字符之外的所有字段/字符   —output-delimiter 指定它必须与输入分隔符不同的时间    cut命令是快速提前文本文件行的部分的方法。这是最老的Unix命令之一。它最流行的实现是Linux上的GUN版本，MacOS的FreeBSD版本。但是Unix的每种风格都有自己的特色。查看下面的不同。输入的行或者从标准输入读取，或者从命令行的参数列出的文件的读取。
只有一个分隔符 你不能拥有大于一个的的分隔符。如果你指定了像-d &amp;quot;,;:&amp;quot;，一些实现中只会使用第一个字符作为分隔符(这里，是逗号)。其他的一些实现(像GNU cut)会出现错误信息。
$ cut -d &amp;quot;,;:&amp;quot; -f2 &amp;lt;&amp;lt;&amp;lt;&amp;quot;J.Smith,1 Main Road,cell:1234567890;land:4081234567&amp;quot; cut: the delimiter must be a single character Try `cut --help&#39; for more information.  重复分隔符任务是空字符 $ cut -d, -f1,3 &amp;lt;&amp;lt;&amp;lt;&amp;quot;a,,b,c,d,e&amp;quot; a,b	 是相当明显的，但是使用空格分隔符，对某些人来说可能不太明显。</description>
    </item>
    
    <item>
      <title>Git专业笔记（六十）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-60.html</link>
      <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-60.html</guid>
      <description>整理本地和远程存储库 删除远端已删除的分支 要在本地和已删除的远程分支之间进行远程跟踪，请使用
git fetch -p  然后你可以使用
git branch -vv  来查看哪些分支没有被追踪。
那些还没有被追踪的分支将会向下面这样，包含&amp;rsquo;gone&amp;rsquo;：
branch 12345e6 [origin/branch: gone] Fixed bug  你可以组合使用上面的命令，查找git branch -vv中返回的gone的分支，并使用-d删除这些分支：
git fetch -p &amp;amp;&amp;amp; git branch -vv | awk &#39;/: gone]/{print $1}&#39; | xargs git branch -d  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十四)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-54.html</link>
      <pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-54.html</guid>
      <description>处理系统提示    转义符 含义     \a 响铃字符   \d 日期，&amp;rdquo;Weekday Month Date&amp;rdquo;这种格式的(像&amp;rdquo;Tue May 26&amp;rdquo;)   \D{FORMAT} 这个FORMAT是传给strftime(3)，并且结果插入提示字符串。一个空的FORMAT导致特定于区域设置的时间表示。花括号是必须的   \e 转义符。\ 033当然也可以。   \h 主机名，知道第一个.(就是没有域的部分)   \H 带有域部分的主机名称   \j 这个shell当前关联的任务数量   \l shell的终端设备名称的根目录   \n 新行   \r 回车符   \s shell的名称，基名是&amp;rdquo;$0&amp;rdquo;(最后一个斜杠后面的部分)   \t 24小时格式的时间，HH:MM:SS   \T 12小时格式的时间，HH:MM:SS   @ 12小时格式的时间， am/pm   \A 24小时的时间，HH:MM   \u 当前用户的用户名   \v Bash的版本(2.</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十九）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-59.html</link>
      <pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-59.html</guid>
      <description>git标签 像大多数的版本控制工具，git可以把历史中某个提交定义为重要的。特别是用户使用这个功能来标记发版点(v1.0等)。
列出所有的tag 使用git tag可以列出所有有效的tag：
$ git tag &amp;lt;output follows&amp;gt; v0.1 v1.3   注意：这里tag是按照字符顺序输出的。
 也可以搜索指定的tag：
$ git tag -l &amp;quot;v1.8.5*&amp;quot; &amp;lt;output follows&amp;gt; v1.8.5 v1.8.5-rc0 v1.8.5-rc1 v1.8.5-rc2 v1.8.5-rc3 v1.8.5.1 v1.8.5.2 v1.8.5.3 v1.8.5.4 v1.8.5.5  创建并push标签 创建标签  在当前分支创建tag   git tag &amp;lt;tagname&amp;gt;  这将在当前分支的当前状态创建一个tag
 在某些提交上创建tag   git tag tag-name commit-identifier  这将在commit-identifier的提交上创建tag。
push tag  push单独的标签   git push origin tag-name   一次push所有的tag   git push origin --tags  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-53.html</link>
      <pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-53.html</guid>
      <description>特定时间的任务 在特定时间执行一次任务 注意：at默认没有在大多数的发行版中安装。
想要只当前时间之外的某个时间执行一些任务，在例子中是下午5点，你可以向下面这样：
echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 5pm  如果你想要获取命令的输出，你可以像往常一样：
echo &amp;quot;somecommand &amp;gt; out.txt 2&amp;gt;err.txt &amp;amp;&amp;quot; | at 5pm  at理解非常多的时间格式，所以你也可以像下面这样：
echo &amp;quot;somecommand &amp;amp;&amp;quot; | at now + 2 minutes echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 17:00 echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 17:00 Jul 7 echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 4pm 12.03.17  如果没有指定年月日的话，这将会在下次遇到这个时间的时候执行。所以如果你提供了一个之前的时间，将会在明天执行。如果你提供了之前的月份，那将会在下一年才会执行。
这也会和nohup联合使用，想你期望的一样：
echo &amp;quot;nohup somecommand &amp;gt; out.txt 2&amp;gt;err.txt &amp;amp;&amp;quot; | at 5pm  有更多的控制命令执行时间的命令:
 atq列出所有的时间任务 atrm移除一个时间任务 batch像at命令一样，但是只在系统的负载在0.</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十八）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-58.html</link>
      <pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-58.html</guid>
      <description>修改git仓库名称 如果你在远端修改了仓库的名称，就像在github或bitbucket。当你推送已经存在的代码时，将会出现错误：Fatal error, repository not found**.
修改本地仓库 在终端中：
cd projectFolder git remote -v (it will show previous git url) git remote set-url origin https://username@bitbucket.org/username/newName.git git remote -v (double check, it will show new git url) git push (do whatever you want.)  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十二)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-52.html</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-52.html</guid>
      <description>变量类型 声明弱类型变量 declare是bash的内部变量。经常用来显示和定义变量或显示函数体。
语法：`declare [options] [name[=value]]&amp;hellip;
# options are used to define # an integer declare -i myInteger declare -i anotherInt=10 # an array with values declare -a anArray=( one two three) # an assoc Array declare -A assocArray=( [element1]=&amp;quot;something&amp;quot; [second]=anotherthing ) # note that bash recognizes the string context within [] # some modifiers exist # uppercase content declare -u big=&#39;this will be uppercase&#39; # same for lower case declare -l small=&#39;THIS WILL BE LOWERCASE&#39; # readonly array declare -ra constarray=( eternal true and unchangeable ) # export integer to environment declare -xi importantInt=42  也可以使用+来移除给定的属性。基本没有用处，只是为了完整性。</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十七）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-57.html</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-57.html</guid>
      <description>git重排 rerere(重复使用记录解决方案)允许你告诉git记住你是如何解决一个大块冲突的。这允许当下次遇到同样的冲突是可以自动的解决这个冲动。
启用rerere 可以使用下面的命令启用rerere:
$ git config --global rerere.enabled true  这个可以在指定仓库中运行，也可以在全局配置中。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十一)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-51.html</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-51.html</guid>
      <description>协同进程 Hello World # create the co-process coproc bash # send a command to it (echo a) echo &#39;echo Hello World&#39; &amp;gt;&amp;amp;&amp;quot;${COPROC[1]}&amp;quot; # read a line from its output read line &amp;lt;&amp;amp;&amp;quot;${COPROC[0]}&amp;quot; # show the line echo &amp;quot;$line&amp;quot;  输出&amp;rdquo;Hello World&amp;rdquo;
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十六）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-56.html</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-56.html</guid>
      <description>git客户端的hooks 和很多其他的版本控制系统一样，Git有一种当某些重要行为发生的时候执行自定义脚本的功能。有两种这样的hooks：客户端的和服务器端的。客户端的hook通常当提交和合并的时候触发执行，而服务器端的hook通常当遇到网络操作(如接收到push的提交)触发。你可以出于各种原因使用这些钩子。
pre-push hook pre-push脚本会在git push调用并且检查远端状态之后执行，但是在任何东西push之前。如果脚本存在，并且返回了一个非零的值，那么什么都不会push。
这个hook使用下面的参数被调用：
$1 -- Name of the remote to which the push is being done (Ex: origin) $2 -- URL to which the push is being done (Ex: https://://.git)  有关正在推送的提交的信息以行的形式提供给表单中的标准输入：
 &amp;lt;local_ref&amp;gt; &amp;lt;local_sha1&amp;gt; &amp;lt;remote_ref&amp;gt; &amp;lt;remote_sha1&amp;gt;  例子：
local_ref = refs/heads/master local_sha1 = 68a07ee4f6af8271dc40caae6cc23f283122ed11 remote_ref = refs/heads/master remote_sha1 = efd4d512f34b11e3cf5c12433bbedd4b1532716f  下面的示例是从默认的pre-push.sample中获取的pre-push脚本，该脚本是在使用git init初始化新存储库时自动创建的。
# This sample shows how to prevent push of commits where the log message starts # with &amp;quot;WIP&amp;quot; (work in progress).</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-50.html</link>
      <pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-50.html</guid>
      <description>脚本输出修改格式 color-output.sh 在bash脚本的开头部分，可以定义一些变量，这些变量在脚本运行期间充电帮助器来对终端的输出进行着色或格式化。
不同的平台使用不同的字符序列来表示颜色。然而有一个叫做tput的工具：在任何类Unix的系统上面，返回指定系统的终端颜色字符串通过一个跨平台的API。
例如，获取终端文本红色或绿色的字符串序列到变量中：
 red=$(tput setaf 1) green=$(tput setaf 2)  或者，要存储将文本重置为默认外观的字符序列：
reset=$(tput sgr0)  然后，当BASH脚本想要显示不同的颜色和输出是，可以像下面这样：
echo &amp;quot;${green}Success!${reset}&amp;quot; echo &amp;quot;${red}Failure.${reset}&amp;quot;  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十五）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-55.html</link>
      <pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-55.html</guid>
      <description>Bash显示分支名 这个文档解决git的分支名称在Bash终端显示的问题。开发者经常需要查看当前的分支名称。我们可以显示当前目录中的git分支名称。
终端的分支名 什么是PS1 PS1表示提示字符串1(Prompt String 1)。这是Linux/UNIX中shell的一个提示字符串。当你打开终端的时候，将会在你的bash提示中显示PS1中的内容。为了在bash提示中增加分支名称，我们需要修改PS1变量(在~/.bash_profile中设置PS1的值)。
显示分支名 在~/.bash_profile中添加下面的内容：
git_branch() { git branch 2&amp;gt; /dev/null | sed -e &#39;/^[^*]/d&#39; -e &#39;s/* \(.*\)/ (\1)/&#39; } export PS1=&amp;quot;\u@\h \[\033[32m\]\w\[\033[33m\]\$(git_branch)\[\033[00m\] $ &amp;quot;  这个git_branch方法或拿到我们当前的分支名称。一但我们做了这个修改，我们切换到一个git仓库，我们就可以看到仓库当前的分支名称。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十九)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-49.html</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-49.html</guid>
      <description>shell类型 开启一个交互shell bash  检查shell类型 shopt -q login_shell &amp;amp;&amp;amp; echo &#39;login&#39; || echo &#39;not-login&#39;  点文件 在Unix中，以.开头的文件或目录包含了指定程序或一系列程序的配置选项。点文件通常对用户是隐藏的，所以你需要使用ls -a来查看这些文件。
一个点文件的例子是.bash_history，假设用户使用Bash，包含了最近执行的命令。
当你在Bash中时，有各种文件是被source的。下面的图片来自这个站点，显示了在启动时选择要源文件的决策过程。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十四）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-54.html</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-54.html</guid>
      <description>修改引用中对象名称 修改引用中对象名称 使用 修改引用中的对象名称
语法 git update-ref [-m &amp;lt;reason&amp;gt;] (-d &amp;lt;ref&amp;gt; [&amp;lt;oldvalue&amp;gt;] | [--no-deref] [--create-reflog] &amp;lt;ref&amp;gt; &amp;lt;newvalue&amp;gt; [&amp;lt;oldvalue&amp;gt;] | --stdin [-z])  普通语法  取消符合引用，修改分支头到新的对象   git update-ref HEAD &amp;lt;newvalue&amp;gt;   验证引用中当前只和oldvalue匹配后，修改newvalue到引用中   git update-ref refs/head/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;  上面的语法只有咱当前的值是oldvalue的时候，修改master分支的头到newvalue。
在验证引用还包含&amp;lt;oldvalue&amp;gt;之后，使用-d标识删除到命名的引用&amp;lt;ref&amp;gt;。
使用—create-reflog之后，更新引用将会为每个引用创建一个reflog，即使通常不会创建reflog。
使用-z标志以nul终止格式指定，该格式具有更新、创建、删除、验证等值。
update 如果提供了，在验证&amp;lt;oldvalue&amp;gt;之后，修改引用&amp;lt;ref&amp;gt;的值为&amp;lt;newvalue&amp;gt;。指定零值&amp;lt;newvalue&amp;gt;确保引用更新之后不存在，或者一个零值&amp;lt;oldvalue&amp;gt;确保引用更新之前不存在。
create 验证不存在之后使用&amp;lt;newvalue&amp;gt;创建&amp;lt;ref&amp;gt;。这个&amp;lt;newvalue&amp;gt;不能为0
delete 如果提供，验证&amp;lt;oldvalue&amp;gt;存在之后，删除&amp;lt;ref&amp;gt;。这时，&amp;lt;oldvalue&amp;gt;不能是0
verify 使用&amp;lt;oldvalue&amp;gt;验证&amp;lt;ref&amp;gt;中存在，但是不做修改。如果&amp;lt;oldvalue&amp;gt;为0或缺失，引用必须不存在。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十八)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-48.html</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-48.html</guid>
      <description>命令和操作链 有多种方法比命令连接在一起使用。简单的就像;，复杂的像逻辑链(根据条件使用不同的命令)。第三种就是管道命令：在链条中，下一个命令处理上一个命令的输出结果。
统计字符串出现次数 使用管道把上一个命令的输出结果作为下个命令的输入值：
ls -l | grep -c &amp;quot;.conf&amp;quot;  这个例子中，ls命令的输出结果作为grep命令的输入。结果是文件名中包含.conf的文件的数量。
这个可以用组织尽量长的命令队列：
ls -1 | grep &amp;quot;.conf&amp;quot; | grep -c .  传输root命令输出到用户文件 有时候想要把root命令的执行结果给其他的用户。tee命令很简单的以用户的权限把root命令的输出结果放入一个文件中。
su -c ifconfig | tee ~/results-of-ifconfig.txt  只有ifconfig是以root的身份运行的。
逻辑命令链 &amp;amp;&amp;amp; || &amp;amp;&amp;amp;连接两个命令，第二个命令只有在第一个命令执行成功的情况下才会执行。||的两个命令只有第一个命令失败的情况下第二个命令才会执行。
[ a = b ] &amp;amp;&amp;amp; echo &amp;quot;yes&amp;quot; || echo &amp;quot;no&amp;quot; # if you want to run more commands within a logical chain, use curly braces # which designate a block of commands # They do need a ; before closing bracket so bash can diffentiate from other uses # of curly braces [ a = b ] &amp;amp;&amp;amp; { echo &amp;quot;let me see.</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十三）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-53.html</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-53.html</guid>
      <description>外部合并和diff工具 设置KDiff3作为合并工具 下面的配置添加到.gitconfig文件中：
[merge] tool = kdiff3 [mergetool &amp;quot;kdiff3&amp;quot;] path = D:/Program Files (x86)/KDiff3/kdiff3.exe keepBackup = false keepbackup = false trustExitCode = false  注意设置path属性为你安装KDiff3的目录。
设置KDiff3为diff工具 [diff] tool = kdiff3 guitool = kdiff3 [difftool &amp;quot;kdiff3&amp;quot;] path = D:/Program Files (x86)/KDiff3/kdiff3.exe cmd = \&amp;quot;D:/Program Files (x86)/KDiff3/kdiff3.exe\&amp;quot; \&amp;quot;$LOCAL\&amp;quot; \&amp;quot;$REMOTE\&amp;quot;  设置IntelliJ IDE为合并工具(Windows) [merge] tool = intellij [mergetool &amp;quot;intellij&amp;quot;] cmd = cmd \&amp;quot;/C D:\\workspace\\tools\\symlink\\idea\\bin\\idea.bat merge $(cd $(dirname &amp;quot;$LOCAL&amp;quot;) &amp;amp;&amp;amp; pwd)/$(basename &amp;quot;$LOCAL&amp;quot;) $(cd $(dirname &amp;quot;$REMOTE&amp;quot;) &amp;amp;&amp;amp; pwd)/$(basename &amp;quot;$REMOTE&amp;quot;) $(cd $(dirname &amp;quot;$BASE&amp;quot;) &amp;amp;&amp;amp; pwd)/$(basename &amp;quot;$BASE&amp;quot;) $(cd $(dirname &amp;quot;$MERGED&amp;quot;) &amp;amp;&amp;amp; pwd)/$(basename &amp;quot;$MERGED&amp;quot;)\&amp;quot; keepBackup = false keepbackup = false trustExitCode = true  这里需要注意的一点是，这个cmd属性不接受路径中任何奇怪的字符。如果您的IDE安装位置中有奇怪的字符（例如，它安装在Program Files (x86)中），则必须创建一个软连。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十七)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-47.html</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-47.html</guid>
      <description>使用trap响应信号和系统事件    参数 详情     -p 列出当前按照的traps   -l 列出信号的名称和相应编号    清理临时文件 你可以使用trap命令来&amp;rdquo;trap&amp;rdquo;信号：这是shell中等同于C中调用signal()或sigaction()，或者其他的编程语言中捕捉信号的方法。
trap的一个常用的地方是清理希望或不希望存在的临时文件。
不幸的是没有足够的脚本实现这个功能：
#!/bin/sh #定义清理函数 cleanup() { rm --force -- &amp;quot;${tmp}&amp;quot; } # 捕捉特殊的EXIT组， shell存在时会一直运行 trap cleanup EXIT #创建临时文件 tmp=&amp;quot;$(mktemp -p /tmp tmpfileXXXXX)&amp;quot; echo &amp;quot;Hello World!&amp;quot; &amp;gt;&amp;gt; &amp;quot;${tmp}&amp;quot; # No rm -f &amp;quot;$tmp&amp;quot; needed. The advantage of using EXIT is that it still works # even if there was an error or if you used exit.</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十二）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-52.html</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-52.html</guid>
      <description>TortoiseGit 合并提交 简单方法 这将不会有效，当你选择的分支包含合并的分支时：
高级方法 开启rebase：
假设不变 如果一个文件修改了，但是你不想提交这个文件，把这个文件设置为&amp;rdquo;假设不变&amp;rdquo;：
恢复假设不变 忽略文件和目录 使用TortioseGit UI 可以在文件或目录上面使用鼠标右键，想要忽略文件TortoiseGit -&amp;gt; Delete and add to ignore list，这里你可以选择忽略所有的某个类型的文件或者指定的文件，然后在弹窗中选择ok就可以了。
分支 使用UI来选择分支，在仓库上面鼠标右键，然后Tortoise Git -&amp;gt; Create Branch…
新的窗口会打开open -&amp;gt; Give branch a name -&amp;gt; Tick the box Switch to new branch(可能你希望在分支之后使用它)。点击&amp;rdquo;确定&amp;rdquo;，就可以完成操作。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十六)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-46.html</link>
      <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-46.html</guid>
      <description>printf输出日期 在Bash4.2，提供了printf内建的时间规则：%(datefmt)T可以让printf输出datefmt指定格式的时间字符串。其中datefmt需要是strftime识别的格式。
获取当前时间 $ printf &#39;%(%F)T\n&#39; 2019-03-14  设置当前时间变量 $ printf -v now &#39;%(%T)T&#39; $ echo &amp;quot;$now&amp;quot; 21:00:04  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十一）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-51.html</link>
      <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-51.html</guid>
      <description>git reflog 从坏rebase修复 假设你开启了一个交互rebase：
git rebase --interactive HEAD~20  但是你犯了错误，你合并或丢掉了一些你不想要失去的提交。然后完成了rebase操作。想要修复的话，使用git reflog，你可以看到类似下面的内容：
aaaaaaa HEAD@{0} rebase -i (finish): returning to refs/head/master bbbbbbb HEAD@{1} rebase -i (squash): Fix parse error ... ccccccc HEAD@{n} rebase -i (start): checkout HEAD~20 ddddddd HEAD@{n+1} ... ...  在这个例子里面，上个提交dddddd或(HEAD@{n+1})是你开始rebase的分支。因此想要恢复这个提交(和所有的父提交，包括那些合并或丢失的)：
$ git checkout HEAD@{n+1}  然后你可以使用下面的命令git checkout -b [branch]来创建一个新分支。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十五)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-45.html</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-45.html</guid>
      <description>单词拆分    参数 详情     IFS 内部的字段分隔符   -x 打印执行的命令和他们的参数    what，when和why 当shell执行参数扩展，命令替换，变量或算术扩展时，它会扫描结果中的字边界。如果找到了字符边界，就会在这个位置把结果分成多个单词。这个单词的边界是被IFS定义的。如果没有显示指明的话，IFS的默认值是空白，tab和新行。当遇到这三个字符的时候，会进行单词的拆分。
set -x var=&#39;I am a multiline string&#39; fun() { echo &amp;quot;-$1-&amp;quot; echo &amp;quot;*$2*&amp;quot; echo &amp;quot;.$3.&amp;quot; } fun $var  在上面的例子中线上了fun是怎么执行的
fun I am a multiline string   $var被分成5个单词，但是只有I，am，a被输出。
 单词拆分的坏处 $ a=&#39;I am a string with spaces&#39; $ [ $a = $a ] || echo &amp;quot;didn&#39;t match&amp;quot; bash: [: too many arguments didn&#39;t match   [ $a = $a ]被解析为[ I am a string with spaces = I am a string with spaces ]。[是一个test命令，然而I am a string with spaces是6个参数不是一个参数。</description>
    </item>
    
    <item>
      <title>Git专业笔记（五十）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-50.html</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-50.html</guid>
      <description>git可视客户端 gitk和git-gui 当你按照git的时候，也可以按照可视化的工具：gitk和git-gui。
gitk是一个图形历史查看工具。把它想象成git log和git grep的强大GUI工具。这在你想要查看仓库历史发送的修改，或者查看仓库的历史很有用。
Gitk很容易从命令行启动。只要cd到仓库的目录，然后输入：
$ gitk [git log options]  Gitk接收很多的命令行选项，启动大部分是传给底层git log操作的。可能其中最有用的：—all标识，通知gitk显示所有引用的提交，不仅仅是HEAD。Gitk的界面可能想下面这样：
上面图像中上部分就像是使用git log —graph的输出。每个点代表一个提交，每条线代表父关系，引用显示在带颜色的块内。黄点标识HEAD，红点表示还没有提交的修改。下部分就是显示指定提交的展示，注释和补丁在左边，右边是摘要视图。中间是一系列用来搜索历史的。
你可以在分支名或提交信息上右键，可以使用很多git的方法。例如签出不同的分支或cherry pick一个提交，只要一个点击。
git-gui主要是用于构建提交的工具，它也很容易从命令行启动：
$ git gui  它的界面就像下面这样：
左边是索引，上边是未暂存的修改，暂存的修改在下吧。你可以点击文件的标识来交互文件的状态，或者选择一个文件点击查看它的名称。
右上角是文件的diff，用来显示选择文件的修改。你可以在这个区域使用右键来暂存单独的块或者行。
右下角是提交信息和操作的地方。在文本框中输入提交信息，然后点击Commit按键做和git commit一样的事情。你也可以使用Amend来提交，将会把暂存的修改提交到上次提交。然后，你可以暂存或取消暂存修改，添加提交信息，然后提交Commit来重新提交。
gitk和git-gui是面向任务的例子。它们中的每一个都是为特定目的而定制的（分别查看历史和创建提交），并且省略了该任务不需要的特性。
查看介绍。
Github桌面 站点：https://git-scm.com/book/en/v2/Git-in-Other-Environments-Graphical-Interfaces
价格：免费
平台：OS X和Windows
开发者：https://github.com/
Git Kraken 站点：https://www.gitkraken.com/
价格：$60/每年(免费为开源、教育、非营利、初创企业或个人使用)
平台：Linux, OS X, Windows
开发者：Axosoft
SourceTree 站点：https://www.sourcetreeapp.com/
价格：免费(需要账户)
平台：OS X 和 Windows
开发者：Atlassian
Git扩展 站点：https://gitextensions.github.io
价格：免费
平台：Windows
SmartGit 站点：https://www.syntevo.com/smartgit/
价格：免费仅限非商业用途。永久许可费99美元
平台：Linux，OS X 和Windows
开发者：syntevo
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十四)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-44.html</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-44.html</guid>
      <description>管理PATH环境变量 添加一个path到PATH环境变量 PATH环境变量通常定义在.bashrc或者.bash_profile或者/etc/profile或者.profile或者/etc/bash.bashrc(不同的bash配置文件)。
$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin: /usr/lib/jvm/jdk1.8.0_92/bin:/usr/lib/jvm/jdk1.8.0_92/db/bin:/usr/lib/jvm/jdk1.8.0_92/jre/bin  现在，如果我们想在PATH中添加一个路径(例如~/bin):
PATH=~/bin:$PATH # or PATH=$PATH:~/bin  但是这只会在当前的shell(或它的子shell中生效)。一旦你退出了这个shell，这个修改就会失效。
想要让修改永久话的话，我们需要在~/.bashrc中添加这些代码，并重新加载这个文件。
如果你在终端中运行下面的命令，将会把~/bin添加到PATH中：
echo &#39;PATH=~/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.bashrc &amp;amp;&amp;amp; source ~/.bashrc  命令解释：
 echo &#39;PATH=~/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.bashrc在文件~/.bashrc的末尾添加PATH=~/bin:$PATH这行代码，你也可以在编辑器中添加 source ~/.bashrc重新加载~/.bashrc文件  下面这个代码将会检查路径是否存在，只有在不存在的时候才会添加：
path=~/bin # path to be included bashrc=~/.bashrc # bash file to be written and reloaded # run the following code unmodified echo $PATH | grep -q &amp;quot;\(^\|:\)$path\(:\|/\{0,1\}$\)&amp;quot; || echo &amp;quot;PATH=\$PATH:$path&amp;quot; &amp;gt;&amp;gt; &amp;quot;$bashrc&amp;quot;; source &amp;quot;$bashrc&amp;quot;  从PATH环境变量移除路径 要从PATH中移除一个路径，需要编辑~/.</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十九）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-49.html</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-49.html</guid>
      <description>git发送邮件 使用Gmail 背景：如果你工作在像Linux内核这样的项目上面，你不是使用pull reques，而是要提交你到提交到服务器上等待review。这里介绍怎么使用git发送Gmail邮件。
在.gitconfig中添加下面的配置：
[sendemail] smtpserver = smtp.googlemail.com smtpencryption = tls smtpserverport = 587 smtpuser = name@gmail.com  然后在网页上面：Go to Google -&amp;gt; My Account -&amp;gt; Connected Apps &amp;amp; Sites -&amp;gt; Allow less secure apps -&amp;gt; Switch ON
创建一个补丁集合：
git format-patch HEAD~~~~ --subject-prefix=&amp;quot;PATCH &amp;lt;project-name&amp;gt;&amp;quot;  发送补丁到listserv:
git send-email --annotate --to project-developers-list@listserve.example.com 00*.patch  创建并发送补丁已经更新的版本：
git format-patch -v 2 HEAD~~~~ ...... git send-email --to project-developers-list@listserve.example.com v2-00*.patch  组合 --from * Email From: --[no-]to * Email To: --[no-]cc * Email Cc: --[no-]bcc * Email Bcc: --subject * Email &amp;quot;Subject:&amp;quot; --in-reply-to * Email &amp;quot;In-Reply-To:&amp;quot; --[no-]xmailer * Add &amp;quot;X-Mailer:&amp;quot; header (default).</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-43.html</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-43.html</guid>
      <description>管道 使用|&amp;amp; |&amp;amp;连接一命令的标准输出和标准错误到二命令，而|命令连接一命令的标准输出到二命令。
在这个例子中，使用curl命令加下载这个页面，使用-v选项写一些内容到标准错误中，这个页面被输出到标准输出中。这个页面的标题在&amp;lt;title&amp;gt;和&amp;lt;/tilte&amp;gt;之间。
curl -vs &#39;http://www.google.com/&#39; |&amp;amp; awk &#39;/Host:/{print} /&amp;lt;title&amp;gt;/{match($0,/&amp;lt;title&amp;gt;(.*)&amp;lt;\/title&amp;gt;/,a);print a[1]}&#39;  这将会输出：
&amp;gt; Host: www.google.com Google  但是使用|的话，会输出更多的内容：即哪些被输出到标准错误中的信息，因为只有标准输出被管道到下一个命令。在这个例子中除了最后一行，其他的都是输出到标准错误中的：
* Hostname was NOT found in DNS cache * Trying 172.217.20.228... * Connected to www.google.com (172.217.20.228) port 80 (#0) &amp;gt; GET / HTTP/1.1 &amp;gt; User-Agent: curl/7.35.0 &amp;gt; Host: www.google.com &amp;gt; Accept: */* &amp;gt; * HTTP 1.0, assume close after body &amp;lt; HTTP/1.0 200 OK &amp;lt; Date: Sun, 24 Jul 2016 19:04:59 GMT &amp;lt; Expires: -1 &amp;lt; Cache-Control: private, max-age=0 &amp;lt; Content-Type: text/html; charset=ISO-8859-1 &amp;lt; P3P: CP=&amp;quot;This is not a P3P policy!</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十八）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-48.html</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-48.html</guid>
      <description>git统计    参数 详情     -n, —numbered 按照作者的提交数量排序而不是按照字母顺序排序   -s, --summary 仅提供提交计数摘要   -e, --email 线上每个作者的邮件地址   --format[=&amp;lt;format&amp;gt;] 不使用提交对象，使用其他的信息来描述提交。&amp;lt;format&amp;gt;是git log的—format选项使用的字符   -w[&amp;lt;width&amp;gt;[,&amp;lt;indent1&amp;gt;[,&amp;lt;indent2&amp;gt;]]] 通过以宽度包装每一行来对输出进行换行。每个条目的第一行缩进1个空格，后续行缩进1个空格。   &amp;lt;revision range&amp;gt; 显示指定版本范围内的提交。默认是直到当前的提交的所有历史   [—] &amp;lt;path&amp;gt; 只显示说明文件匹配路径的提交。路径可能需要以“-”作为前缀，以将其与选项或修订范围分开。    每个开发者的行 git ls-tree -r HEAD | sed -Ee &#39;s/^.{53}//&#39; | \ while read filename; do file &amp;quot;$filename&amp;quot;; done | \ grep -E &#39;: .*text&#39; | sed -E -e &#39;s/: .</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十二)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-42.html</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-42.html</guid>
      <description>scp传输文件 scp传输文件 想要安全的传输一个文件到另一台机器上面：
scp file1.txt tom@server2:$HOME  这个例子将会把file1.txt从我们的机器上面传输到server2的用户tom的家目录内。
scp传输多个文件 scp也可以用来从一个服务器到一个服务器传输多个文件。下面的例子是从my_folder目录传输所有后缀为.txt的文件到server2。下面的例子所有的文件传输到用户的home目录：
scp /my_folder/*.txt tom@server2:$HOME  使用scp下载文件 从远端机器下载文件到本地机器：
scp tom@server2:$HOME/file.txt /local/machine/path/  这里例子展示了如果从tom的家目录下载文件file.txt到本地机器的当前目录。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十七）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-47.html</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-47.html</guid>
      <description>git补丁    参数 详情     `( )`&amp;hellip;   -s, —signoff 使用自己的提交者标识，在提交消息中添加一个签名人   -q, —quiet 安静模式。值打印错误信息   -u, -utf8 git mailinfo使用-u标识。这表明从邮箱获取的提交日志信息使用UTF-8重新编码(如果不是UTF-8的话，i18n.commitencoding可以用来指定项目的编码)。你可以使用—no-utf8来覆盖这个选项   —no-utf8 git mailinfo使用-n标识。   -3, —3way 如果补丁不干净地应用，那么如果补丁记录了它应该应用到的blob的标识，并且我们在本地有这些blob可用，那么返回到3路合并。   —ingore-date, —ignore-space-change, —ignore-whitespace, —whitespace=&amp;lt;option&amp;gt;, -C&amp;lt;n&amp;gt;, -p&amp;lt;n&amp;gt;, —directory=&amp;lt;dir&amp;gt;, —exclude=&amp;lt;path&amp;gt;, —include=&amp;lt;path&amp;gt;, —reject 这些标识传递给git apply来应用补丁   —patch-format 默认命令会试着自动进行补丁格式的解析。这个选项允许用户跳过自动解析，指定补丁的格式。有效的格式包括mbox, stgit stgit-series hg   -i, —interactive 运行交互模式   —committer-date-is-author-date 默认命令使用邮件信息的提交作者日期，使用提交创建时间作为提交者的时间。这允许用户使用和作者日期一样的值来假装提交者日期。   —ignore-date 默认命令使用邮件信息的提交作者日期，使用提交创建时间作为提交者的时间。这允许用户使用和提交者日期一样的值来假装作者日期。   —skip 跳过当前补丁。这只在重启一个终端的补丁时有意义。   -S[&amp;lt;keyid&amp;gt;], —gpg-sign[=&amp;lt;keyid&amp;gt;] GPG签名提交   —continue, -r, —resolved 修补程序失败后（例如尝试应用冲突的修补程序），用户已手动应用该修补程序，索引文件存储应用程序的结果。使用从电子邮件和当前索引文件中提取的作者身份和提交日志进行提交，然后继续。   —resolvemsg=&amp;lt;msg&amp;gt; 当补丁失败的时候，在退出之前，&amp;lt;msg&amp;gt;将会被输出到屏幕。这将会覆盖你使用—continue或—skip的时候的标准信息。这只限于git rebase和git am之间使用   —abort 终端补丁操作，返回原本的分支。    创建补丁 创建一个补丁，有两个步骤：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十一)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-41.html</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-41.html</guid>
      <description>拆分文件 有时候把一个文件分成多个文件时很有用的。如果你有一个大文件，把它分成多个小块是很有用的。
拆分一个文件 直接不带参数的运行spilt命令，将会把一个文件分为1个或多个文件，每个文件最多包含1000行。
split file  这将会创建文件xaa xab xac …，每个文件最多1000行。这里你注意到，所有的文件都是x开头的。如果文件没有1000行，只有创建一个这样的文件。
想要修改文件名前缀的话，在命令的后面添加你想要的文件前缀：
split file customprefix  现在将会创建customprefixaa, customprefixab, customprefixac...这些文件。
指定每个文件的行数，可以使用-l选项。下面的命令将会拆分文件，每个文件最多5000行。
split -l5000 file  或者
split --lines=5000 file  另外你可以指定文件的最大大小而不是行数。这可以通过使用-b或—bytes选项来实现。例如，每个文件最大1M：
split --bytes=1MB file  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十六）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-46.html</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-46.html</guid>
      <description>git大文件存储 声明额外存储的文件类型 一个通常使用Git LFS的方式是声明一个使用系统规则处理指定文件，就像.gitingnore这个文件一样。
很多时候，通配符用于选择某些文件类型以覆盖跟踪。
git lfs track &amp;quot;*.psd&amp;quot;  当一个匹配上面规则的文件被添加到提交中，当被推送到远端的时候，它将会被单独上次，使用一个指针替换远端仓库中的文件。
使用LFS追踪文件之后，你的.gitattributes文件也会被更新。Github建议你提交自己仓库本地的.gitattributes文件，而不是修改全局的.gitattributes文件，这样就不会再处理多个仓库时出现问题。
为所有的副本设置LFS配置 想要设置在所有仓库副本都有效的LFS配置选项，要在仓库的根目录添加并提交一个.lfsconfig的文件。这个文件用来指定和.git/config中一样的配置文件。
例如：要从LFS中排查某个文件，请创建并提交.lfsconfig文件，并添加下面的内容提交：
[lfs] fetchexclude = ReallyBigFile.wav  按照LFS 下载和安装LFS，既可以使用Homebrew，也可以从这个网址。
homebrew  brew install git-lfs git lfs install  通常你需要对托管的远端服务器进行一些设置，用来允许它和LFS一起使用。这对于每个主机是不同的，但很可能只是勾选了一个框，说明你想要使用git lfs。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-40.html</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-40.html</guid>
      <description>文件执行顺序 .bash_profile，.bash_login，.bashrc和.profile做这相同的事情：设置和定义函数，变量和排序。
主要的不同是.bashrc在开启一个非登录的交互窗口是调用，.bash_profile和其他文件在登录的shell中执行。无论如何很多人都拥有.bash_profile和相似的.bashrc。
.profile VS .bash_profile(和.bash_login) .profile在很多shell启动的时候读取，包括bash。然后.bash_profile是指定bash的配置。对于通用的初始化代码，放在.profile中，但是指定bash的代码，放到.bash_profile中。
.profile并不是专门为bash设计的，但是.bash_profile是。(.profile是用于Bourne和其他类似的shell的，bash基于这个创作的。)如果找不到.bash_profile，就会去寻找.profile。
如果找不到.bash_profile的话，就会寻找.bash_login，但是最好是使用.bash_profile或.profile。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十五）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-45.html</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-45.html</guid>
      <description>git远端    参数 详情     -v, —verbos 冗长模式运行   -m  设置远端分支的头   —mirror=fetch 引用将不会保存在efs/remotes，而是保存在本地仓库内   —mirror=push git push表现的像--mirror被设置了   —no-tags git fetch &amp;lt;name&amp;gt;不会从远端仓库导入tag   -t  指定远端只追踪   -f 远端设置之后立即执行git fetch &amp;lt;name&amp;gt;   &amp;ndash;tags git fetch &amp;lt;name&amp;gt;从远端仓库导入每个tag   -a, —auto 符号引用的HEAD设置为远端HEAD的相同的分支。   -d, —delete 所有列出的引用都会从远端仓库删除   &amp;ndash;add 将添加到当前跟踪的分支列表（设置分支）   &amp;ndash;add 不是修改某些URL，而是添加一些URL(设置URL)   &amp;ndash;all 推送所有的分支。   &amp;ndash;delete 所有匹配的将会被删除。   —push 推送URL而不是拉取URL   -n 远端HEAD不是首先使用git ls-remote &amp;lt;name&amp;gt;，而是使用缓存信息   —dry-run 报告将修剪哪些分支，但不要实际修剪它们   —prune 删除没有本地对应的远端分支    显示远端仓库 使用git remote列出所有配置的远端仓库。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十九)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-39.html</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-39.html</guid>
      <description>读取文件    参数 详情     IFS 内部字段分隔符   file 文件名或路径   -r 当使用read时，防止反斜杠解析   -t 从readarray读取的每一行中删除尾部换行符   -d DELIM 读取到DELIM的第一个字符中断，而不是换行符    一行一行循环 while IFS= read -r line; do echo &amp;quot;$line&amp;quot; done &amp;lt;file  如果没有包含新行符号的话：
while IFS= read -r line || [ -n &amp;quot;$line&amp;quot; ]; do echo &amp;quot;$line&amp;quot; done &amp;lt;file  逐个字段循环 我们假设字段分隔符是:：
while IFS= read -d : -r field || [ -n &amp;quot;$field&amp;quot; ];do echo &amp;quot;**$field**&amp;quot; done &amp;lt; &amp;lt;(ping google.</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十四）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-44.html</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-44.html</guid>
      <description>git工作树    参数 详情     -f —force 默认情况下，当&amp;lt;branch&amp;gt;被另外的工作树使用，add拒绝添加新的工作树。这个选项将会强制创建。   -b  -B  当在添加或创建一个名字为&amp;lt; new-branch&amp;gt;的分支，将会在新的工作树上签出分支。如果忽略的话，默认是HEAD。默认-b当分支存在时，将不会创建新分支，但是-B会创建新的分支   &amp;ndash;detach 使用add，分类工作树中的HEAD   —[no-] checkout 默认add将会签出，然而—no-将会禁止签出，而使用自定义例如配置   -n —dry-run 使用prunce，这个选项将不会删除任何东西， 只是说明将会删除的内容。   &amp;ndash;porcelain 使用list，以易于解析的格式输出。无论用户怎么配置，都会在git中保持一致。   -v &amp;ndash;verbose 使用prune,的说明所有删除   —expire  使用prune，只会使早于的未使用的工作树过期。    使用工作树 你正在某个特性的开发工作中，这是你的老板来让你先修复一个问题。你通常会使用git stash来临时存储你的本地修改。然而，这时你的工作树处于混乱状态(新文件，移动文件，删除文件以及其他的一些文件)，你不想干扰你的进度。
通过添加一个临时的工作树，你可以创建一个临时关联的工作树来保存这个紧急修改，然后在功能完成之后移出这个工作树，恢复之前的修改：
$ git worktree add -b emergency-fix ../temp master $ pushd ../temp # .</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十八)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-38.html</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-38.html</guid>
      <description>case语句 简单语句 在所有bash版本支持的最简单格式中，case语句执行与模式匹配的case。如果有的话，;;在第一次匹配后中断。
#!/bin/bash var=1 case $var in 1) echo &amp;quot;Antartica&amp;quot; ;; 2) echo &amp;quot;Brazil&amp;quot; ;; 3) echo &amp;quot;Cat&amp;quot; ;; esac  输出：
Antartica  贯穿语句 Version&amp;gt;=4.0
从4.0开始，引入了新的操作符;&amp;amp;，支持贯穿操作。
#!/bin/bash var=1 case $var in 1) echo &amp;quot;Antartica&amp;quot; ;&amp;amp; 2) echo &amp;quot;Brazil&amp;quot; ;&amp;amp; 3) echo &amp;quot;Cat&amp;quot; ;&amp;amp; esac  输出：
Antartica Brazil Cat  子模式匹配贯穿 Version&amp;gt;=4.0
4.0开始，另一个操作符;;&amp;amp;，只有子语句匹配才贯穿的操作。
#!/bin/bash var=abc case $var in a*) echo &amp;quot;Antartica&amp;quot; ;;&amp;amp; xyz) echo &amp;quot;Brazil&amp;quot; ;;&amp;amp; *b*) echo &amp;quot;Cat&amp;quot; ;;&amp;amp; esac  输出：</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十三）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-43.html</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-43.html</guid>
      <description>git revisions的语法 通过对象名指定revision $ git show dae86e1950b1277e545cee180551750029cfe735 $ git show dae86e19  你可以使用SHA-1对象名称（完整的40位16进制字符串，或者在仓库中唯一的部分字符串）指定revision(或者任何的对象：tag，tree等待。目录内容，blob等等文件内容)。
象征的引用名称：分支，tag，远端分支 $ git log master #指定分支 $ git show v1.0 #指定tag $ git show HEAD #指定当前分支 $ git show origin #指定远端Origin默认追踪的分支  你可以使用象征名称指定一个revision：例如分支(如 master next 等)，tag(如v1.0 v2.0等)，如远端追踪分支(例如 origin，origin/master等)，或者当前分支的特定名称HEAD。
如果符号引用名称不明确，例如，如果同时具有名为“fix”的分支和标记（不建议使用同名的分支和标记），则需要指定要使用的引用类型：
$ git show heads/fix #或者 refs/heads/fix $ git show tags/fix #或者 refs/tags/fix  默认的revision:HEAD $ git show #等价于git show HEAD  HEAD是你当前工作树基于的提交所在的分支，通常是当前分支。很多(但不是全部)命令如果没有蚕食时都会使用HEAD作为默认的值。
Reflog references: @{} $ git show @{1} #显示当前分支的reflog $ git show master@{1} #显示分支master的reflog $ git show HEAD@{1} #显示HEAD的reflog  一个引用(通常是一个分支或HEAD)后面跟着@之后一个{}包围的数字，指定当前仓库向前数第n个的提交。你可以使用git reflog命令或者使用git log的—walk-reflogs/ -g选项。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十七)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-37.html</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-37.html</guid>
      <description>任务管理 显示后台进程 $ jobs [1] Running sleep 500 &amp;amp; (wd: ~) [2]- Running sleep 600 &amp;amp; (wd: ~) [3]+ Running ./Fritzing &amp;amp;  第一个字段是任务的id。+和-表示当前任务结束时的默认任务和下一个候选任务。当在没有任何参数的情况下使用fg或bg命令时，将使用默认作业。
第二个字段是当前任务的状态。第三个字段时用来启动这个进程的命令。
最后一个字段（wd：~）表示sleep命令是从工作目录（home）启动的。
从后台取一个进程到前台  $ fg %2 sleep 600  %2意味着第2个进程。如果fg命令没有带参数，将会把最后一个命令取到前台。
 $ fg %?sle sleep 500  ?sle意味着取出包含sle的命令。如果有多个后台命令匹配，将会出现一个错误。
重启以停止的命令 $ bg [8]+ sleep 600 &amp;amp;  运行后台命令  $ sleep 500 &amp;amp; [1] 7582  把sleep命令放到后台执行。7582就是这个进程的id。
终止一个前台进程 Ctrl+Z终止前台进程，并放入到后台执行。
$ sleep 600 ^Z [8]+ Stopped sleep 600  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十二）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-42.html</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-42.html</guid>
      <description>blame    参数 详情     filename 需要显示详情的文件名称   -f 在详情中显示文件的名称   -e 使用作者的邮箱地址代替作者的名称   -w 当在父子版本之间比较时忽略掉空格   -L start,end 显示指定行范围内的详情，行从1开始。例如 git blame -L 1,2 [filename]   —show-stats 在详情末尾输出额外的统计信息   -l 输出长的hash值(默认不输出)   -t 输出时间戳(默认输出时间格式)   -reverse 反向输出详情信息   -p,—porcelain 输出机器理解的格式   -M 检查文件中移动或复制的行   -C 除了想-M一样，还检查统一提交中其他文件中移动或复制的行   -h 显示帮助信息   -c 使用和git annotate相同格式的输出(默认off)   -n 输出在原来提交中的行号(默认off)    只显示指定的行 输出可以被限定在指定的行区间内：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十六)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-36.html</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-36.html</guid>
      <description>内部变量 简单介绍一下Bash的内部变量，并说明在什么地方，怎么使用以及何时使用这些变量。
Bash内部变量一览    变量 详情      函数/脚本可以选择的变量或参数。   $* $@ $*和$@和$1 $2..这样的内容是一样的(注意：通常不引用这些内容是没有意义的) &amp;quot;$*&amp;quot; 和 &amp;quot;$1 $2 … 一样。&amp;quot;$@&amp;quot;和&amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot; …一样。&amp;quot;$*&amp;quot;是由$IFS的第一个字符分割的，不一定是空格   $# 传个脚本或者函数的参数的数量   $! 最后放入后台工作(管道的最右边那个)的job的id。(注意：当启用作业控制时，它不一定和作业的组id相同)   $$ bash正在执行的进程的id   $? 最后一个命令的退出状态   $n 指定位置的参数 n=1,2,3,4…9   ${n} 和上面一样，但是n可以大于9   $0 在执行脚本时，是脚本的路径。bash -c &#39;printf &amp;quot;%s\n&amp;quot; &amp;quot;$0&amp;quot;&#39; name。name(内部脚本的第一个参数)或者，argv[0]会获得bash   $_ 命令的最后一个字段   $IFS 内建的字段分隔符   $PATH 用来寻找可执行脚本的路径地址   $OLDPWD 前一个工作目录   PWD 当前的工作目录   FUNCNAME 调用栈内的函数名称数组   BASH_SOURCE 包含FUNCNAME数组中函数的地址的数组。可以用来寻找脚本路径。   $BASH_ALIAS 当前定义别名的管理数组   BASH_REMATCH 上一个正则表达式匹配的结果   BASH_VERSION bash版本的字符串   BASH 到当前执行的bash的绝对路径。(由bash根据argv[0]和$path的值以启发式方式确定；在某些情况下可能是错误的)   BASH_SUBSHELL bash subshell的等级   $UID 运行bash的进程的实际（如果不同则无效）用户ID   $PS1 主进程的命令提示   $PS2 辅助命令行提示（用于附加输入）   PS3 三级命令行提示（用于select循环）   PS4 第四级命令行提示（用于附加详细输出的信息）   RANDOM 0-32767之间的伪随机整数   $REPLY 当变量没有指定时，默认为read的使用的变量。SELECT还用于用户返回的值   PIPESTATUS 数组变量，保存最近执行的前台管道中每个命令的退出状态值。     变量赋值的时候等号前后不能有空格。a=123而不是a = 123。后者（由空格包围的等号）单独表示使用参数=和123运行命令a，尽管在字符串比较运算符（从语法上讲，它是[或[[或使用的任何测试]的参数）中也可以看到。</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十一）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-41.html</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-41.html</guid>
      <description>搜索/查找错误提交 二进制搜索(git bisect) git bisect允许你使用二进制搜索查找哪个提交引入了错误。
首先通过两个提交的引用来搜索：一个在bug之前的提交，一个在bug之后的提交。一般来说，错误的提交时HEAD。
# start the git bisect session $ git bisect start # give a commit where the bug doesn&#39;t exist $ git bisect good 49c747d # give a commit where the bug exist $ git bisect bad HEAD  这里git开启了一个二进制搜索：这里把修订分为两个部分，并把仓库切换到中间的修订。检查代码确定这个修订是好的还是坏的：
# tell git the revision is good, # which means it doesn&#39;t contain the bug $ git bisect good # if the revision contains the bug, # then tell git it&#39;s bad $ git bisect bad  git会根据你的操作对没有改包含错误修改的部分进行二进制的搜索。git最后只会有一个修改版本，除非你标记错误了，否则这个版本就是包含错误的版本。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十五)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-35.html</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-35.html</guid>
      <description>修改shell 查找当前的shell 有好几种方式获取当前的shell：
echo $0 ps -p $$ echo $SHELL  列出所有有效shell 列出所有有效的shell
cat /etc/shells  例如：
$ cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash  修改shell 修改当前的shell可以使用下面的命令：
 export SHELL=/bin/bash exec /bin/bash  修改.profile文件，添加上面的内容。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（四十）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-40.html</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-40.html</guid>
      <description>使用gitk图形化显示提交历史 显示一个文件的提交历史 gitk path/to/myfile  显示两个提交之间的提交 假设你有d9e1db9和5651067两个提交，然后想要看这两个提交之间的提交。d9e1db9是老提交，5651067是提交链上的末尾提交。
gitk --ancestry-path d9e1db9 5651067  显示tag之后的提交 如果你有v2.3的tag，你可以获取这个tag之后的所有提交
gitk v2.3..  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十四)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-34.html</link>
      <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-34.html</guid>
      <description>模式匹配和正则表达式 获取字符串正则匹配的内容 a=&#39;I am a simple string with digits 1234&#39; pat=&#39;(.*) ([0-9]+)&#39; [[ &amp;quot;$a&amp;quot; =~ $pat ]] echo &amp;quot;${BASH_REMATCH[0]}&amp;quot; echo &amp;quot;${BASH_REMATCH[1]}&amp;quot; echo &amp;quot;${BASH_REMATCH[2]}&amp;quot;  输出：
I am a simple string with digits 1234 I am a simple string with digits 1234  glob未匹配时的行为 $ mkdir globbing $ cd globbing $ mkdir -p folder/{sub,another}folder/content/deepfolder/ touch macy stacy tracy &amp;quot;file with space&amp;quot; folder/{sub,another}folder/content/deepfolder/file .hiddenfile $ shopt -u nullglob $ shopt -u failglob $ shopt -u dotglob $ shopt -u nocaseglob $ shopt -u extglob $ shopt -u globstar  在这个例子里面，使用nullglob和failglob时将没有匹配任何内容。无论使用了哪一个，如果没有匹配的时候，bash将会返回glob本身。</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十九）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-39.html</link>
      <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-39.html</guid>
      <description>bundles 在本地创建一个bundle并应用到另一个 如果你想保持没有网络的机器上面的仓库的版本信息。 bundle允许你打包一台机器上这个仓库的对象和引用，然后应用到另一台机器的仓库上。
git tag 2016_07_04 git bundle create changes_between_tags.bundle [some_previous_tag]..2016_07_24  以某种方式把changes_between_tags.bundle传到远端的机器上，例如：thumb drive。一旦你有了这个文件：
git bundle verify changes_between_tags.bundle # make sure bundle arrived intact git checkout [some branch] # in the repo on the remote machine git bundle list-heads changes_between_tags.bundle # list the references in the bundle git pull changes_between_tags.bundle [reference from the bundle, e.g. last field from the previous output]  反过来也是可能的。一旦对远程存储库进行了更改，您就可以将增量放入bundle里面；将更改放在（例如）一个拇指驱动器上，然后将它们合并回本地存储库，这样两个存储库就可以保持同步，而不需要在计算机之间直接访问git、ssh、rsync或http协议。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-33.html</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-33.html</guid>
      <description>debug调试 使用-n检查脚本语法 使用-n允许你在不执行脚本的情况下检查这个脚本：
~&amp;gt; $ bash -n testscript.sh testscript.sh: line 128: unexpected EOF while looking for matching `&amp;quot;&#39; testscript.sh: line 130: syntax error: unexpected end of file  使用bashdb调试 bashdb是一个和gdb雷士的工具，使用这个工具你可以实现某行或者某个方法的中断，输出变量的内容，或者重启脚本等等。
通常可以使用包管理器按照这个工具，像在Fedroa中：
sudo dnf install bashdb  你可以从首页上获取这个工具。然后可以使用它像参数一样运行这个脚本：
bashdb &amp;lt;YOUR SCRIPT&amp;gt;  下面是一些你可以使用的命令：
l - show local lines, press l again to scroll down s - step to next line print $VAR - echo out content of variable restart - reruns bashscript, it re-loads it prior to execution.</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十八）</title>
      <link>http://blog.huaifufeng.com/2019/03/post/git-section-38.html</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/git-section-38.html</guid>
      <description>解决冲突 手动解决 当你在执行一个git merge命令的时候，你可能会发现一个“merge conflict”的错误。这将会告诉你哪些文件冲突了，你需要解决这些冲突。
一个git status不管在什么时候都可以给你提供一个帮助信息，帮助你查看你需要做什么事情。
On branch master You have unmerged paths. (fix conflicts and run &amp;quot;git commit&amp;quot;) Unmerged paths: (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to mark resolution) both modified: index.html no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)  Git在冲突文件中添加了一些标识来告诉你哪些地方发生冲突了：
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD: index.html #indicates the state of your current branch &amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;contact : email@somedomain.com&amp;lt;/div&amp;gt; ========= #indicates break between conflicts &amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt; please contact us at email@somedomain.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十二)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-32.html</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-32.html</guid>
      <description>getopts:智能位置-参数分析    参数 详情     optstring 要识别的选项字符串   name 然后命名存储解析选项的位置    pingmap #!/bin/bash # Script name : pingnmap # Scenario : The systems admin in company X is tired of the monotonous job # of pinging and nmapping, so he decided to simplify the job using a script. # The tasks he wish to achieve is # 1. Ping - with a max count of 5 -the given IP address/domain.</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十七）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-37.html</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-37.html</guid>
      <description>show 简介 git show显示各种git对象。
显示Commit: 显示提交信息和其中包含的修改信息。
   Command Description     git show 显示之前的提交   git show @~3 显示最后提交之前第3个提交    显示tree和blob：    Command Description     git show @~3 显示项目的根目录，显示3个提交之前的（tree）   git show @~3:src/program.js 显示3个提交之前src/program.js的信息（blob）   git show @:a.txt @:b.txt 现在当前提交中a.txt和b.txt的拼接    显示tags: 显示tag的信息和引用的对象。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十一)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-31.html</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-31.html</guid>
      <description>花括号扩展 修改文件名扩展 $ mv filename.{jar,zip}  这个将会执行mv filename.jar filename.zip这个命令
创建按照年月分组文件的目录 $ mkdir 20{09..11}-{01-12}  执行ls命令，将会看到下面的目录被创建了：
2009-01 2009-04 2009-07 2009-10 2010-01 2010-04 2010-07 2010-10 2011-01 2011-04 2011-07 2011-10 2009-02 2009-05 2009-08 2009-11 2010-02 2010-05 2010-08 2010-11 2011-02 2011-05 2011-08 2011-11 2009-03 2009-06 2009-09 2009-12 2010-03 2010-06 2010-09 2010-12 2011-03 2011-06 2011-09 2011-12  在9前面加上0确保当个数字有一个0。你也可以在数字前面使用多个0，例如：
$ echo {001..10} 001 002 003 004 005 006 007 008 009 010  创建.文件的备份 $ cp .</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十六）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-36.html</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-36.html</guid>
      <description>迁移到git subGit subGit可以用来把SVN仓库一次性导入到git仓库内。
$ subgit import --non-interactive --svn-url http://svn.my.cm/repos/myproject myproject.git  使用Atlassian转换工具迁移SVN到GIT 从这里下载Atlassian转换工具。这个工具依赖于java，所以在你计划迁移之前确保你的本地安装有java运行环境JRE。
使用java -jar svn-migration-scripts.jar verify命令来检查你是否缺少完成迁移工作必须的程序。特别是这个命令会检查Git，subversion，git-svn工具。也会检查你的系统是否区分大小写。迁移到Git的工作应该在区分大小写的系统上进行，避免毁坏仓库。
接下来你需要生成一个作者文件。Subversion只追踪提交者做的修改。然而Git使用两种信息来区分一个用户：真实名称和邮箱地址。下面的命令会生成一个txt文件，会把Subversion的用户名和Git等价起来：
java -jar svn-migration-scripts.jar authors &amp;lt;svn-repo&amp;gt; authors.txt  这里是你想要进行转换的Subversion仓库的地址。运行这个命令只会，贡献者的身份信息会把映射到authors.txt中。邮箱地址会是下面这样的格式：@mycompany.com。在作者文件里面，你需要手动修改每一个人的默认名称（默认是他们的用户名）为他们的实际名称。在使用之前确保所有的邮箱地址是正确的。
下面的命令会克隆一个SVN库到Git仓库：
git svn clone --stdlayout --authors-file=authors.txt &amp;lt;svn-repo&amp;gt; &amp;lt;git-repo-name&amp;gt;  是像上面一样的仓库地址，是当前目录中用来克隆仓库的目录名称。在执行这个命令之前有一些需要注意的地方：
 —stdlayout选项告诉Git使用trunk，branches，tags目录的标准布局。非标准的Subversion仓库的布局要求你指定trunk目录，branch目录，tag目录的本地路径。这可以使用下面的例子：git svn clone --trunk=/trunk --branches=/branches --branches=/bugfixes --tags=/tags --quthors-file=authors.txt &amp;lt;svn-repo&amp;gt; &amp;lt;git-repo-name&amp;gt; 这个命令执行多长时间依赖于你仓库的大小 要减少大仓库的转换时间，这个转换过程可以在Subversion仓库的服务器上运行，减少网络传输时间  git svn clone将Subversion的分支（包括trunk）导入为远端的分支，包括Subversion的tags（远端分支前缀为tags/）。要将它们转换为实际的分支和标记，请在Linux机器上按提供的顺序运行以下命令。运行这个命令之后，git branch -a显示所有正确的分支名称，git tag -l显示仓库的标记。
git for-each-ref refs/remotes/origin/tags | cut -d / -f 5- | grep -v @ | while read tagname; do git tag $tagname origin/tags/$tagname; git branch -r -d origin/tags/$tagname; done git for-each-ref refs/remotes | cut -d / -f 4- | grep -v @ | while read branchname; do git branch &amp;quot;$branchname&amp;quot; &amp;quot;refs/remotes/origin/$branchname&amp;quot;; git branch -r -d &amp;quot;origin/$branchname&amp;quot;; done  这样从svn到Git的转换过程就完成了。可以使用push把本地的仓库推送到服务器。并且可以继续使用git来更新仓库，这个仓库包括svn的所有提交历史。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-30.html</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-30.html</guid>
      <description>定制化PS1 修改终端的颜色和提示 gitPS1(){ gitps1=$(git branch 2&amp;gt;/dev/null | grep &#39;*&#39;) gitps1=&amp;quot;${gitps1:+ (${gitps1/#\* /})}&amp;quot; echo &amp;quot;$gitps1&amp;quot; } #Please use the below function if you are a mac user gitPS1ForMac(){ git branch 2&amp;gt; /dev/null | sed -e &#39;/^[^*]/d&#39; -e &#39;s/* \(.*\)/ (\1)/&#39; } timeNow(){ echo &amp;quot;$(date +%r)&amp;quot; } if [ &amp;quot;$color_prompt&amp;quot; = yes ]; then if [ x$EUID = x0 ]; then PS1=&#39;\[\033[1;38m\][$(timeNow)]\[\033[00m\] \[\033[1;31m\]\u\[\033[00m\]\[\033[1;37m\]@\[\033[00m\]\[\033[1;33m\]\h\[\033[00m\] \[\033[1;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\] \[\033[1;31m\]:/#\[\033[00m\] &#39; else PS1=&#39;\[\033[1;38m\][$(timeNow)]\[\033[00m\] \[\033[1;32m\]\u\[\033[00m\]\[\033[1;37m\]@\[\033[00m\]\[\033[1;33m\]\h\[\033[00m\] \[\033[1;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\] \[\033[1;32m\]:/$\[\033[00m\] &#39; fi else PS1=&#39;[$(timeNow)] \u@\h \w$(gitPS1) :/$ &#39; fi  下面就是配置终端的显示样式：</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十五）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-35.html</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-35.html</guid>
      <description>filter-branch修改提交历史 修改提交作者 你可以使用环境筛选器修改提交的作者。只需要在修改提交作者的脚本中修改并导出$GIT_AUTHOR_NAME。
创建一个包含下面内容的filter.sh脚本：
if [ &amp;quot;$GIT_AUTHOR_NAME&amp;quot; = &amp;quot;Author to Change From&amp;quot; ] then export GIT_AUTHOR_NAME=&amp;quot;Author to Change To&amp;quot; export GIT_AUTHOR_EMAIL=&amp;quot;email.to.change.to@example.com&amp;quot; fi  然后在命令行中运行这个命令：
chmod +x ./filter.sh git filter-branch --env-filter ./filter.sh  修改提交人为提交作者 下面的命令修改commit1..commit2之间提交的提交人为提交的作者。
git filter-branch -f --commit-filter \ &#39;export GIT_COMMITER_NAME=\&amp;quot;$GIT_AUTHOR_NAME\&amp;quot;; export GIT_COMMITER_EMAIL=\&amp;quot;$GIT_AUTHOR_EMAIL\&amp;quot;; export GIT_COMMITER_DATE=\&amp;quot;$GIT_AUTHOR_DATE\&amp;quot;; git commit-tree $@&#39; \ -- commit1..commit2  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十九)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-29.html</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-29.html</guid>
      <description>可编程补全 函数实现补全 _mycompletion(){ local command_name=&amp;quot;$1&amp;quot; local current_word=&amp;quot;$2&amp;quot; local previous_word=&amp;quot;$3&amp;quot; # COMPREPLY is an array which has to be filled with the possible completions # compgen is used to filter matching completions COMPREPLY==( $(compgen -W &#39;hello world&#39; -- &amp;quot;$current_word&amp;quot;) ) } complette -F _mycompletion mycommand  使用例子：
$ mycommand [TAB][TAB] hello world $ mycommand h[TAB][TAB] $ mycommand hello  选项和文件名的简单补全 # The following shell function will be used to generate completions for # the &amp;quot;nuance_tune&amp;quot; command.</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十四）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-34.html</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-34.html</guid>
      <description>Archive    参数 详情     —format= 归档结果的格式：tar或zip。如果没有这个选项，并且提供了文件名称，可能的话就会从文件名中解析。否则就是tar。   -l,—list 列出所有有效的归档   -v,—verbose 将详细的进度输出到stderr   —prefix=/ 在归档的每个文件前面添加/   -o file, —output file 把归档写入某个文件，而不是stdout   —worktree-abttributes 寻找工作树中gitattributes中的属性    可以是任何归档后台程序理解的选项。对zip来说，使用-0是不降低质量，使用-1到-9调整压缩速度和比率   —remote= 从远端仓库获取归档而不是从本地仓库   —exec= 使用—remote来指定远端上的路径    用来归档的tree或者提交    如果没有一个选项，本地工作目录的所有文件和目录都会被包含在归档中。如果一个或多个路径制定了，只会把这些文件包含到归档内。    创建git仓库的归档 使用git archive命令可以创建仓库的压缩归档文件，例如用来分发版本。
创建一个当前HEAD修订的归档文件：
git archive --format tar HEAD | cat &amp;gt; archive-HEAD.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十八)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-28.html</link>
      <pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-28.html</guid>
      <description>过程替换 比较web文件 下面的例子用diff命令执行过程替换来比较两个文件，而不是创建两个临时文件。
diff &amp;lt;(curl http://www.example.com/page1) &amp;lt;(curl http://www.example.com/page2)  while循环从命令输出获取 下面使用grep命令的输出作为while循环的输出参数：
while IFS=&amp;quot;:&amp;quot; read -r user _ do #&amp;quot;$user&amp;quot; 有/etc/passwd中的密码 done &amp;lt; &amp;lt;(grep &amp;quot;hello&amp;quot; /etc/passwd)  拼接文件 总所周知，你不能在一个命令里面把一个文件既当做输入文件也当做输出文件，例如：
$ cat header.txt body.txt &amp;gt;body.txt  不会产生你希望的结果。当cat命令读取body.txt文件的内容时，这个文件已经被重定向截断，并且内容是空。最后body.txt只会有header.txt的内容。
某些人可能相应使用进程替换来避免这个效果，就是下边这样：
$ cat header.txt &amp;lt;(cat body.txt) &amp;gt; body.txt  将强制在重定向截断文件之前，将body.txt的原始内容以某种方式保存在某个缓冲区中。但是这并没有作用。括号中的cat只有在所有文件描述符都设置好之后才开始读取文件，就像外部的描述符一样。在这种情况下，尝试使用流程替换是没有意义的。
将文件预处理到另一个文件的唯一方法是创建中间文件：
$ cat header.txt body.txt &amp;gt; body.txt.new $ mv body.txt.new body.txt  当使用交互编辑选项-i调用sed、perl或类似的命令时，会在后台默默执行这些命令。
同时通过多个程序传输文件 下面的命令使用wc -l计算同时使用gzip压缩大文件的行数，两者同时运行：
$ tee &amp;gt;(wc -l &amp;gt;&amp;amp;2) &amp;lt; bigfile | gzip &amp;gt; bigfile.</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十三）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-33.html</link>
      <pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-33.html</guid>
      <description>git-svn 克隆一个SVN仓库 你需要使用下面的命令创建一个仓库的本地新副本。
git svn clone SVN_REPO_ROOT_URL [DEST_FOLDER_PATH] -T TRUNK_REPO_PATH -t TAGS_REPO_PATH -b BRANCHES_REPO_PATH  如果你的SVN仓库在标准的模式下面（trunk，branchs，tags目录），你可以使用下面的命令。
git svn clone -s SVN_REPO_ROOT_URL [DEST_FOLDER_PATH]  git svn clone命令一个接一个的切换成SVN的修改，在你的本地仓库新建一个Git提交来重建历史的提交。如果SVN仓库有很多的提交，这将会花费很多的时间。
当命令执行完毕之后，你会获得一个仓库的完整信息，本地的git分支名称叫做master，也就是SVN仓库的trunk分支。
推送修改到SVN 下面的命令
git svn dcommit  将会为你本地的每一个git提交创建一个SVN的修订历史。和svn一样，你的本地git仓库必须同步svn仓库的全部修改，所以如果这个命令失败了，就先尝试运行git svn rebase。
在本地工作 就像git仓库一样使用本地的git仓库，使用git常用的命令：
 git add FILE和git checkout — FILE暂存或取消暂存一个文件 git commit来提交修改。这些提交都是本地的，不会推送到SVN仓库，像普通的git仓库一样。 git stash和git stash pop暂存和应用暂存修改 git reset HEAD —hard恢复本地所有的修改 git log访问仓库的所有历史 git rebase -i可以自由的修改提交历史 git branch和git checkout -b创建新的本地分支  就像git-svn描述的：Subversion是一个远没有git复杂的系统。所以你不能在不毁坏Subversion服务的情况下使用过全部的git功能。幸运的是规则非常简单：保持线性的提交历史。
这意味着你可以做几乎所有的git操作：创建分支，删除/重拍/压缩提交，改变提交历史，删除提交等等。除了merge操作。如果你要整合本地提交的历史，使用git rebase命令。
当你进行merge操作的时候，一个merge提交就建立了。一个特别需要注意的事：merge提交拥有两个父提交，这样提交历史就不是线性的了。当你推送一个merge提交到这个仓库的时候，SVN会非常糊涂。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十七)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-27.html</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-27.html</guid>
      <description>Scoping 动态作用域 动态作用域的含义是：动态范围是指变量查找发生在调用函数的范围内，而不是在定义函数的范围内。
$ x=3 $ func1 () { echo &amp;quot;in func1: $x&amp;quot;;} $ func2 () { local x=9; func1;} $ func2 in func1 9 $ func1 in func1: 3  在词汇范围语言中，func1总是在全局范围中查找x的值，因为func1是在本地范围中定义的。
在动态范围语言中，func1查找调用它的范围。当从func2中调用它时，它首先在func2的主体中查找值x。如果没有在那里定义它，它将在全局范围中查找，其中func2是从全局范围调用的。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十二）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-32.html</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-32.html</guid>
      <description>空目录 假设你用下面的目录结构初始化了一个项目：
/build app.js  然后你添加所有的文件并且提交：
git init git add . git commit -m &amp;quot;Initial commit&amp;quot;  git将会值追踪app.js文件。
假设你想应用程序添加了一个构建步骤，并依赖“构建”目录作为输出目录（你不想让它成为每个人都必须遵循的安装命令），惯例是在目录中包含一个“.gitkeep”文件，并让git跟踪该文件。
/build .gitkeep app.js  然后添加这个新文件：
git add build/.gitkeep git commit -m &amp;quot;Keep the build directory around&amp;quot;  git现在追踪文件build/.gitkeep，因此build目录讲座签出时有效。同时这只是一个月的，而不是git的特性。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十六)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-26.html</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-26.html</guid>
      <description>Bash算法    参数 详情     EXPRESSION 执行的表达式    (())算法 #!/bin/bash echo $((2 + 1))  输出3。
#!/bin/bash var1=4 var2=5 ((output=$var1 * $var2)) printf &amp;quot;%d\n&amp;quot; &amp;quot;$output&amp;quot;  输出20
算法命令  let   let num=1+2 let num=&amp;quot;1+2&amp;quot; let &#39;num= 1 + 2&#39; let num=1 num+=2  如果有空格或者填充字符，你就需要引号了。所有下面会出现错误：
 let num= 1 + 2 //错误 let &#39;num = 1 + 2&#39; //正确 let a[1] = 1 + 1 //错误 let &#39;a[1] = 1 + 1&#39; //正确   (())   ((a=$a+1)) //a加1 ((a = a + 1)) //a加1 ((a += 1)) //a加1  我们可以在if表达式中使用(())。例如：</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十一）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-31.html</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-31.html</guid>
      <description>git-tfs git-tfs克隆 这将创建一个和项目名一样的目录，/My.Project.Name：
$ git tfs clone http://tfs:8080/tfs/DefaultCollection/ $/My.Project.Name  从裸Git仓库克隆 从git仓库克隆比直接从TFV仓库克隆快10倍，并且在团队中工作的很好。至少有一个团队成员必须首先通过执行常规的git-tfs克隆来创建裸露的git存储库。然后可以引导新的存储库使用TFV。
$ git clone x:/fileshare/git/My.Project.Name.git $ cd My.Project.Name $ git tfs bootstrap $ git tfs pull  通过Chocolatey安装 下面假设你使用kdiff3来进行文件差异，虽然不是必须的但是这是给好主意：
C:\&amp;gt; choco install kdiff3  可以先安装Git，这样就可以说出你想要的任何参数。这里还安装了所有Unix工具，&amp;rsquo;NoAutoCrlf&amp;rsquo;表示按原样切换，按原样提交。
C:\&amp;gt; choco install git -params &#39;&amp;quot;/GitAndUnixToolsOnPath /NoAutoCrlf&amp;quot;&#39;  这是所有你使用Chocolatey安装git-tfs的所有事情：
C:\&amp;gt; choco install git-tfs  签入 启动TFVS的“检入”对话框。
$ git tfs checkintool  这将占用您所有的本地提交并创建一个单一的check-in。
推送 推送本地的所有提交到TFVS远端。
$ git tfs rcheckin  注意：如果需要签入备注，这将失败。 可以通过将git-tfs-force：rcheckin添加到提交消息来绕过这些。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十五)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-25.html</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-25.html</guid>
      <description>Math dc是Unix系统中最古老的命令之一。
它使用reverse polish notation，这意味着：你首先存在数字，然后提供操作符。例如1+1就写成1 1 +。
打印前面存储的数据，使用p命令：
$ echo &#39;2 3 + p&#39; | dc 5 # 或者 $ dc &amp;lt;&amp;lt;&amp;lt; &#39;2 3 + p&#39; 5  你可以多次打印顶层元素：
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;1 1 + p 2 + p&#39; 2 4  负数使用_前缀：
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;_1 p&#39; -1  你可以使用A到F之前的字符标识10到15之间的数字。.表示小数符合。
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;A.4 p&#39; 10.4  dc是任意精度的，这意味着只要内存许可精度是不收限制的。默认情况下精度是0：
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;4 3 / p&#39; 1  我们可以提升之前命令的精度使用k命令。像下面这样：</description>
    </item>
    
    <item>
      <title>Git专业笔记（三十）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-30.html</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-30.html</guid>
      <description>内部概念 仓库 一个git repository就是硬盘上面存储了一系列的文件和目录信息的数据结构。
这些信息在你的.git/目录下面。每一次你使用git提交数据，它都会把数据存储在这里。反过来说，.git/目录保存了每一个单独提交。
它基本的结构像下面一样：
.git/ objects/ refs/  对象 Git从根本上说是一个键值存储。当你向git添加数据的时候，将会构建一个对象，并且使用对象内容的SHA-1值作为键值。
因此，任何git里面的内容都可以通过hash值找到：
git cat-file -p 4bb6f98  有四种类型的对象：
 blob tree commit tag  HEAD引用 HEAD是一个特殊的ref。它将会一直指向当前的对象。
你可以查看.git/HEAD文件当前指向的内容。
一般来说，HEAD指向另一个ref：
$ cat .git/HEAD ref: refs/heads/mainline  但是它也可以指向另外的对象：
$ cat .git/HEAD 4bb6f98a223abc9345a0cef9200562333  这就是所谓的“分离的头部”——因为HEAD不连接（指向）任何引用，而是直接指向一个对象。
引用 一个ref本质是一个指针，指向对象的名称。例如：
&amp;quot;master&amp;quot; --&amp;gt; 1a410e...  他们都存储在.git/refs/heads/这个文本文件内。
$ cat .git/refs/heads/mainline 4bb6f98a223abc9345a0cef9200562333  这通常被叫做分支。但是你要注意在Git里面没有分支，只有引用。
现在完全可以通过hash值来跳转到不同的对象。但这会非常不方便。引用提供了一个便捷的名称来引用对象。要求Git按名称而不是哈希去特定的地方要容易得多。
提交对象 提交可能是用户最熟悉的对象类型。因为这是他们使用git命令创建的对象类型。
然后提交没有直接包含任何修改过的文件或数据。相反，它主要包括元数据和指向其他对象的指针，这些对象包含提交的实际内容。
一个提交对象包含下面的内容：
 一个tree的hash值 父commit的hash值 作者的名称/邮箱，提交者的名称/邮箱 提交信息  你可以像下面一样查看任何提交的内容：
$ git cat-file commit 5bac93 tree 04d1daef.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十四)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-24.html</link>
      <pubDate>Wed, 20 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-24.html</guid>
      <description>Bash的历史替换 快速引用 操作历史记录 #列出所有之前的命令 history #如果你不小心输入了命令，这时候清除所有的历史是很有用的 history -c  事件指示符 #执行历史中第n行的命令 !n #执行最后的命令 !! #执行最后以&#39;text&#39;文本开始的命令 !text #执行最后包含&#39;text&#39;的命令 !?text #执行n行之前的命令 !-n #执行最后一个以&#39;foo&#39;开头的并将&#39;foo&#39;替换为&#39;bar&#39;的命令 ^foo^bar^ #执行当前的命令 !#  单词指示符 它们由:与它们所引用的事件指示符分开。如果事件指示符不是数字开始的，可以省略冒号：!^和!:^是一样的。
#获取最后命令的第一个参数 !^ #获取最后命令的最后参数(!!:$的短格式) !$ #获取最后命令的第3个参数 !:3 #获取最后命令从x到y之间的参数，可以是数字，也可以是 $ ^ !:x-y #获取最后命令处理第0个之外的所有参数，等价于 :^-$ !*  修改 这些会修改前面的事件或单词指示符。
#使用sed语法替换。允许标记在s和可选分隔符之前 :s/foo/bar/ #替换最开始的foo为bar :gs|foo|bar| #替换所有的foo为bar #从最后一个参数删除前导路径(tail) :t #从最后一个参数删除尾随路径(head) :h #删除最后一个参数的文件扩展名 :r  如果Bash变量HISTCONTROL包含ignorrespace或ignoreboth（或者包含模式[ ]*）,这样你不想把你的命令添加到history的时候，可以在命令前面添加空格：
#不保存 foo #保存 bar  以sudo权限执行之前的命令 $ apt-get install r-base E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied) E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十九）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-29.html</link>
      <pubDate>Wed, 20 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-29.html</guid>
      <description>push    参数 详情     &amp;ndash;force 强制重命名或移动一个文件，哪怕目标已经存在   —verbose 运行详细信息    将要push到的远端仓库   &amp;hellip; 指明将要使用本地ref或对象更新的远端引用    在Git修改，暂存和提交代码之后，接下来就需要push操作来把你本地的修改分享给其他人，把你本地的修改推送到仓库服务器。这个主题主要介绍如果使用Git来推送代码。
推送指定对象到远端分支 一般语法 git push &amp;lt;remottename&amp;gt; &amp;lt;object&amp;gt;:&amp;lt;remotebranchname&amp;gt;  例子 git push origin master:wip-yourname  这个例子将会推送你本地的master分支到origin的wip-yourname分支上面（一般是你克隆的仓库）。
删除远端分支 删除远端分支就等价于推送一个空对象到远端。
git push &amp;lt;remotename&amp;gt; :&amp;lt;remotebranchname&amp;gt;  例子 git push origin :wip-yourname  将会删除你的远端分支wip-yourname。
除了使用冒号，你可以使用—delete选项来代替，在一些情况下是更加可读的。
例子 git push origin --delete wip-yourname  推送单独提交 如果你本地有一个单独的提交，你想要推送到远端不推送其他的内容，你可以使用下面的命令：
git push &amp;lt;remotename&amp;gt; &amp;lt;commit SHA&amp;gt;:&amp;lt;remotebrranchname&amp;gt;  例子 假设存在一个像下面一样的提交历史：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十三)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-23.html</link>
      <pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-23.html</guid>
      <description>脚本变量 多变量解析 解析很多变量，最好的办法就是使用while循环，加上case语句和shift。
shift是从一系列变量中回去第一个变量，比如当前是$1，使用这个你将会获得$2。这在一次处理多个变量的时候非常有用。
#!/bin/bash #加载用户定义的变量 while [[ $# &amp;gt; 0 ]] do case &amp;quot;$1&amp;quot; in -a|--valueA） valA=&amp;quot;$2&amp;quot; shift ;; -b|--valueB) valB=&amp;quot;$2&amp;quot; shift ;; --help|*) echo &amp;quot;Usage:&amp;quot; echo &amp;quot; --valueA \&amp;quot;value\&amp;quot;&amp;quot; echo &amp;quot; --valueB \&amp;quot;\value&amp;quot;&amp;quot; echo &amp;quot; --help&amp;quot; exit 1 ;; esac shift done echo &amp;quot;A: $valA&amp;quot; echo &amp;quot;B: $valB&amp;quot;  输入和输出：
$ ./multipleParams.sh --help Usage: --valueA &amp;quot;value&amp;quot; --valueB &amp;quot;value&amp;quot; --help $ ./multipleParams.sh A: B: $ ./multipleParams.sh --valueB 2 A: B: 2 $ .</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十八）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-28.html</link>
      <pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-28.html</guid>
      <description>重命名    参数 详情     -f 或者&amp;ndash;force 强制重命名或移动一个文件，哪怕目标已经存在    重命名目录 重命名一个目录，从oldname到newname：
git mv directoryToFolder/oldName directoryToFolder/newName  然后就可以git commit和git push了。
如果出现了错误：
 fatal: renaming &amp;lsquo;directoryToFolder/oldName&amp;rsquo; failed: Invalid argument
 使用下面的命令：
git mv directoryToFolder/oldName temp &amp;amp;&amp;amp; git mv temp directoryToFolder/newName  重命名本地和远端分支 最简单的方式是切换出本地的分支：
git checkout old_branch  然后重命名本地分支，删除老分支，设置上游的新分支名称：
git branch -m new_branch git push origin :old_branch git push --set-upstream origin new_branch  重命名本地分支 你可以使用下面的命令重命名本地分支：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十二)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-22.html</link>
      <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-22.html</guid>
      <description>条件表达式 文件类型检查 -e检查文件是否存在，包括所有的文件类型（如：括号，文件。。。）
if [[ -e $filename ]]; then echo &amp;quot;$filename exists&amp;quot; fi  也可以对指定类型的文件格式进行检查：
if [[ -f $filename ]]; then echo &amp;quot;$filename is a regular file&amp;quot; elif [[ -d $filename ]]; then echo &amp;quot;$filename is a directory&amp;quot; elif [[ -p $filename ]]; then echo &amp;quot;$filename is a named pipe&amp;quot; elif [[ -S $filename ]]; then echo &amp;quot;$filename is a named socket&amp;quot; elif [[ -b $filename ]]; then echo &amp;quot;$filename is a block device&amp;quot; elif [[ -c $filename ]]; then echo &amp;quot;$filename is a character device&amp;quot; fi if [[ -L $filename ]]; then echo &amp;quot;$filename is a symbolic link (to any file type)&amp;quot; fi  对于符号链接，使用-L这些测试应用到目标上，当时坏链接的时候返回false。</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十七）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-27.html</link>
      <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-27.html</guid>
      <description>子树 创建、拉入和反向端口子树 创建子树 添加一个新的远端plugin指向组件的远端仓库：
git remote add plugin https://path.to/remotes/plugin.git  然后创建一个子树指定一个plugins/demo前缀的新目录。plugin是远端的名称，master是引用的子树仓库的master分支名。
git subtree add --prefix=plugins/demo plugin master  子树更新 pull拉取plugin中正常的提交：
git subtree pull --prefix=plugins/demo plugin master  反向端口子树更新  指定在超级项目中进行的要进行反向移植的提交：   git commit -am &amp;quot;new changes to be backported&amp;quot;   签出要合并的新分支，设置为跟踪子树存储库   git checkout -b backport plugin/master   Cherry-pick backports   git cherry-pick -x --strategy=subtree master   推送修改到远端的plugin   git push plugin backport:master  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十一)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-21.html</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-21.html</guid>
      <description>引号 变量和命令替换的双引号 变量的个替换只能够被用在双引号中。
calculation=&#39;2 * 3&#39; echo &amp;quot;$calculation&amp;quot; # prints 2 * 3 echo $calculation # prints 2, the list of files in the current directory, and 3 echo &amp;quot;$(($calculation))&amp;quot; # prints 6  在双引号之外，$var使用变量var的值，然后用空格分隔这个值的每一部分，并将每一部分解析为一个(通配符)模式。除非你需要这种方式，否则每次都把$var放到双引号里面&amp;quot;$var&amp;quot;。
这也适用于命令的方式，&amp;quot;$(mycommand)&amp;quot;输出mycommand的值。mycommand将会输出空格分隔之后的结果。
echo &amp;quot;$var&amp;quot; # good echo &amp;quot;$(mycommand)&amp;quot; # good another=$var # also works, assignment is implicitly double-quoted make -D THING=$var # BAD! This is not a bash assignment. make -D THING=&amp;quot;$var&amp;quot; # good make -D &amp;quot;THING=$var&amp;quot; # also good  命令替换有它自己的上下文环境。编写任意嵌套替换很容易，因为解析器将跟踪嵌套深度，而不是贪婪地搜索第一个“字符”。不过，StackOverflow语法高亮分析错误。例如：</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十六）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-26.html</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-26.html</guid>
      <description>暂存    参数 详情     show 线上暂存区中处于暂存状态的文件和原始父文件的不同，当没有时，显示最新的一个。   list 列出当前拥有的暂存内容。每一个列出的暂存有名称（stash@{0}是最新的，stash@{1}是上一个），暂存创建是处于的分支名称，暂存基于的提交的简单描述   pop 从暂存列表中删除一个暂存，并把修改应用到当前工作树状态内   apply 和pop类似，但是不会删除暂存列表中的新   clear 删除所有的暂存信息。注意这些状态都会被删除，并且无法修复   drop 从暂存列表删除一个暂存状态。当没有给出时，会删除最新的一个stash@{0}。否则是stash列表中指向stash@{}中的有效信息   create 创建一个stash（它是一个常规提交对象）并返回其对象名，而不将其存储在ref命名空间的任何位置。这对脚本很有用。它可能不是您想要使用的命令；请参见上面的“save”。   store 将通过git stash create创建的给定存储（这是一个悬空合并提交）存储在stash ref中，更新stash reflog。这对脚本很有用。它可能不是您想要使用的命令；请参见上面的“save”。    什么是暂存 当在一个项目上面做开发，你目前在一个特性分支上做修改做了一半，但是现在master分支出现了一个bug。你还没有准备好提交你的信息，但是你也不想丢掉你的修改。这个就到git stash出马的时候了。
运行git status查看你当前分支没有提交的修改：
(master) $ git status On branch master Your branch is up-to-date with &#39;origin/master&#39;. Changes not staged for commit: (use &amp;quot;git add &amp;lt;file&amp;gt;.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-20.html</link>
      <pubDate>Sat, 16 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-20.html</guid>
      <description>Here语法 here文档执行命令 ssh -p 21 example@example.com &amp;lt;&amp;lt;EOF echo &#39;printing pwd&#39; echo &amp;quot;\${pwd}&amp;quot; ls -a find &#39;*.txt&#39; EOF  $这里是被逃脱的，因为我们不想让这个变量在当前shell中解析。$(pwd)应该在远端的shell中执行。
另外一种方式：
ssh -p 21 example@example.com &amp;lt;&amp;lt;&#39;EOF&#39; echo &#39;printing pwd&#39; echo &amp;quot;$(pwd)&amp;quot; ls -a find &#39;*.txt&#39; EOF  注意：这个结束的EOF标识需要在一行的最开始（前面没有任何空格）。如果需要缩进的话，当你的hera语法是以&amp;lt;&amp;lt;-开头的话，可以使用tab。查看here文档的缩进和限制字符串来获取更多信息。
here缩进 你可以在here文档中使用tab来进行缩进操作，但是这个时候你就需要使用&amp;lt;&amp;lt;-来代替&amp;lt;&amp;lt;符号了：
$ cat &amp;lt;&amp;lt;- EOF This is some content indented with tabs `\t`. You cannot indent with spaces you __have__ to use tabs. Bash will remove empty space before these lines. __Note__: Be sure to replace spaces with tabs when copying this example.</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十五）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-25.html</link>
      <pubDate>Sat, 16 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-25.html</guid>
      <description>clone 浅克隆 克隆一个大项目（像已经有多年历史的项目）可能会花费很长的时间，或者因为需要传输太多的数据而出现问题。因此你不需要获取所有有效的历史，你可以使用一个浅克隆：
git clone [repo_url] --depth 1  上面的命令只会获取远端仓库的最新提交。
注意你可能无法在浅克隆仓库中解析merge提交。获取足够解析merge提交的提交数是个好的主意。例如，获取至少50个提交：
git clone [rrepo_url] --depth 50  之后如果需要的话，你可以fetch仓库其他的提交：
Version &amp;gt;= 1.8.3
git fetch --unshallow # equivalent of git fetch -–depth=2147483647 # fetches the rest of the repository  Version &amp;lt; 1.8.3
git fetch --depth=1000 # fetch the last 1000 commits  普通克隆 下载整个仓库包括所有的历史和所有的分支，输入：
git clone &amp;lt;url&amp;gt;  上面的例子将会把仓库的信息放到一个和仓库名称一致的目录内。
下载一个仓库，并且把仓库的信息放到指定的目录内：
git clone &amp;lt;url&amp;gt; [directory]  克隆指定分支 克隆一个仓库指定的分支，可以在仓库地址前面加上--branch选项：
git clone --branch &amp;lt;branch_name&amp;gt; &amp;lt;url&amp;gt; [directory]  也可以使用—branch选项的简写格式-b。这个命令会下载整个仓库，并且切换到&amp;lt;branch_name&amp;gt;分支。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十九)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-19.html</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-19.html</guid>
      <description>Source source一个文件和执行命令是不同的，因为所有的命令都是在当前bash会话的上下文环境中执行的—这就意味着所有的变量、函数或别名在整个会话中是保持不变的。
创建一个你想要source的文件sourcename.sh：
#!/bin/bash export A=&amp;quot;hello_world&amp;quot; alias sayHi=&amp;quot;echo Hi&amp;quot; sayHello() { echo Hello }  在你当前的bash会话中，source这个文件：
$ source sourcename.sh  从这时开始，在当前的会话中你拥有了被source文件内的所有变量：
$ echo $A hello_world $ sayHi Hi $ sayHello Hello  另外注意：.命令是source命令的简称，所以你可以简单的使用下面的命令：
. sourcename.sh  source虚拟环境 当在一个机器上面开发多个应用的时候，把不同的依赖分别放入不同的虚拟环境是很有用的。
通过使用virtualenv命令，这些环境变量被source到你的shell环境中。这样当你执行一个命令的时候，它是被运行在一个虚拟环境中。
下面是使用pip按照软件的常用方法：
pip install https://github.com/pypa/virtualenv/tarball/15.0.2  创建一个新的环境变量：
virtualenv --python=python3.5 my_env  激活这个环境：
source my_env/bin/activate  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十四）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-24.html</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-24.html</guid>
      <description>钩子 pre-push 在Git1.8.2及以上是有效的。
Version&amp;gt;=1.8
Pre-push钩子可以用来避免过度推送。这很有用，这是其中的一些原因：阻止意外的手动推送到指定分支，或者当遇到错误时阻止推送（单元检测，语法等）。
创建一个Pre-push钩子是很贱的，只需要在.git/hooks/目录下面创建一个名为pre-push的文件，（警戒），并且确保这个文件有执行的权限：chmod +x ./git/hooks/pre-push。
下面是Hannah Wolfe提供的一个阻止推送到master分支的钩子：
#!/bin/bash protected_branch=&#39;master&#39; current_branch=$(git symbolic -ref HEAD | sed -e &#39;s,.*/\(.*\),\1,&#39;) if [$protected_branch = $current_branch] then read -p &amp;quot;You&#39;re about to push master, is that what you intended? [y|n] &amp;quot; -n 1 -r &amp;lt; /dev/tty echo if echo $REPLY | grep -E &#39;^[Yy]$&#39; &amp;gt; /dev/null then exit 0 #push 将会执行 fi exit 1 #push 将不会执行 else exit 0 #push 执行 fi  下面是Volkan Unsal提供的要求在push之前需要确保通过了RSpec的测试的例子：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十八)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-18.html</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-18.html</guid>
      <description>Sort    Option meaning     -u 每行输出都唯一    sort是一个Unix命令，用来按顺序对文件中的数据进行排序。
命令输出 sort用来排序一列行。
输入一个文件 sort file.txt  排序另个命令的输出 你可以排序任何输出命令的输出。在下面的例子中，会排序一列符合条件的文件：
find * -name pattern | sort  输出唯一 如果想要输出的行保持唯一，可以使用-u选项。
输出目录中文件的所有者：
ls -l | awk &#39;{print $3}&#39; | sort -u  数字排序 假设我们有下面的文件：
$ cat file 10.Gryffindor 4.Hogwarts 2.Harry 3.Dumbledore 1.The sorting hat  想要按数字排序这些内容，使用-n选项：
sort -n file  这个命令会输出下面的内容：
1.The sorting hat 2.Harry 3.Dumbledore 4.Hogwarts 10.</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十三）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-23.html</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-23.html</guid>
      <description>Pull    Parameter Details     &amp;ndash;quiet 没有文本输出   -q —-quiet的短格式   &amp;ndash;verbose 详细文本输出。可以分别传给merge/rebase命令   -v —verbos的短格式   &amp;ndash;[no-]recurse-submodules[=yes|on-demand|no] 获取子模块的新提交？（注意这个不是pull/checkout）    不像push是把你本地的修改推到集中版本关联服务器，而是从代码仓库服务器获取服务器上当前的代码，并且把代码从远端服务器拉取到本地机器。本主题说明了使用Git从代码库中提取代码的过程，以及将不同代码提取到本地副本时可能遇到的情况。
获取修改到本地代码库 简单pull 当你和其他人在一个远端仓库（例如Github）协同工作时，某些时候你想和其他人分享你的修改。当他们已经把自己的修改推送到这个仓库时，你可以使用pull命令从这个仓库获取这些修改。
git pull  在大多数的情况下，这都会正常工作的。
从不同的远端或分支获取 你可以通过指定远端或分支的名字来从远端仓库获取这些修改：
git pull origin feature-A  将会从origin拉取分支feature-A的修改到本地分支。注意你可以直接使用远端url来代替远端名称，使用提交的SHA来代替分支名称。
手动pull 你可以使用git fetch和git merge模拟pull命令的行为：
git fetch origin # retrieve objects and update refs from origin git merge origin/feature-A # actually perform the merge  这给与你更多的控制器，允许你在合并分支之前检查分支的内容。实际上，在fetch代码之后，你可以使用git branch -a命令来查看远端的分支，然后切换到这个分支：</description>
    </item>
    
    <item>
      <title>访问本地服务</title>
      <link>http://blog.huaifufeng.com/2019/02/post/localhost.html</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/localhost.html</guid>
      <description>本地访问 我们在访问本地服务的时候，有的时候使用的是localhost，有的时候用的是127.0.0.1。这在大多数的情况下都是可以互换的，可以使用一种方法换另一种方法。但是在某些情况下localhost可以访问，但是127.0.0.1不可以访问。这说明两者还是有不同存在的。
127.0.0.1 这个地址一般是分配给loopback接口的，这是一种特殊的接口，用于本机应用的相互通信。只要本机的网络组件正常，这个接口就可以使用。实际上整个127.*的网段都是可以使用的，只不过127.0.0.1是默认的设置而已。ping 127.0.0.2也是可以访问的。
因为数据的传输通过网卡，所以受到网络防火墙和网卡设置的限制。这个在访问的过程中就涉及到网络用户权限的问题。
localhost localhost是一个域名，默认指向127.0.0.1。现在支持IPv6，同时也指向[::1]。
可以设置localhost指向的ip地址，一般是在操作系统的hosts文件中进行配置。在这个配置文件中，可以把不同的ip地址设置到localhost上面。
因为localhost的访问不走网卡，所以不收网络防火墙和网卡的限制。
访问这个地址也是使用本地用户权限去访问的。
其他 所以访问本地程序时，使用localhost比较好，不占用网卡和网络资源。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十七)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-17.html</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-17.html</guid>
      <description>Find find是一个用于在目录中递归搜索与条件匹配的文件（或目录）的命令，然后对所选文件执行某些操作。
find search_path selection_criteria action  按照文件名或扩展名搜索文件 使用指定的文件名在pwd指向的本地目录内搜索文件或目录：
$ find . -name &amp;quot;myFile.txt&amp;quot; ./myFile.txt  使用通配符查找有指定扩展名的文件或目录：
$ find . -name &amp;quot;*.txt&amp;quot; ./myFile.txt ./myFile2.txt  想要搜索包含多个扩展的文件或目录，使用or选项：
$ find . -name &amp;quot;*.txt&amp;quot; -o -name &amp;quot;*.sh&amp;quot;  想要搜索以abc开头，后面跟着一个字符，之后跟着一个数字使用下面的模式：
$ find . -name &amp;quot;abc[a-z][0-9]&amp;quot;  获取指定目录下所有的文件：
$ find /opt  只显示目录下面的文件，使用-type f：
$ find /opt -type f  只显示目录下面的目录，使用-type d:
$ find /opt -type d  对找到的文件执行命令 有时候我们需要在一批文件上面运行命令。这里就可以使用xargs命令。
find . -type d -print | xargs -r chmod 770  上面的命令将会在.</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十二）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-22.html</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-22.html</guid>
      <description>工作流的类型 集中工作流 使用这种基础工作流程，master分支包含所有进行中的开发分支。在继续开发前，贡献者需要特别确定他们能够获取最新的修改，因为这个分支会迅速变化。每个可以访问这个仓库的人都可以把提交修改到master分支上面。
这种模型的图形展示：
这是经典的版本控制范例，旧的版本管理系统Subversion和CVS就是基于这种模型。以这种方式工作的软件成为集中版本控制系统或者CVCS。虽然Git可以以这种方式工作，但是存在的名下的缺点，例如在每次拉取之前都要进行合并操作。团队可以按这种方式工作，但不断的合并解决冲突最终会占用大量的宝贵时间。
这就是为什么Linus Torvalds创建Git不是按照CVCS模式，而是DVCS（分布式版本控制系统），类似于Mercurial。这种模式的优点是本章其他示例展示的灵活性。
Gitflow工作流 最初由Vincent Driessen提出的，Gitflow是使用Git和几个预定义的分支的开发流程。这可以看做是特性分支工作流的一种特例。
这种想法是为开发中的特定部分保留在单独的分支上面：
 master分支一直包含最新的生产代码，实验性代码不能包含到这个分支上面。 develop包含所有最新的开发内容。这些最新的修改可以包含基本所有的内容，但是大的特性应该包含在自己的分支内。这里的代码在发布/部署之前要合并到release分支上面。 hotfix分支代表一些小的bug修复功能，这些修复功能等不到代码发布了。hotfix从master分支上切出来，并且要合并到master和develop分支上面。 release分支用来把最新的开发从develop分支发布到master分支上。任何最后一分钟的修改（像版本号冲突）都在release分支修改，然后合并到master和develop分支上。部署新版本时，master应标记当前版本号（例如，使用语义版本），以供将来参考和轻松回滚。 feature分支包含大的特性的修改。这些修改都在专门的分支中进行，开发结束之后合并到develop分支。专门的feature分支可以把开发工作分库，对于每个特性可以单独部署。  这种模型的图形展示：
这种模型的原始展现形式是：
特性分支工作流 特性分支工作流的核心思想是把所有的特性放到不同的分支中进行开发，而不是统统放到master分支。这种封装使得多个开发人员可以在不干扰主代码库的情况下轻松地完成特定功能的开发。这还意味着主分支永远不会包含损坏的代码，对于持续集成环境来说是一个巨大的优势。
封装特性开发可以利用pull request的优势，这也是围绕分支讨论的一种方法。这给了其他开发者在特性合并到主线之前进行确认的机会。或者，你可以在一个特性分支的开发中，你可以打开一个pull request来请求同时的建议。最关键的是，pull request使您的团队非常容易对彼此的工作进行评论。
基于Atlassian Tutorials。
Github工作流 这在很多开源项目中是很有名的，但不仅仅这样。特定位置的master分支（Github,Gitlab,BitBucket,本地服务器）包含最新的可发布版本。
对于每个新特性/错误修复/体系结构更改，每个开发人员都创建一个分支。所有的修改都在这个分支上进行，并且可以在pull request或code review中进行讨论。一旦这些修改都被接受了，可以合并到master主分支。
Scott Chacon提供的全部流程：
 master分支上的任何信息都是可以发布的 要处理新的功能，请从master创建一个描述性命名的分支（即：new-oauth2-scopes） 在本地提交该分支，并定期将您的工作推送到服务器上的同一个命名分支 当您需要反馈或帮助时，或者您认为分支已准备好进行合并时，请建立一个pull request。 在其他人查看并且接受了这个分支之后，你就可以把这个分支合并到master了。 一旦这个分支被合并到master并且push到远端的master分支，你应该立即把这个master分支发布。  Scott Chacon私人站点表述的原始流程：
图片由Github Flow reference提供。
Fork工作流 这种工作流和其他提到的工作流有着根本的不同。每个人都有一个他/她自己从主库fork的新库，而不是所有人使用一个集中主库。这样做的好处是开发人员可以将修改发布到自己的存储库而不是共享存储库，维护人员可以在适当的时候将其他人存储库中的更改集成到原始存储库中。
下面是这种工作流的一种图形展示：
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十六)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-16.html</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-16.html</guid>
      <description>复制    Option Description     -a,-archive 和选项d，p，r一起使用   -b,-backup 在删除之前，建立一个备份   -d,&amp;ndash;no-deference 保存连接   -f,&amp;ndash;force 在不提醒用户的情况下删除目标地址存在的文件   -i,&amp;ndash;interactive 在覆盖前进行提示   -l,&amp;ndash;link 不复制文件，而是使用文件连接   -p,&amp;ndash;preserve 尽可能保留文件的属性   -R,&amp;ndash;recursive 递归复制目录的文件    复制一个文件 把文件foo.txt从/path/to/source/复制到/path/to/target/folder/。
cp /path/to/source/foo.txt /path/to/target/folder/  把文件foo.txt从/path/to/source/复制到/path/to/target/folder/，并且修改文件名称为bar.txt。
cp /path/to/source/foo.txt /path/to/target/folder/bar.txt  复制目录 把目录foo复制到目录bar里面：
cp -r /path/to/foo /path/to/bar  如果目录bar在执行命令之前存在，目录foo和它的内容将会被复制到目录bar中。但是如果执行命令之前bar目录不存在的话，会创建目录bar，并且把目录foo的内容存放到bar中。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十一）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-21.html</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-21.html</guid>
      <description>.mailmap文件 按别名合并贡献者以在短日志中显示提交计数 当贡献者从不同的机器或操作系统添加到一个项目中时，他们可能会为此使用不同的电子邮件或名称，这将分割贡献者列表和统计信息。
git shortlog -sn命令可以获取贡献者的列表和他们各自的提交数量，具体的结果像下面这样：
Patrick Rothfuss 871 Elizabeth Moon 762 E. Moon 184 Rothfuss, Patrick 90  可以通过提供包含电子邮件映射的纯文本文件.mailmap来调整此碎片/解除关联。
一行中列出的所有名称和电子邮件地址将分别与第一个命名实体关联。
像上面的例子，一个map邮件像下面这样：
Patrick Rothfuss &amp;lt;fussy@kingkiller.com&amp;gt; Rothfuss, Patrick &amp;lt;fussy@kingkiller.com&amp;gt; Elizabeth Moon &amp;lt;emoon@marines.mil&amp;gt; E. Moon &amp;lt;emoon@scifi.org&amp;gt;  如果这个文件在项目的根目录，运行git shortlog -sn命令将会返回缩减之后的结果：
Patrick Rothfuss 961 Elizabeth Moon 946  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十五)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-15.html</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-15.html</guid>
      <description>bash参数扩展 $字符引入了参数扩展、命令替换或算术扩展。要扩展的参数名称或符号可以用大括号括起来，大括号是可选的，但可以将变量从紧跟在其后面的字符扩展中选取出来，不然这些字符可以被解释为名称的一部分。
查看更多。
修改字母字符的大小写 Version&amp;gt;=4.0
修改为大写字母：
$ v=&amp;quot;hello&amp;quot; # Just the first character $ printf &#39;%s\n&#39; &amp;quot;${v^}&amp;quot; Hello # All characters $ printf &#39;%s\n&#39; &amp;quot;${v^^}&amp;quot; HELLO # Alternative $ v=&amp;quot;hello world&amp;quot; $ declare -u string=&amp;quot;$v&amp;quot; $ echo &amp;quot;$string&amp;quot; HELLO WORLD  转换字符为小写：
$ v=&amp;quot;BYE&amp;quot; # Just the first character $ printf &#39;%s\n&#39; &amp;quot;${v,}&amp;quot; bYE # All characters $ printf &#39;%s\n&#39; &amp;quot;${v,,}&amp;quot; bye # Alternative $ v=&amp;quot;HELLO WORLD&amp;quot; $ declare -l string=&amp;quot;$v&amp;quot; $ echo &amp;quot;$string&amp;quot; hello world  大写修改为小写，小写修改为大写：</description>
    </item>
    
    <item>
      <title>Git专业笔记（二十）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-20.html</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-20.html</guid>
      <description>.gitattributes文件 自动行结束符标准化 在项目的更目录创建.gitattributes文件，里面添加下面的内容：
* text=auto  这将导致所有文本文件（由Git标识的）使用LF提交，但根据操作系统的不同默认检出合适的格式。
这等价于core.autocrlf配置项使用下面的配置：
 Linux/macOS里面是input Windows里面是true  识别二进制文件 Git非常擅长识别二进制文件，但是你可以指明哪些文件时二进制的。在项目的根目录创建.gitattributes文件，并添加下面的配置：
*.png binary  binary是内建的宏命令，等价于-diff -merge -text。
.gitattributes模板 如果你确定你的.gitattributes文件是否少了某些规则，或者你只是想给你的项目添加一个通用的配置，你可以在下面的地址中选择或生成一个.gitattributes文件：
 https://gitattributes.io/ https://github.com/alexkaratarakis/gitattributes  进制行结束符标准化 在项目的根目录创建.gitattributes文件，并在里面添加：
* -text  这个配置等价于下面的配置core.autocrlf = false。
参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十四)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-14.html</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-14.html</guid>
      <description>函数 带参数函数 在helloJohn.sh文件里面有下面的代码：
#!/bin/bash greet() { local name=&amp;quot;$1&amp;quot; echo &amp;quot;Hello, $name&amp;quot; } greet &amp;quot;John Doe&amp;quot;  执行这个文件：
$ bash helloJohn.sh Hello, John Doe   如果你没有修改参数，可以不用把这个参数放到本地变量中，可以直接使用`echo &amp;ldquo;Hello, $1&amp;rdquo;
 你可以在函数中使用$1，$2，$3等等的变量访问函数的参数。
   注意：对于超过9个的参数，使用$10是没有用的，因为这将被解析成为$10，所以你需要使用${10}、${11}这样的变量。
  在函数中，$@引用所有的参数：   #!/bin/bash foo() { echo &amp;quot;$@&amp;quot; } foo 1 2 3 # output =&amp;gt; 1 2 3   注意：你应该像这里展示的一样，在$@周围使用双引号。
 省略引号将导致shell扩展通配符（即使用户为避免这种情况而专门引用通配符），并且通常会引入不受欢迎的行为，甚至潜在的安全问题。
 foo &amp;quot;string with spaces;&amp;quot; &#39;$HOME&#39; &amp;quot;*&amp;quot; # output =&amp;gt; string with spaces; $HOME *   想要使用默认值的话，用${1:-default_val}的格式：   #!</description>
    </item>
    
    <item>
      <title>Git专业笔记（十九）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-19.html</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-19.html</guid>
      <description>Git清理    Parameter Details     -d 除了未追踪的文件外，删除未追踪的文件夹。如果未追踪的文件夹由不同的Git仓库管理，默认是不删除的。如果你一定要删除，使用两次-f选项。   -f,&amp;ndash;force 如果Git的配置clean. requireForce配置为false，Git将不会删除任何文件或目录，除了提供-f，-n或-i选项。除非给出第二个-f，否则Git将拒绝删除有.git子目录的目录或文件。   -i,&amp;ndash;interactive 交互式操作删除每个文件   -n,&amp;ndash;dry-run 只显示将要被删除的文件列表，而不实际删除这些内容   -q,&amp;ndash;quiet 只显示删除出错的文件，不显示成功的文件    交互式清理 git clean -i  打印出将要被清理的文件，使用下面的命令进行确认：
Would remove the following items: folder/file1.py folder/file2.py *** Commands *** 1: clean 2: filter by pattern 3: select by numbers 4: ask each 5: quit 6: help What now&amp;gt;  交互式选项-i可以和其他的选项-X，-d一起添加。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十三)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-13.html</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-13.html</guid>
      <description>关联数组 操作关联数组 以下代码段显示了所有需要的用法：
#!/usr/bin/env bash declare -A assoc_array=([key_string]=value \ [one]=&amp;quot;something&amp;quot; \ [two]=&amp;quot;another thing&amp;quot; \ [ three ]=&#39;mind the blanks!&#39; \ [ &amp;quot; four&amp;quot; ]=&#39;count the blanks of this key later!&#39; \ [IMPORTANT]=&#39;SPACES DO ADD UP!!!&#39; \ [1]=&#39;there are no integers!&#39; \ [info]=&amp;quot;to avoid history expansion &amp;quot; \ [info2]=&amp;quot;quote exclamation mark with single quotes&amp;quot; \ ) echo # just a blank line echo now here are the values of assoc_array: echo ${assoc_array[@]} echo not that useful, echo # just a blank line echo this is better: declare -p assoc_array # -p == print echo have a close look at the spaces above\!</description>
    </item>
    
    <item>
      <title>Git专业笔记（十八）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-18.html</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-18.html</guid>
      <description>恢复 恢复reset操作 使用Git，你总是（几乎）可以把时钟倒转。
不要害怕尝试重写历史的命令。Git默认不会删除你90天内的提交，在此期间你可以使用reflog轻松的恢复这些修改：
$ git reset @~3 # go back 3 commits $ git reflog c4f708b HEAD@{0}: reset: moving to @~3 2c52489 HEAD@{1}: commit: more changes 4a5246d HEAD@{2}: commit: make important changes e8571e4 HEAD@{3}: commit: make some changes ... earlier commits ... $ git reset 2c52489 ... and you&#39;re back where you started  *注意像--hard和—force这样的选项：他们会丢弃修改
*另外，避免在协助的分支上面修改提交历史。
恢复stash 获取你在执行git stash命令之后你最新的暂存修改，使用下面命令：
git stash apply  查看你暂存的信息列表：
git stash list  你可以获取像下面这样的修改：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十二)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-12.html</link>
      <pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-12.html</guid>
      <description>数组 数组赋值 列表赋值 如果你熟悉Perl，C或者Java的话，你可能会认为Bash使用逗号来分隔数组的元素，然而不是这样的，Bash使用空格来分隔元素：
# Perl中的数组 my @array = (1, 2, 3, 4); #Bash中的数组 array=(1 2 3 4)  使用新元素创建数组：
array=(&#39;first element&#39; &#39;second element&#39; &#39;third element&#39;)  下标赋值 使用明确的元素索引创建一个数组：
array=([3]=&#39;fourth element&#39; [4]=&#39;fifth element&#39;)  索引赋值 array[0]=&#39;first element&#39; array[1]=&#39;second element&#39;  关联数组 Version&amp;gt;= 4.0
decalare -A array array[first]=&#39;First element&#39; array[second]=&#39;Second elemet&#39;  动态赋值 从其他命令的输出结果创建一个数组，例如使用seq获取1到10的值：
array=(`seq 1 10`)  从脚本的输入参数赋值给数组：
array=(&amp;quot;$@&amp;quot;)  使用循环赋值：
while read -r; do #array+=(&amp;quot;$REPLY&amp;quot;) #数组追加 array[$i]=&amp;quot;$REPLY&amp;quot; #索引赋值 let i++ #索引增加 done &amp;lt; &amp;lt;(seq 1 10) #?</description>
    </item>
    
    <item>
      <title>Git专业笔记（十七）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-17.html</link>
      <pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-17.html</guid>
      <description>随意选取    Parameter Details     -e,&amp;ndash;edit 选择这个选项，使用git cherry-pick命令允许你在提交信息之前编辑提交信息   -x 记录提交时，在原始提交消息中附加一行（cherry picked from commit&amp;hellip;），以指示从哪个提交中挑选出这个更改。这个只适用于没有冲突的选取。   &amp;ndash;ff 如果当前的HEAD和cherry的提交的父提交同级，将会执行此提交的快进。   &amp;ndash;continue 使用.git/sequencer里面的信息继续进行当前的操作。可以在解决失败的挑选或恢复中的冲突后继续使用   &amp;ndash;quit 忘记当前的操作。在选取或恢复失败后，可以用来清除sequencer的信息   &amp;ndash;abort 取消当前操作，恢复之前的状态    一个随意选取获取提交中引入的补丁，并尝试在您当前所在的分支上重新应用它。
Source：Git SCM Book
从一个分支复制提交到另一个分支 git cherry-pick &amp;lt;commit-hash&amp;gt;会应用另一个分支上的已经存在的提交修改，将会记录一个新的修改。实际上，你可以把提交从分支复制到另一个分支。
已经有下面的提交树(source)：
dd2e86 - 946992 - 9143a9 - a6fd86 - 5a6057 [master] \ 76cada - 62ecb3 - b886a0 [feature]  我们想把b886a0这个分支的修改复制到master上（5a6057之上）：
我们使用下面的命令：
 git checkout master git cherry-pick b886a0  下面我们的提交树就变成下面这样：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十一)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-11.html</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-11.html</guid>
      <description>true，false和：命令 无限循环 while true; do echo ok done  或者
while :; do echo ok done  或者
until false; do echo ok done  函数返回 function positive() { return 0 } function negative() { return 1 }  一直或从不执行的代码 if true; then echo Always executed fi if false; then echo Never executed fi  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（十六）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-16.html</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-16.html</guid>
      <description>压缩 不使用rebase压缩提交 如果你想把之前的x个提交压缩到一个提交，你可以使用下面的命令：
$ git reset --soft HEAD~x $ git commit  这里，你可以替换x为你想要压缩到一个提交的多个提交的数量。
请记住这将会创建一个新的提交，基本上会丢掉之前x个提交包含的提交人，提交信息和提交日期。你可能需要首先复制粘贴现有的提交消息。
merge时压缩提交 你可以使用git merge —squash命令把这个分支的修改压缩到一个提交。并不是实际的提交被创建了。
 git merge --squash &amp;lt;branch&amp;gt; git commit  这或多或少相当于使用git reset命令，但当合并更改具有符号名时更方便。比较：
git checkout &amp;lt;branch&amp;gt; git reset --soft $(git merge-base master &amp;lt;branch&amp;gt;) git commit  rebase时压缩提交 在git rebase命令执行的时候可以压缩多个提交。建议您在尝试以这种方式压缩提交之前了解rebase命令。
 确定要从哪个提交中rebase，并注意其提交的hash值。
 执行git rebase -i [commit hash]
  或者，你可以使用HEAD~4来代替提交的hash值，来查看最新的提交和最新之前4个提交
 在运行这个命令打开的编辑器中，选择哪些提交你想要合并。替换这些行之前的pick为squash来吧这些提交压缩的签名的提交中。
 在选择了压缩的提交之后，你需要编辑提交的信息
  查看提交并且决定哪些提交要rebase:
&amp;gt; git log --oneline 612f2f7 This commit should not be squashed d84b05d This commit should be squashed ac60234 Yet another commit 36d15de Rebase from here 17692d1 Did some more stuff e647334 Another Commit 2e30df6 Initial commit &amp;gt; git rebase -i 36d15de  这时你选择的编辑器就会打开，在这里你可以描述你想要这些提交做什么。Git在注释中提供了帮助信息。如果你退出了这个编辑器，什么都不会发生，因为每个提交都会保持和之前一样的顺序。在这个例子中，我们应用下面的命令：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-10.html</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-10.html</guid>
      <description>控制结构    Parameter to [ or test Details     File Operators Details   -e &amp;ldquo;$file&amp;rdquo; 如果文件存在，返回true   -d &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个目录的话，返回true   -f &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个普通文件的话，返回true   -h &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个符号链接的话，返回true   String Comparators Details   -z &amp;ldquo;$str&amp;rdquo; 字符串长度为0时为true   -n &amp;ldquo;$str&amp;rdquo; 字符串长度不为0时为true   &amp;rdquo;$str&amp;rdquo; = &amp;ldquo;$str2&amp;rdquo; 如果字符串$str等于字符串$str2。对整数是不合适的，虽然可以工作，但是结果可能不符合预期。   &amp;rdquo;$str&amp;rdquo; != &amp;ldquo;$str2&amp;rdquo; 如果字符串$str不等于$str2时返回true   Integer Comparators Details   &amp;rdquo;$int1&amp;rdquo; -eq &amp;ldquo;$int2&amp;rdquo; 如果整数相等返回true   &amp;rdquo;$int1&amp;rdquo; -ne &amp;ldquo;$int2&amp;rdquo; 如果整数不相等返回true   &amp;rdquo;$int1&amp;rdquo; -gt &amp;ldquo;$int2&amp;rdquo; 如果整数$int1大于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -ge &amp;ldquo;$int2&amp;rdquo; 如果整数$int1大于等于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -lt &amp;ldquo;$int2&amp;rdquo; 如果整数$int1小于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -le &amp;ldquo;$int2&amp;rdquo; 如果整数$int1小于等于$int2返回true    命令列表的条件执行 如何使用命令列表的条件执行 任何内建的命令、表达式或函数，以及外部的命令或脚本都可以使用&amp;amp;&amp;amp;或||运算符有条件的执行。</description>
    </item>
    
    <item>
      <title>Git专业笔记（十五）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-15.html</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-15.html</guid>
      <description>Rev-List    Parameter Detals     &amp;ndash;online 将提交显示为带有标题的单行。    列出在master不在远端master提交 git rev-list --oneline master ^origin/master  git rev-list命令会列出在一个分支不在另一个分支的提交。当您试图弄清楚代码是否已合并到分支中时，它是一个很好的工具。
 使用--oneline选项显示每个提交的标题 ^操作符会在列表中过滤指定的分支 如果需要，可以传递两个以上的分支。git rev-list foo bar ^baz将会列出foo和bar的提交，不包括baz。  参考：Git® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(九)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-9.html</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-9.html</guid>
      <description>重定向    Parameter Details     内部文件标识 整形   重定向 &amp;gt;或&amp;lt;或&amp;lt;&amp;gt;   外部文件标识或路径 文件标识或路径后面加&amp;amp;    重定向标准输出 &amp;gt;重定向当前命令的标准输出（STDOUT）到一个文件或者另外的描述符。
下面的例子会把ls命令的标准输出，输出到一个文件file.txt：
$ ls &amp;gt;file.txt $ &amp;gt; file.txt ls  如果目标文件不存在的话，就会创建这个文件，否则就会重置这个文件。
默认的文件标识符是标准输出，或者没有提供的话就是1。下面的命令和之前的一样，只是指定了标准输出：
$ ls 1&amp;gt;file.txt  注意：重定向是执行的shell初始化的，而不是由执行的命令初始化的，因此在命令执行前，初始化工作就已经完成了。
追加 Vs 重置 重置 &amp;gt;  文件不存在创建指定文件 重置（删除文件内容） 向文件写入内容  $ echo &amp;quot;first line&amp;quot; &amp;gt; /tmp/lines $ echo &amp;quot;second line&amp;quot; &amp;gt; /tmp/lines $ cat /tmp/lines second line  追加 &amp;gt;&amp;gt;  不存在创建文件 追加文件（向文件末尾写入内容）  # Overwrite existing file $ echo &amp;quot;first line&amp;quot; &amp;gt; /tmp/lines # Append a second line $ echo &amp;quot;second line&amp;quot; &amp;gt;&amp;gt; /tmp/lines $ cat /tmp/lines first line second line  重定向到STDOUT和STDERR 文件标识符0和1是指针。我们通过重定向更改文件描述符指向的内容。&amp;gt;/dev/null意味着1指向/dev/null。</description>
    </item>
    
    <item>
      <title>Git专业笔记（十四）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-14.html</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-14.html</guid>
      <description>分支    Parameter Detals     -d,&amp;ndash;delete 删除分支。这个分支必须合并到它的远端分支，如果设置了--track或--set-upstream的话，就需要在HEAD中   -D --delete --force强制删除的简称   -m,&amp;ndash;move 移动/重命名分支和相应的reflog   -M --move —force命令的简称   -r,&amp;ndash;remotes 列出或删除（使用-d）远端追踪的分支   -a,&amp;ndash;all 列出远端追踪分支和本地分支   &amp;ndash;list 激活列表模式。git branch &amp;lt;pattern&amp;gt;会试着新建分支。git branch -- list &amp;lt;pattern&amp;gt;列出所有匹配的分支   &amp;ndash;set-upstream 如果指定的分支不存在或者指定了--force参数，行为会和--track一样。否则在创建分支时设置像--track那样的配置，除了分支指向的地方没有改变    创建和切换新分支 创建一个新分支，并且保留在当前分支，执行下面的命令：
$ git branch &amp;lt;name&amp;gt;  通常，分支名称不得包含空格，并且符合列出的这里列出的其他规范。切换到已经存在的分支：
$ git checkout &amp;lt;name&amp;gt;  创建并且切换到新分支：
$ git checkout -b &amp;lt;name&amp;gt;  在指定索引创建一个分支，而不是在当前分支的最后提交（就是HEAD），可以使用下面任何一个命令：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(八)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-8.html</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-8.html</guid>
      <description>任务和进程 任务处理 创建任务 要创建一个任务，可以在命令后面添加&amp;amp;符号：
$ sleep 10 &amp;amp; [1] 20024  你也可以创建一个运行任务进程，可以按下Ctrl+z：
前后台进程 想要把一个后台进程获取到前台执行，可以使用fg命令加上%和进程数：
$ sleep 10 &amp;amp; [1] 20024 $ fg %1 sleep 10  现在你可以控制流程，想要把进程放回到后台运行的话，使用bg命令。因为终端的缓存，你需要使用Ctrl+z来终端进行。
$ sleep 10 ^Z [1]+ Stopped sleep 10 $ bg %1 [1]+ sleep 10 &amp;amp;  因为程序员的&amp;rdquo;惰性&amp;rdquo;，当只有一个进程或者想要处理列表中第一个进程，可以只适使用一个%。
$ sleep 10 &amp;amp; [1] 20024 $ fg % # to bring a process to foreground &#39;fg %&#39; is also working. sleep 10  或者：</description>
    </item>
    
    <item>
      <title>Git专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</guid>
      <description>配置    Parameter Detals     &amp;ndash;system 编辑为每个人使用的系统配置（在linux上，配置文件在$(prefix)/etc/gitconfig）   &amp;ndash;global 修改为你的每个仓库使用的全局配置文件（在linux上，配置文件在~/.gitconfig）   &amp;ndash;local 编辑指定仓库的配置文件，在你仓库的.git/config这个文件内，这个是默认的配置    配置编辑器 有多个方式来配置你commit和rebase的时候使用的编辑器：
 修改core.editor配置项：   $ git config --global core.editor nano   设置GIT_EDITOR环境变量：  举个例子，应用到一个命令：
 $ GIT_EDITOR=nano git commit  或者为终端执行的所有git命令。注意：直到你关闭了终端，这个配置才会生效：
 $ export GIT_EDITOR=nano   想要修改终端所有程序的编辑器，不仅仅是git，可以VISUAL或EDITOR环境变量（可以查看VISUAL vs EDITOR）:   $ export EDITOR=nano  注意：像上面一样，这个命令只会应用到当前的终端页面。你的shell通常会有一个配置文件，允许你永远的设置你的配置。（比如在bash时，可以添加上面的配置到~/.bashrc获取~/.bash_profile配置文件）。
一些文本编辑器（主要是GUI编辑器）一次只运行一个实例，如果你已经打开了一个实例，通常会退出。如果您的文本编辑器就是这种情况，Git将打印Aborting commit due to empty commit message。不允许你先编辑你的提交信息。如果你遇到了这种情况，检查你的编辑器文档是否有--wait这个配置项。允许你在文档关闭之前终端提交。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(七)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-7.html</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-7.html</guid>
      <description>别名 shell的别名是一种创建新命令或者在已有命令添加自己代码的方式。这和shell的函数有重叠的地方，但是shell函数更加通用，最好优先使用。
绕过别名 有时候你想临时绕过一个别名，而不是让别名不能使用了。下面就是一个例子：
alias ls=&#39;ls --color=auto&#39;  如果我们想要使用ls命令而不是ls别名，有下面几种方法：
 使用内建的command命令：command ls 使用命令的完整路径：/bin/ls 在命令名的任何地方添加一个\：\ls或l\s 把命令引用起来：&amp;rdquo;ls&amp;rdquo;或&amp;rsquo;ls&amp;rsquo;  创建别名 alias word=&#39;command&#39;  使用word就是运行命令command。任何追加到别名后面的参数就会添加到命令后面：
 alias myAlias=&#39;some command --with --options&#39; myAlias foo bar baz  上面的别名将会执行下面的命令：
some command --with --options foo bar baz  想要在一行中执行多个命令，可以使用&amp;amp;&amp;amp;连接多个命令字符串。李润：
alias print_things=&#39;echo &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;bar&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;baz&amp;quot;&#39;  删除别名 删除别名使用下面的命令：
unalias {alias_name}  例如：
# create an alias $ alias now=&#39;date&#39; # preview the alias $ now Thu Jul 21 17:11:25 CEST 2016 # remove the alias $ unalias now # test if removed $ now -bash: now: command not found  BASH_ALIASES 别名是一些命令的快捷方式，可以在交互式bash实例中定义和使用。这些别名被保存在一个名字文件BASH_ALIASES的关联数组文件。想要在脚本中使用这些别名的话，必须在交互式的shell中：</description>
    </item>
    
    <item>
      <title>Git专业笔记（十二）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-12.html</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-12.html</guid>
      <description>rebase    Parameter Detals     &amp;ndash;continue 在解决完merge冲突之后，重新开始执行rebase命令   &amp;ndash;abort 中断rebase操作之后，重新吧HEAD定位到原有分支上。如果在使用rebase命令的时候提供了分支名，HEAD将会被设置到这个分支上。否则HEAD将会重新设置到rebase操作开始的位置。   &amp;ndash;keep-empty 保留那些没有修改的提交   &amp;ndash;skip 重新开始rebase命令，忽略掉当前的补丁   -m,&amp;ndash;merge 在rebase的时候使用megre策略。当使用递归(默认)合并策略的话，这允许rebase知道上游的重命名。注意rebase合并的工作方式是从上游分支顶部的工作分支重放每个提交。因此，当合并冲突发生时，报告为我们的一方是迄今为止重新定位的系列，从上游开始，他们是工作分支。换句话说，双方交换。   &amp;ndash;stat 显示上次rebase之后，上游做的修改。这些不同将会有rebase.stat配置项控制   -x, &amp;ndash;exec command 执行交互式rebase，在每个提交和执行command之间暂停    本地分支rebase rebase在另外提交的顶部应用一系列的提交。rebase一个分支的话，首先切换到这个分支，然后rebase到另一个分支的顶部：
$ git checkout topic $ git rebase master  这会导致：
	A---B---C topic / D---E---F---G master  变成：
 A&#39;--B&#39;--C&#39; topic / D---E---F---G master  这些操作可以合并到一个简单命令上面：切换分支然后执行rebase命令</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-6.html</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-6.html</guid>
      <description>grep 找bar文件中的foo字符：
$ grep foo ~/Desktop/bar  寻找bar文件中不包含foo字符的其他字符串：
$ grep –v foo ~/Desktop/bar  显示所有以foo结尾的字符串：
$ grep &amp;quot;*foo&amp;quot; ~/Desktop/bar  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Git专业笔记（十一）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-11.html</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-11.html</guid>
      <description>别名 简单别名 有两种方法来创建Git别名：
 编辑~/.gitconfig文件：   [alias] ci = commit st = status co = checkout   使用命令行：   git config --global alias.ci &amp;quot;commit&amp;quot; git config --global alias.st &amp;quot;status&amp;quot; git config --global alias.co &amp;quot;checkout&amp;quot;  在别名创建之后：
 git ci就是git commit git st就是git status git co就是git checkout  像正常的命令一样，别名也可以使用参数，例如：
 git ci -m &amp;quot;Commit message...&amp;quot; git co -b feature-42  显示搜索别名 你可以使用--get-regexp选项来列出所有的别名：
$ git config --get-regexp &#39;^alias\.&#39;  搜索别名 想要搜索别名的话，在.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-5.html</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-5.html</guid>
      <description>cat    Option Description     -n 输出行号   -v 使用^和M-代替不能打印的字符，除了LFD和TAB   -T 使用^I代替TAB   -E 使用$代替换行符(LF)   -e 和-vE一个含义   -b 输出非空行行号，覆盖-n   -A 等价于-vET   -s 抑制重复输出空行    拼接文件 这是cat命令的主要作用：
$ cat file1 file2 file3 &amp;gt; file_all  cat命令也用来把拼接文件的结果作为管道的一部分：
$ cat file1 file2 file3 | grep foo  输出文件内容 $ cat file.txt  将会输出文件的所有内容。</description>
    </item>
    
    <item>
      <title>Git专业笔记（十）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-10.html</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-10.html</guid>
      <description>提交    参数 详情     &amp;ndash;message, -m 包含在提交中的信息。这将会打开一个编辑器   &amp;ndash;amend 指定这个参数将会把当前暂存区的信息添加到之前的提交内。请注意，这将会修改之前的提交历史   &amp;ndash;no-edit 使用选择的提交信息但是不打开编辑器，例如：git commit --amend --no-edit追加提交到之前的提交上，并且不修改提交信息。   &amp;ndash;all, -a 提交包括未暂存的文件在内的修改   &amp;ndash;date 手动设置关联到这个提交的日期信息   &amp;ndash;only 只提交指定路径的信息。这将只会提交指定的文件   &amp;ndash;patch,-p 使用交互的补丁选择窗口来选择提交哪些修改   -S[keyid], -S &amp;ndash;gpg- sign[=keyid], -S &amp;ndash;no-gpg-sign Sign commit, GPG-sign commit, 取消 commit.gpgSign 配置变量   -n,&amp;ndash;no-verify 这个参数取消执行预提交和提交信息的钩子。详情看钩子    暂存提交修改 基础 在你修改了你的本地文件之后，在你准备提交这些修改之前，需要把文件暂存起来。
例如，如果你修改README.md和program.py这两文件：
$ git add README.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-4.html</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-4.html</guid>
      <description>文件列表    Option Description     -a, &amp;ndash;all 列出所有文件，包含.开头的文件   -A, &amp;ndash;almost-all 列出所有文件，处理.和..   -c 按修改时间排序文件   -d, &amp;ndash;directory 列出所有的目录   -h, &amp;ndash;human-readable 使用人可读的单位列出文件的大小（K, M等）   -H 和上面的参数一样，只是使用1000来代替1024   -l 显示文件的详细信息   -o 显示详细信息处理分组信息   -r, &amp;ndash;reverse 倒序显示文件内容   -s, &amp;ndash;size 显示文件的块大小   -S 以文件大小排序   &amp;ndash;sort=WORD 按照某个词排序（size，version，status等）。ps：mac没有这个选项   -t 按照修改时间排序   -u 按照访问时间排序   -v 按照版本排序   -1 每行返回一个文件    列出文件详情 ls命令的-l参数，打印文件长列表格式的详细信息。如果没有指定文件夹，默认列出当前文件夹的内容。</description>
    </item>
    
    <item>
      <title>Git专业笔记（九）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-9.html</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-9.html</guid>
      <description>submodule clone一个有子模块的仓库 当你克隆了一个有子模块的仓库时，你需要初始化和更新他们：
$ git clone --recursive https://github.com/username/repo.git  这将会克隆关联的子模块，并且把子模块放到合适的位置上面（包括子模块关联的子模块）。这个命令等价于在仓库克隆之后立即执行git submodule update --init --recursive这个命令。
更新子模块 如果一个子模块引用了另一个仓库中的子模块的特定提交。想要切换到所有引用子模块的特定状态的话，可以使用下面的命令：
$ git submodule update --recursive  有时候为了替换引用子模块当前的状态，你想要把本地米宽的分支切换到远端的最新状态。使用下面的命令可以把所有引用的子模块切换到远端最新的分支：
$ git submodule foreach git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;  或者使用默认的git pull参数：
$ git submodule foreach git pull  注意：这将只会更新本地工作区副本。如果一个子模块用这个命令更新了，他将会出现在git status命令的文件列表内。如果你想要把你的引用更新到最新的状态，你可以提交这些修改：
 git add &amp;lt;submodule_directory&amp;gt; git commit  如果你使用git pull的话，这写修改可能会造成合并冲突。你可以使用git pull —rebase来把修改到会到最新。大多数情况下这会减少出现冲突的次数。这也会把所有的分支pull到本地：
$ git submodule foreach git pull --rebase  想要把某个分支切换到最新的状态，可以使用：
$ git submodule update --remote &amp;lt;submodule_directory&amp;gt;  添加子模块 你可以把另外的Git仓库当做你自己项目的一个文件夹，使用Git来追踪：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-3.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-3.html</guid>
      <description>导航目录 绝对目录和相对目录 想要切换到一个绝对路径的目录，可以使用/开头的完整目录名称：
$ cd /home/username/project/abc  如果你想到达的目录在这个目录的下级目录，可以使用一个相对路径。例如，你当前在/home/username/project目录，如果想要到这个目录的abc子目录：
$ cd abc  如果你想到当前目录的上级目录，可以使用..符号。比如，如果你当前在/home/username/project/abc这个目录，现在想要到/home/username/project这个目录，可以使用下面的命令：
$ cd ..  这也可以称作“向上”目录。
到之前目录 在当前的shell中，你可以到你之前在的目录，而不用管这个目录在哪：
$ cd -  如果多次执行这个目录，你将会在当前目录和之前的目录之间切换。
home目录 默认的目录是home目录（$HOME，特别是/home/username），所以当没有带目录参数的执行cd命令的时候，将会直接到home目录：
$ cd  或者你可以更加明确的执行：
$ cd $HOME  home目录的简单符合是~，所以也可以这样执行：
$ cd ~  脚本目录 通常，有两种bash脚本：
 在当前目录执行的系统工具。 相对于自己目录修改文件的项目工具。  对第二中脚本来说，到的脚本所在的目录是非常有用的。这可以使用下面的命令：
$ cd &amp;quot;$(dirname &amp;quot;$(readlink -f &amp;quot;$0&amp;quot;)&amp;quot;)&amp;quot;  这个命令运行了3个命令：
 readlink -f &amp;quot;$0&amp;quot;获取当前脚本的目录。 dirname获取脚本的目录。 cd修改当前的目录到dirname返回的目录。  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-2.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-2.html</guid>
      <description>脚本shebang 环境shebang 想要使用bash命令执行一个脚本文件，可以使用可以执行的env来指定PATH环境变量中的bash命令。脚本文件的第一行需要是：带有bash参数的绝对路径的env可执行文件：
#!/usr/bin/env bash  只有在使用下面这样的方式执行脚本的时候，shebang里面的env命令才会被解析：
script.sh  当然，这个脚本必须有执行权限。
当直接指明bash解析器来执行脚本的时候，这个shebang是被忽略的：
bash script.sh  直接shebang 想要用bash来执行一个脚本，也可以定义一个可以执行的bash路径：
#!/bin/bash  当直接执行脚本的时候，shebang将会被解析并执行：
./script.sh  脚本需要可以执行的权限。
当bash解析器直接指明来执行这个脚本的时候，这个shebang不会被执行：
bash script.sh  其他的shebang 操作系统内核能识别的有两种程序：一种是用ELF (ExtenableLoadableFormat)头声明的二进制程序，通常是编译生成的；另一种就是各种的脚本。
如果一个文件的第一行以#!开头，下一个字符串必须是一个解析器的路径。如果操作系统内核读到了这行，会调用路径指向的解析器，然后把后面的字符都传给这个解析器作为参数。如果没有文件焦作something或者wrong：
#!/bin/bash something wrong echo &amp;quot;This line never gets printed&amp;quot;  bash执行的时候，参数something wrong是不存在的。脚本文件的名称也会被添加。下面看下直接声明echo命令的shebang：
#&amp;quot;/bin/echo something wrong # and now call this script named &amp;quot;thisscript&amp;quot; like so: # thisscript one two # the output will be: something wrong ./thisscript one two  一些想awk的程序就用这种技术来运行长时间留在硬盘上的脚本。</description>
    </item>
    
    <item>
      <title>Git专业笔记（八）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-8.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-8.html</guid>
      <description>merge    parameter Details     -m 在merge提交里使用的信息   -v 显示详细的输出   &amp;ndash;abort 中断把文件恢复到之前的状态   &amp;ndash;ff-only 当一个merge提交被要求的话立即中断   &amp;ndash;no-ff 强制创建一个merge提交，即使它不是强制的   &amp;ndash;no-commit 假装merge失败了，允许去检查和调整这个结果   &amp;ndash;stat merge合并之后，展示状态的不同   -n/&amp;ndash;no-stat 不显示状态的不同   &amp;ndash;sqaush 允许对这个分支的merge修改做一个单独的提交    自动合并 当两个分支的提交不冲突的话，Git可以自动的合并他们：
~/Stack Overflow(branch:master) » git merge another_branch Auto-merging file_a Merge made by the &#39;recursive&#39; strategy. file_a | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)  找到没有merge提交的分支 有时候你有一些已经把修改merge到master上的分支。这将找出来所有不是master分支并且和master分支没有区别提交的分支。这用来查找在PR合并到master之后，没有删除的分支非常有帮助：</description>
    </item>
    
    <item>
      <title>Git专业笔记（七）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-7.html</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-7.html</guid>
      <description>撤销修改 返回前一个提交 返回前一个提交，首先使用git log找到前一个提交的hash值。然后要临时返回那个提交的话，使用下面的命令：
$ git checkout 789abcd  这将返回hash值为789abcd的提交。现在你可以在不影响你的HEAD的情况下，在这个老提交的基础上建立新的提交。你可以使用branch或checkout -b命令来建立一个分支，然后把这些修改放到这个分支上面。
使用下面的命令返回上一个提交的话，会保留之前的修改：
$ git reset --soft 789abcd  去返回上一个提交，可以使用下面的命令：
$ git reset --soft HEAD~  想要抛弃某个提交之后的修改，可以使用下面的命令：
$ git reset --hard 789abcd  想要抛弃上一个提交之后的修改，使用下面的命令：
$ git reset --hard HEAD~  注意：你可以使用reflog和reset恢复丢弃的提交，但是没有提交的修改是无法恢复的。
撤销修改 撤消对工作副本中文件或目录的更改。
$ git checkout -- file.txt  下面的命令将会递归的应用到当前目录的所有文件和文件夹上面，他将撤销工作区副本的所有修改：
$ git checkout .  想要撤销部分修改的话，可以使用---patch选项。这样对每个修改，你都将被询问，是要撤销还是保留：
$ git checkout --patch -- dir  想要撤销添加到index的修改，使用下面的命令：
$ git reset --hard  如果没有—hard选项的话，这将会执行一个软reset命令。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(一)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-1.html</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-1.html</guid>
      <description>开始Bash Hello World 交互shell Bash shell通常是使用其交互模式：这允许你输入和修改命令，当你按下Return键的时候，就会执行这些命令。大多数基于Unix和类Unix的操作系统都会使用Bash作为它们默认的shell（特别是Linux和macOS）。当终端打开的时候会自动的进入交互模式的Bash shell。
使用下面的方式输出一个Hello World：
$ echo &amp;quot;Hello World&amp;quot; #&amp;gt; Hello World # Output Example  注意点：
 你可以在终端中通过修改shell的名称来修改shell。比如：sh，bash等等 echo是Bash内建的一个命令，会把它接收到的参数输出到标准输出中。默认它会在输出的后面输出一个新行。  非交互shell Bash shell也可以在脚本中被按照非交互模式运行，当shell不需要人工操作时。交互的行为和非交互的行为都是唯一的：Unix V7 Bourne shell和其他的衍生shell 的一项重要设计原则。因此，任何在命令行中可以执行的命令都可以放到脚本中重复使用。
下面的步骤创建了一个Hello World脚本：
 创建一个叫hello-world.sh的文件。   $ touch hello-world.sh   为文件添加执行权限：chmod +x hello-world.sh
 添加下面的代码：
   #!/bin/bash echo &amp;quot;Hello World&amp;quot;  第一行：脚本的第一行必须以字符串#!开始，这被叫做 shebang。这个shebang通知操作系统去允许/bin/bash，并且把文件的路径作为参数传递给这个命令。像：/bin/bash hello-world.sh
第二行：使用echo命令把Hello world输出到标准输出。
 在命令行中执行hello-world.sh这个脚本可以使用下面的人一个方式：
 ./hello-world.sh 最常用的方法，也是最推荐的方法。 /bin/bash hello-world.sh bash hello-world.</description>
    </item>
    
    <item>
      <title>Git专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-6.html</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-6.html</guid>
      <description>git diff    parameter details     -p, -u, &amp;ndash;patch 生成补丁。   -s, &amp;ndash;no-patch 取消差异的输出。对于像git diff这样显示补丁的命令非常有用。或者用来取消—patch选项的效果。   &amp;ndash;raw 输出原生格式信息的文件差异信息。   &amp;ndash;diff-algorithm= 选择差异对比的算法。可选的算法有：myers，minimal，patience，histogram   &amp;ndash;summary 输出一个压缩的扩展头信息，包括（创建，重命名和模式修改等）   &amp;ndash;name-only 只展示修改文件的名称   &amp;ndash;name-status 展示已修改文件的名称和状态，常见的状态有：M 修改 A 添加 D 删除   &amp;ndash;check 如果修改出现了标记冲突和空白错误会发出警告。被视作空白错误的信息是由core.whitespace控制的。默认情况下，尾随空格（包括仅由空格组成的行）和空格字符（在行的初始缩进内紧跟制表符）被视为空格错误。如果出现问题就会以非0的退出码退出。不和--exit-code兼容。   &amp;ndash;full-index 当想产生补丁格式的输出时，取代最开始的几个字符，将会把完整的pre-和post-image二进制对象显示在索引行中。   &amp;ndash;binary 除了像--full-index外，还会输出一个可以用于git apply命令的二进制差异文件。   -a, &amp;ndash;text 把所有的文件视作文本。   &amp;ndash;color 设置颜色模式：如果要将diff设置为较小并保持git的颜色，请使用--color=always    展示工作区差异 $ git diff  这将展示当前分支未暂存的修改和之前的提交的差异。这只展示相对于索引的差异，也就是只展示你可以在下次提交的，但是还没有提交的修改。想要添加这些修改，可以使用git add。</description>
    </item>
    
    <item>
      <title>Git专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-5.html</link>
      <pubDate>Sun, 27 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-5.html</guid>
      <description>忽略文件文件夹 这章的主题是介绍怎么避免把不想要的文件（或者文件的修改）添加到Git仓库内。有好几种方式可以实现这个目的：全局或者本地的.gitignore ，.git/exclude，git update-index --assume-unchanged，git update-index --skip-tree。但是请记住Git是用来管理内容的：忽略实际忽略的是文件夹的内容。一个空的文件夹将会被自动忽略，因为它不能不添加到仓库内。
.gitignore 你可以让Git通过添加一个或多个.gitignore文件来忽略某些文件或者文件夹，即不把这些内容通过Git来追踪。
在一些软件项目中，.gitignore文件会包含一列在构建程序或运行时产生的文件或文件夹。在.gitignore中，可能包含指向下面内容的名称或路径：
 临时资源，像缓存，log文件，编译文件等 不应该分享给其他人的配置文件 包含密码、秘钥、证书等隐秘信息的文件  当在顶层目录创建这个文件时，这些规则将会应用到这个仓库所有的文件和子目录。当在子目录创建时，这些规则只会应用到这个目录和这个目录子目录的文件中。
当一个文件或目录被忽略了，这代表：
 不会被Git库追踪。 不会再git status和git diff命令中输出处理。 不会通过git add -A命令暂存这些内容。  在一些特殊的场景下，你需要把已经追踪的文件忽略掉，这时你要特别小心。可以查看下面章节：忽略已提交内容。
例子： 下面是一些.gitignore中比较简单的例子，基于glob file patterns：
# Lines starting with `#` are comments. # Ignore files called &#39;file.ext&#39; file.ext # Comments can&#39;t be on the same line as rules! # The following line ignores files called &#39;file.ext # not a comment&#39; file.ext # not a comment # Ignoring files with full path.</description>
    </item>
    
    <item>
      <title>Git专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-4.html</link>
      <pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-4.html</guid>
      <description>暂存区 暂存所有文件 想要删除一个远端的分支：
$ git add -A  在Git 2.0+之后的版本
$ git add .  在版本2.x时，git add .命令将会添加当前目录及其子目录下的所有修改的文件。但是在1.x的版本，只会暂存新建或修改的文件，不会暂存删除的文件。
使用git add -A或者git add --all来存储所有修改的文件，不管在哪个版本都是有效的。
取消存储的修改文件 $ git reset &amp;lt;filePath&amp;gt;  添加大片修改 你可以看到大片的选项是怎么被存储的，通过使用patch选项：
$ git add -p  或者
$ git add --patch  这个命令将会打开一个交互界面，允许你查看修改，并且决定哪些内容去被存储起来：
Stage this hunk [y,n,q,a,d,/,s,e,?]?   y stage this hunk for the next commit n do not stage this hunk for the next commit q quit; do not stage this hunk or any of the remaining hunks a stage this hunk and all later hunks in the file d do not stage this hunk or any of the later hunks in the file g select a hunk to go to / search for a hunk matching the given regex j leave this hunk undecided, see next undecided hunk J leave this hunk undecided, see next hunk k leave this hunk undecided, see previous undecided hunk K leave this hunk undecided, see previous hunk s split the current hunk into smaller hunks e manually edit the current hunk ?</description>
    </item>
    
    <item>
      <title>Git专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-3.html</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-3.html</guid>
      <description>操作远端 删除远端分支 想要删除一个远端的分支：
$ git push [remote-name] --delete [branch-name]  或者
$ git push [remote-name] :[branch-name]  修改远端地址 查看已经存在的远端地址：
$ git remote -v # origin https://github.com/username/repo.git (fetch) # origin https://github.com/usernam/repo.git (push)  修改仓库的地址：
$ git remote set-url origin https://github.com/username/repo2.git # Change the &#39;origin&#39; remote&#39;s URL  查看验证新的远端地址：
$ git remote -v # origin https://github.com/username/repo2.git (fetch) # origin https://github.com/username/repo2.git (push)  远端列表 查看这个仓库关联的远端列表：
$ git remote  查看这个仓库关联的远端列表，包括这些远端的fetch和push的Url地址。
$ git remote --verbose  或者</description>
    </item>
    
    <item>
      <title>Git专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-2.html</link>
      <pubDate>Fri, 18 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-2.html</guid>
      <description>查看历史    Parameter Explanation     -q, &amp;ndash;quiet Quiet, suppresses diff output   &amp;ndash;source Shows source of commit   &amp;ndash;use-mailmap Use mail map file (changes user info for committing user)   &amp;ndash;decorate[=&amp;hellip;] Decorate options   &amp;ndash;L &amp;lt; n,m:file&amp;gt; Show log for specific range of lines in a file, counting from 1. Starts from line n, goes to line m. Also shows diff.</description>
    </item>
    
    <item>
      <title>Git专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-1.html</link>
      <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-1.html</guid>
      <description>开始学习Git 创建自己的项目，并添加、提交文件 首页在终端验证你是否已经安装有Git：
在所有的操作系统上，都可以使用下面的命令：
$ git --version  在类Unix系统还可以使用下面的命令：
$ which git  如果什么都没有返回，或者没有通过验证，这就表明你需要通过下载并运行安装程序，在你的系统上安装Git。查看Git官网，上面有特别详细和容易的安装教程。
安装完Git之后，在你真正的提交之前，还需要配置好你的名称和邮件地址。
一旦安装成功Git，你就可以到你希望进行版本管理的文件夹下，初始化一个空的Git仓库：
$ git init  这会创建一个隐藏的.git文件夹，用来存放Git工作需要的信息。
接下来检查下Git将把什么文件加入到仓库内，这是非常值得注意的，也是在添加、提交文件之前的必要操作：
$ git status  检查文件的列表，你可以告诉Git哪些文件你想进行版本的管理（避免将像密码这样的重要信息或者污染仓库的信息添加到Git仓库里面）：
$ git add &amp;lt;file/directory name #1&amp;gt; &amp;lt;file/directory name #2&amp;gt; &amp;lt; ... &amp;gt;  如果所有的文件你都想和能访问这个仓库的人分享，有一个简单的命令可以添加当前目录和当前目录子目录内的所有文件：
$ git add .  这将“暂存”所有的文件，等待将这些文件加入版本管理，准备在你的第一次提交中提交它们。
对于你不想添加到版本管理的文件，你可以在执行add之前命令创建一个名.gitignore的文件，并且填写里面的内容。
提交所有已经添加的文件，同时填写一个提交的注释信息：
$ git commit -m &amp;quot;Initial commit&amp;quot;  这使用提供的信息创建了一个新的提交。一个提交就像你整个项目的一个快照。现在你就可以把本地的文件push到远端的仓库内，如果有需要的时候，你可以重新返回这里。
如果你忽略了-m参数，你默认的编辑器将会打开，你可以在编辑器里面编辑并且保存提交信息。
添加远端仓库 想要添加一个新的远端仓库地址，你可以在你仓库所在的文件夹内，在终端内执行git remote add命令。
1. 一个远端的名称，比如```origin``` 2. 一个远端的URL地址，比如```https://&amp;lt;your-git-service-address&amp;gt;/user/repo.git``` ```shell $ git remote add origin https://&amp;lt;your-git-service-address&amp;gt;/owner/repository.</description>
    </item>
    
    <item>
      <title>Golang学习（二）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/go-learn-2.html</link>
      <pubDate>Sat, 12 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/go-learn-2.html</guid>
      <description>上一节简单介绍了Golang的基本含义和简单的例子，接下来就详细介绍一下使用Go开发需要的详细环境配置。主要是GOPATH等环境变量和一些很有效的工具。
环境配置 go语言一般需要设置三个环境变量：
 GOPATH：go的工作区，是我们代码的所在目录。 GOROOT：go的安装路径，即go的安装目录。不过在1.11之后已经不需要再配置这个路径了。 GOBIN：go生成的执行文件的目录，也不需要专门的配置，默认在GOPATH目录下的src/bin目录  GOPATH go语言的代码工作区目录，可以是一个目录，也可以是多个目录，go命令会按照多个目录的顺序依次搜索相应的目录，
GOPATH目录的基本结构如下，下面会有三个目录：
bin/ pkg/ src/   bin目录就是GOBIN默认对应的目录，存放编译后的可执行文件，一般不用单独在设置。 src是我们的代码目录文件，下面包含.go文件，就是go的源码文件。 pkg编译后的生成的静态库文件，和平台有关系，每个平台会有相应的目录。在linux下是扩展名为.a的文件。  使用go install会bin目录生成项目的执行文件，而go build会在当前目录生成项目的执行文件。
管理工具 我们自己在开发时，可能不同的项目会需要在不同版本的go下面执行，就需要在不同版本go下面进行切换，这里就介绍两款工具，方便我们管理不同版本的go；go的包管理工具
GVM 管理不同版本go的管理工具GVM。
安装 在终端执行下面的命令，因为我本地安装了oh-my-zsh，所以我这里就最开始是zsh，如果你本地是原生的bash，将zsh替换成bash就可以：
$ zsh &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) Cloning from https://github.com/moovweb/gvm.git to /Users/test/.gvm Created profile for existing install of Go at &amp;quot;/usr/local/Cellar/go/1.11.4/libexec&amp;quot; Installed GVM v1.0.22 Please restart your terminal session or to get started right away run `source /Users/test/.gvm/scripts/gvm`  出现如上的信息就代表安装成功了，在安装下面的提示执行如下命令，激活gvm的命令：</description>
    </item>
    
    <item>
      <title>Golang学习（一）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/go-learn-1.html</link>
      <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/go-learn-1.html</guid>
      <description>作为一个PHP程序员，最近因为兴趣和业务的需要(学习了一个东西，如果不使用的话，忘记的速度会非常快)，开始接触golang这门语言，这里做下学习的笔记，这里是学习的第一步，简单介绍一下golang的一些基本信息。
简介 golang是一门谷歌开发并开源，和C++，java，c等一样的类c语言；一门静态、编译型语言。
该语言起源于2007年，于2009年正式的发布，目前在TIBOE中排行到19位。在各个地区尤其是国内拥有大量的使用，包括京东，七牛，B站等都有使用。
专注安全 golang在保留了C++的大部分语法，移除了其中指针运算，运算符重载等特性，同时增加了GC等新特性，拥有不输于C++的性能，是一门类型安全、内存安全的编程语言。
统一格式 golang强制要求语言的格式，让每个人的代码格式都是一致的，也许有人会不习惯，但是我觉得相同的语言格式对于代码的一致性，更容易理解别人的代码。
原生协程 为了更好的利用分布式和多核的计算机，实现了goroutine来达到这个目标，使用channel作为goroutine通信的工具。原生支持协程。简单的一个go func就可以实现协程。
易于开发 虽然具备不输于C++的性能，但是去除了一些C++的不良特性，增加gc。对于开发者来说，不用再考虑那些疑惑的特性，不用考虑内存的申请，更加关注于程序自身。
快速编译 golang的编译速度非常快，整个标准库一般在20s以下，自己的库一般也就几s就可以了，比c的编译速度更快，减少开发者等待编译的时间。
WebAssembly golang和WebAssembly强强联合，加入WASM的大家庭，允许编写可以在浏览器运营的程序，然后使用JavaScript调用wasm的文件，处理需要运算的功能，虽然目前还比较简单，但是值得期待。
等等，特性还有很多，我这只是列出一些比较有特色的特性。
Hello World! 任何语言的第一步都是Hello World!，我们也从这里开始。
安装 这里就直接使用mac环境介绍了，其他环境自行百度。
使用mac开发的，一般都已经安装好HomeworkBrew了，这里就直接执行命令就可以：
$ brew install go  安装网络的不同，等待的时间也不一样长，在命令行输入如下命令，就可以确定是否安装成功了:
$ go version  当输出类似go version go1.11.4 darwin/amd64的信息就代表安装成功了。
go一般会安装到如下目录：/usr/local/Cellar/go，目录下面是不同版本的目录。同时，会在/usr/local/bin下生成一个指向刚才目录下某个版本的go执行命令，
代码 环境安装成功之后，只是编写Hello World 的话，在任何目录下都可以。我们就直接在自己的家目录下编写第一个文件吧。
使用vim在命令行打开hello.go文件，然后输入如下内容：
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;Hello World!&amp;quot;) }  然后保存文件。
想要执行一个go文件，很简单，直接使用go run filename就可以，比如要执行hello.go文件，我们可以：
$ go run hello.go Hello World!  这我们就执行成功了，输出了我们想要的Hello World！</description>
    </item>
    
    <item>
      <title>Hugo&#43;GitHub搭建自己的blog</title>
      <link>http://blog.huaifufeng.com/2019/01/post/hugo-first.html</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/hugo-first.html</guid>
      <description>2019年新的开始，新年第一天的首个工作就是把blog搭了起来，之后就要坚持做下去了，保证一周能有一篇有货的文章，这个也是给自己提的一个邀请，每周要学习至少一个知识点，可以分享的知识点。
这个blog是用hugo搭建的，因为最近在学习go语言，所以就挑选了这个以go语音实现的静态网站生成工具，在以后就要看下hugo的源码了，希望能够学习并升级这个工具。下面就介绍一下hugo+github搭建自己的blog。
环境搭建 这里涉及到两个环境的配置Hugo静态网站生成器和GitHub代码托管网站的配置，下面分别介绍两个环境的配置过程。
Hugo环境搭建 Hugo是一个用golang语言实现的一个静态网站生成器，不只是用来生成blog，还可以用来生成商城，信息网站等。它最主要的特性就是快，安全。这里就介绍下安装方法。
Hugo支持目前市面上的操作系统，包括：Mac，Windows，Linux，OpenBSD，FreeBSD。我这里用的Mac电脑，就介绍下Mac的安装，其他的环境可以到Hugo安装页面查看相应的安装步骤。
1、首先确定你的电脑是否安装有Homebrew，这是一个mac的安装包管理工具，可以用来安装软件。
brew --version  如果输出了版本号，说明你的电脑已经安装了这个软件，否则就需要执行下面的命令进行安装。
/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;  然后重新输入上面的命令进行安装。
2、使用Homebrew安装Hugo
brew install hugo  安装完毕之后使用下面的命令验证：
hugo version  获取到版本号说明安装成功。
3、然后就可以使用过hugo的命令来生成网站，生成页面了。
首先生成网址，先到达你存放网站信息的地方，使用下面的命令生成网站的根目录文件夹example(替换为你自己的项目目录)：
hugo new site example  生成网站的目录结构如下：
. ├── archetypes ├── assets ├── config.toml //网站的配置文件 ├── content //网站内容的原始文件 ├── data ├── layouts ├── static └── themes //网站的模板文件  其他的我们暂时不关心，目前用到的是content，themes，config.toml
首先需要把我们的项目变成一个git项目，才可以进行下面的操作：
git init git add . git commit -m &#39;init&#39;  Hugo目前已经有了一批的模板，只需要到这个地址，就可以找到需要的模板了，我这个blog就是从中使用的模板。使用下面的命令就可以把一个模板下载到本地：</description>
    </item>
    
  </channel>
</rss>