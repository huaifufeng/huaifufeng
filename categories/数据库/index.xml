<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 14 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL专业笔记(六十一)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-61.html</link>
      <pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-61.html</guid>
      <description>服务器信息    参数 说明     GLOBAL 显示配置到整个服务器上面的变量。可选的   SESSION 显示只配置当前会有的变量。可选    1. SHOW VARIABLES 例子 获取所有的服务器变量，请在首选的(PHPMyAdmin或其他)窗口或mysql的命令行中运行下面的查询：
SHOW VARIABLES;  你可以像下面这样指定要获取全局变量还是当前会话的变量：
-- 会话变量 SHOW SESSION VARIABLES; -- 全局变量 SHOW GLOBALE VARIABLES;  像其他的SQL查询一样，你可以在这里使用LIKE等命令：
SHOW [GLOBAL | SESSION] VARIABLES LIKE &#39;max_join_size&#39;;  或者使用标识符：
SHOW [GLOBAL | SESSION] VARIABLES LIKE &amp;quot;%size%&amp;quot;;  你可以使用WHERE语句来筛选这个结果：
SHOW [GLOBAL | SESSION] VARIABLES WHERE VALUE &amp;gt; 0;  2. SHOW STATUS 例子 获取所有的服务器的状态，请在首选的(PHPMyAdmin或其他)窗口或mysql的命令行中运行下面的查询：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六十)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-60.html</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-60.html</guid>
      <description>一对多关系 一对多(1:M)的概念涉及行之间的连接，特别是一个表中的一行对应另一个表中的多行的情况。
1:M 是一种指向，也就是说查询1:M关系时，都可以使用&amp;rdquo;一&amp;rdquo;行在另一个表中找到&amp;rdquo;多&amp;rdquo;行，但不能使用单个&amp;rdquo;多&amp;rdquo;行找到多个&amp;rdquo;单&amp;rdquo;行。
1. Company表示例 假设有一个企业表，其中每个雇员都有一个经理，这个经理关联一个或多个雇员，并且每个雇员都只有一个经理。
两个表中有下面的数据：
EMPLOYEES EMP_ID FIRST_NAME LAST_NAME MGR_ID E01 Johnny Appleseed M02 E02 Erin Macklemore M01 E03 Colby Paperwork M03 E04 Ron Sonswan M01 MANAGERS MGR_ID FIRST_NAME LAST_NAME M01 Loud McQueen M02 Bossy Pants M03 Barrel Jones  2. 获取某个经理管理的雇员 SELECT e.emp_id, e.first_name, e.last_name FROM employees e JOIN managers m ON m.mgr_id=e.mgr_id WHERE m.mgr_id = &#39;M01&#39;; -- 结果 EMP_ID FIRST_NAME LAST_NAME E02 Erin Macklemore E04 Ron Sonswan  最后，对于我们查询的每个经理，我们将看到一个或多个员工返回。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十九)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-59.html</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-59.html</guid>
      <description>亚秒精度时间 1. 获取当前毫秒精度时间 SELECT NOW(3)  就是这样。
2. 获取当前时间的JavaScript时间戳格式 JavaScript时间戳基于古老的Unixtime_t数据类型，显示从1970-01-01 00:00:00 UTC开始的毫秒数。
下面的表达式获取当前时间的JavaScript时间戳整数（不管当前时区设置如何，这都会正确地执行此操作）。
ROUND(UNXI_TIMESTAMP(NOW(3)) * 1000.0, 0)  如果你的列中存储有TIMESTAMP格式的值，你可以使用UNIX_TIMESTAMP()方法获取时间的JavaScript时间戳整数。
SELECT ROUND(UNIX_TIMESTAMP(column) * 1000.0, 0)  如果你的列中包含DATETIME列，你可以将他们作为JavaScript时间戳检索。那么这些时间戳将会按照时区进行便宜。
3. 创建存储亚秒列的表 CREATE TABLE times ( dt DATETIME(3), ts TIMESTAMP(3) );  创建带有毫秒精度的日期/时间字段的表。
INSERT INTO times VALUES (NOW(3), NOW(3));  在表中插入一行包含NOW()毫秒精度的值：
INSERT INTO times VALUES (&#39;2015-01-01 16:34:00.123&#39;,&#39;2015-01-01 16:34:00.128&#39;);  插入指定的时间精度值。
注意：如果你想要插入高精度的值的话，需要使用NOW(3)而不是NOW()
4. 转换毫秒精度的日期和时间为文本值 %f是小数精度格式说明符，对DATE_FORMATE()来说。
SELECT DATE_FORMAT(NOW(3), &#39;%Y-%m-%d %H:%i:%s.%f&#39;)  这将会显示2016-11-19 09:52:53.248000这样小数的毫秒。因为我们使用的是NOW(3)，所以分数的最后3位是0。
5. 存储Javascript时间戳到一个TIMESTAMP列中 如果你有一个JavaScript的时间戳，例如1478960868932，你可以像下面这样将这个值转换为MySQL的小数时间值：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十八)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-58.html</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-58.html</guid>
      <description>多种语言使用UTF-8连接 1. Python 源代码的第一行或第二行(需要有utf8的编码声明)
# -*- coding: utf-8 -*-  连接：
db = MySQLdb.connect(host=DB_HOST, user=DB_USER, passwd=DB_PASS, db=DB_NAME, charset=&amp;quot;utf8mb4&amp;quot;, use_unicode=True)  对于web页面，下面中的一个：
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt; &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;  2. PHP 在php.ini(在PHP5.6之后是默认的)：
default_charset UTF-8  当在web页面的时候：
header(&#39;Content-type: text/plain; charset=UTF-8&#39;);  当连接MySQL的时候：
(for mysql:) Do not use the mysql_* API! (for mysqli:) $mysqli_obj-&amp;gt;set_charset(&#39;utf8mb4&#39;); (for PDO:) $db = new PDO(&#39;dblib:host=host;dbname=db;charset=utf8&#39;, $user, $pwd);  在代码中，不用使用任何转换例程。
对于数据入口：
&amp;lt;form accept-charset=&amp;quot;UTF-8&amp;quot;&amp;gt;  对于JSON，避免使用\uxxxx:
 $t = json_encode($s, JSON_UNESCAPED_UNICODE);  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十七)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-57.html</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-57.html</guid>
      <description>处理稀疏或丢失的数据 1. 处理包含NULL值的列 在MySQL和其他的SQL语言中，NULL是一个特殊的属性。
考虑有下面的表，其中包括求职者信息、他们的公司以及他们离开公司的时间。NULL值表示这个人还在公司中工作:
CREATE TABLE example (`applicant_id` INT, `company_name` VARCHAR(255), `end_date` DATE); +--------------+-----------------+------------+ | applicant_id | company_name | end_date | +--------------+-----------------+------------+ | 1 | Google | NULL | | 1 | Initech | 2013-01-31 | | 2 | Woodworking.com | 2016-08-25 | | 2 | NY Times | 2013-11-10 | | 3 | NFL.com | 2014-04-13 | +--------------+-----------------+------------+  你的任务是使用一个查询获取所有在2016-01-01之后的记录，包括还在公司工作的员工记录(那些NULL的值)，下面这个查询语句：
SELECT * FROM example WHERE end_date &amp;gt; &#39;2016-01-01&#39;;  将不会包含NULL值的记录：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十六)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-56.html</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-56.html</guid>
      <description>自定义PS1 1. 自定义当前数据库的MySQL PS1 在.bashrc或.bash_profile中添加下面的内容：
export MYSQL_PS1=&amp;quot;\u@\h [\d]&amp;quot;  这会让MySQL客户端提示当前的 user@host [database]
2. 使用MySQL配置文件配置PS1 在mysqld.cnf或者等价的文件中添加下面的内容：
[mysql] prompt = &#39;\u@\h [\d] &#39;  这将会获得相同的功能，但是不需要处理.bashrc这样的文件。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十五)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-55.html</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-55.html</guid>
      <description>临时表 1. 创建临时表 临时表用来保存临时数据是很有用的。临时表选项是在MySQL3.23之后开始有效的。
临时表在会话结束或连接关闭的时候自动销毁。用户也可以自己删的临时表。
相同名称的临时表可以在同时被多个连接使用，因为临时表只在创建表的客户端中有效可以访问。
临时表可以使用下面的语法穿甲：
-- 基本语法 CREATE TEMPORARY TABLE tempTable1( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(100) NOT NULL, PRIMARY KEY (id) ); -- 从select创建 CREATE TEMPORYARY TABLE tempTable1 SELECT ColumnName1,ColumnName2,... FROM table1;  你可以像创建表一样添加索引：
CREATE TEMPORARY TABLE tempTable1 (PRIMARY KEY(ColumnName2)) SELECT ColumnName1,ColumnName2,... FROM table1;  IF NOT EXISTS关键字用来避免&amp;rsquo;table already exists&amp;rsquo;错误。你过你创建的表名在的当前会话中已经存在了，这个表将不会创建。
CREATE TEMPORARY TABLE IF NOT EXISTS tempTable1 SELECT ColumnName1,ColumnName2,... FROM table1;  2. 删除临时表 Drop Temporary Table用来删除这个会话中创建的临时表。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十四)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-54.html</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-54.html</guid>
      <description>MySQL Client    参数 描述     -D —database=name 数据库的名称   —delimiter=str 设置语句的分隔符，默认是&amp;rdquo;;&amp;rdquo;   -e —execute=&amp;lsquo;command&amp;rsquo; 执行命令   -h —hostname=name 要连接的主机名称   -p —password=password 密码。注意：在-p和密码之间没有空格   -p (没有密码) 将会提示输入密码   -P —port=# 端口号   -s —slient 安静模式，产生更少的输出。使用-t作为列分隔符   -ss 和-s一样，但是忽略列名   -S —socket=path 当连接本地实例的时候，指定使用的socket(Unix)或pipe(Windows)   —skip-column-names 忽略列名   -u —user=name 用户名   -U —safe-updates —i-am-a-dummy 使用sql_safe_updates=ON变量登录。这在DELETE和UPDATE操作时，只允许指定Key的操作   -V —version 打印版本号并退出    1.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十三)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-53.html</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-53.html</guid>
      <description>Union 1. Union运算符 Union运算符用来把两个或多个SELECT语句的结果集(只有非重复的值)组合在一起。
查询：从&amp;rdquo;Customers&amp;rdquo;和&amp;rdquo;Supplies&amp;rdquo;表中查询不同的城市(只限非重复的值)
SELECT City FROM Customers UNION SELECT City FROM Suppliers ORDER BY City;  结果：
Number of Records: 10 City ------ Aachen Albuquerque Anchorage Annecy Barcelona Barquisimeto Bend Bergamo Berlin Bern  2. Union ALL Union ALL从&amp;rdquo;Customers&amp;rdquo;和&amp;rdquo;Suppliers&amp;rdquo;两个表中查到所有的值(包括重复的值)。
查询：
SELECT City FROM Customers UNION ALL SELECT City FROM Suppliers ORDER BY City;  结果：
Number of Records: 12 City ------- Aachen Albuquerque Anchorage Ann Arbor Annecy Barcelona Barquisimeto Bend Bergamo Berlin Berlin Bern  3.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十二)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-52.html</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-52.html</guid>
      <description>LOAD DATA INFILE 1. 使用LOAD DATA INFILE 导入大量数据到数据库 考虑下面的示例，假设您有一个以&amp;rdquo;;&amp;ldquo;分隔的csv加载到数据库中。
1;max;male;manager;12-7-1985 2;jack;male;executive;21-8-1990 . . . 1000000;marta;female;accountant;15-6-1992  创建一个要导入数据的表：
CREATE TABLE `employee` ( `id` INT NOT NULL , `name` VARCHAR NOT NULL, `sex` VARCHAR NOT NULL , `designation` VARCHAR NOT NULL , `dob` VARCHAR NOT NULL );  使用下面的语句来把数据导入的数据表中：
LOAD DATA INFILE &#39;path of the file/file_name.txt&#39; INTO TABLE employee FIELDS TERMINATED BY &#39;;&#39; //指定字段分隔符 LINES TERMINATED BY &#39;\r\n&#39; (id, name, sex, designation, dob)  考虑其中日期格式不标准的情况：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十一)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-51.html</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-51.html</guid>
      <description>使用mysqlimport导入数据    选项 详情     —delete -D 服务器登录选项   —fields-optionally-enclosed-by 定义引用字段的字符   —fields-terminated-by 字段终止符   —ignore -i 如果key重复了，那就忽略已经插入的行   —lines-terminated-by 定义行终止符   —password -p 密码   —port -P 端口号   —replace -r 重复key时，覆盖原本的行   —user -u 用户名   —where -w 指定条件    1. 基本用法 使用tab分隔符的employee.txt文件：
 1 \t Arthur Dent 2 \t Marvin 3 \t Zaphod Beeblebrox</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五十)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-50.html</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-50.html</guid>
      <description>使用mysqldump备份    选项 详情     — 服务器登录选项   -h (—host) 要连接的服务器的主机(IP地址或主机名称)。默认是localhost(127.0.0.1)。例如-h localhost   -u (—user) MySQL的用户名   -p (—password) MySQL的用户密码。重要：当使用这个选项的时候，在-p和密码之间没有空格。例如-pMyPassword   — 导出选项   —add-drop-database 在每个CREATE DATABASE语句之前添加一个DROP DATABASE。如果你想要替换服务器上面的数据库，这个是很有用的   —add-drop-table 在每个CREATE TABLE语句前面增加DROP TABLE语句。当你想要替换服务器上面的表的话很有用。   —no-create-db 禁止在转存中使用CREATE DATABASE语句。当你确定要转存的数据库在目标数据库中已经存在时使用。   -t (—no-create-info) 禁止在转存中使用CREATE TABLE语句。这在你只想导出表的数据时有用，然后在另外的库中使用这个转存文件导入数据到相同的表中。   -d (—no-data) 不写表信息。值或导出CREATE TABLE语句。对应创建数据库的&amp;rdquo;模板&amp;rdquo;很有用   -R (—routines) 在导出中包含存储过程/函数   -K (—disable-keys) 在插入数据之前禁止每个表的key，数据导入之后允许key。这会增加MyISAM中没有唯一索引的表的导入速度。    1.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十九)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-49.html</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-49.html</guid>
      <description>复制 1. 主从配置复制 假设有两个MySQL服务器进行复制配置，其中一台是主库，一台是从库。
我们需要配置主库记录在其上执行的每个操作的日志。我们需要配置从库监控主库的日志，一旦主库做了一些修改操作，从库就需要执行同样的操作。
主库配置
首先，我们需要为主库设置一个用户。这个用户用来给从库建立到主库的连接使用。
CREATE USER &#39;user_name&#39;@&#39;%&#39; IDENTIFIED BY &#39;user_password&#39;; GRANT REPLICATION SLAVE ON *.* TO &#39;user_name&#39;@&#39;%&#39;; FLUSH PRIVILEGES;  修改上面代码中的user_name和user_password为你自己的用户名和密码。
现在my.inf(Linux中是my.cnf)需要被修改了，在[mysqld]部分添加下面的内容：
server-id = 1 log-bin = mysql-bin.log binlog-do-db = your_database  第一行用来为这个MySQL服务器设置一个ID。
第二行告诉MySQL开始在指定的log文件中开始写入日志。在Linux机器上，这个需要被设置为log-bin=/home/mysql/logs/mysql-bin.log。如果您正在已使用复制的MySQL服务器中启动复制，请确保此目录中没有复制日志。
第三行用来说明我们想要哪个数据库去写日志。你需要替换其中的your_database为你自己的数据库名。
确保ship-networking没有开启，重启主库。
从库配置
从库的my.inf也需要修改。需要在[mysqld]部分包含下面的内容：
server-id = 2 master-host = master_ip_address master-connect-retry = 60 master-user = user_name master-password = user_password replicate-do-db = your_database relay-log = slave-relay.log relay-log-index = slave-relay-log.index  第一行用来设置这个从库的ID，这个ID应该是唯一的。
第二行是主库服务器的IP地址。修改这个值为你的主库服务器的IP。
第三行以秒为单位，限制重试的次数。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十八)</title>
      <link>http://blog.huaifufeng.com/2019/06/post/mysql-section-48.html</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/mysql-section-48.html</guid>
      <description>分区 1. 范围分区 按照范围分区的表是指每个分区包含按照指定分区表达式在某个范围内的行。范围应该是连续但不重叠的，使用VALUES LESS THAN运算符获得。在下面的例子中，假设你创建了包含下面20加连锁视频店(从1到20)的人事记录。
CREATE TABLE employees( id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30), hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;, separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;, job_code INT NOT NULL, store_id INT NOT NULL );  这个表可以根据你的需要，按照不同的范围分为几个区。一种方法是使用store_id列。例如，你可以把表分为4个部分，使用PARTITION BY RANGE语句：
ALTER TABLE employees PARTITION BY RANGE (store_id) ( PARTITION p0 VALUES LESS THAN (6), PARTITION p1 VALUES LESS THAN (11), PARTITION p2 VALUES LESS THAN (16), PARTITION p3 VALUES LESS THAN MAXVALUE );   MAXVALUE表示一个始终大于最大可能整数值的整数值。(在数学中，用作最小上界。)</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-47.html</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-47.html</guid>
      <description>集群 1. 消除歧义 &amp;ldquo;MySQL集群&amp;rdquo;消除歧义：
 NDB集群：一种专用，主要是内存中引擎。没有广泛使用 Galera集群又叫Percona XtraDB集群又叫PXC又叫带有Galera的MariaDB：一个非常好的MySQL高可用性解决方案;它超越了Replication  查看单独的&amp;rdquo;集群&amp;rdquo;相关的页面。
对于&amp;rdquo;聚簇索引&amp;rdquo;，查看主键相关。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十六)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-46.html</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-46.html</guid>
      <description>日志文件 1. 慢查询日志 慢查询日志包含查询话费时间在long_query_time秒之后才结束的查询记录。例如，话费了10秒才查询结束。要查看当前设置的慢查询时间值，可以使用下面的命令：
SELECT @@long_query_time; +-------------------+ | @@long_query_time | +-------------------+ | 10.000000 | +-------------------+  可以在my.cnf或my.ini文件中配置一个全局的设置值。或者可以在一个会话中进行设置，虽然这个不太常用。这个值是从0到10(秒)之间的一个值。应该使用什么值呢？
 10秒太高了，一般不使用。 2秒是一个妥协的方案 0.5或者其他分数是可能的 0秒会捕获所有的内容；这可能会很快的把硬盘填满，但是很有用。  慢查询日志要么开启要么关闭。并且log文件也是可以指定的。下面的内容介绍了相关的变量：
SELECT @@slow_query_log; -- 慢查询是否开启 SELECT @@slow_query_log_file; -- 慢查询日志文件 SELECT @@datadir; -- 日志文件的目录 SET GLOBAL slow_query_log=0; --关闭 SET GLOBAL slow_qeury_log=1; --开启  更详细的信息，查看MySQL的手册：慢查询日志。
注意：上面例子中开启和关闭慢查询的方法是5.6之后新加的，在老版本中使用另外的语法。
&amp;ldquo;最好&amp;rdquo;的查询你系统上面的慢日志：
long_query_time=... turn on the slowlog run for a few hours turn off the slowlog (or raise the cutoff) run pt-query-digest to find the &#39;worst&#39; couple of queries.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十五)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-45.html</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-45.html</guid>
      <description>事务 1. 开启事务 一个事务就是一个SQL语句的序列分组，可以包括像select,insert,update或者delete这些超值，然后在一个工作单元中执行。
换句话说，事务只有在分组中的每个操作执行成功的情况下才会完成执行。如果事务中任何一个操作失败了，事务就会失败。
银行事务是用来解释这个的最好例子。假设有两个用户之间的转账操作。要实现这个功能你需要写下面的SQL语句：
 首先检查第一个账户请求的数量是不是有效。 从第一账户中删除请求的数量 在第二个账户中增加这个金额  如果上面的操作中任何一个操作失败了，就需要返回之前的状态。
ACID：事务的属性
事务有下面四个属性：
 原子性：确保工作单元内的所有操作都成功完成；否则事务的操作会在失败时终止，以前的操作都会回滚到以前的状态。 一致性：确保数据库在成功提交事务时正确更改状态。 隔离性：使事务能够独立运行并且彼此透明 持久性：确保提交事务的结果在系统故障时持续存在  事务使用START TRANSACTION或BEGIN WORK来开启，然后使用COMMIT或ROLLBACK语句结束。在这两个语句之间的SQL语句就是事务的代码块。
START TRANSACTION; SET @transAmt = &#39;500&#39;; SELECT @availableAmt:=ledgerAmt FROM accTable WHERE customerId=1 FOR UPDATE; UPDATE accTable SET ledgerAmt=ledgerAmt-@transAmt WHERE customerId=1; UPDATE accTable SET ledgerAmt=ledgerAmt+@transAmt WHERE customerId=2; COMMIT;  在使用START TRANSACTION语句之后，自动提交操作将会被终止，知道事务结束使用COMMIT或ROLLBACK 操作才会提交这些修改。然后恢复自动提交操作之前单的状态。
FOR UPDATE语句指示(并锁定)事务持续期间的行。
事务没有提交之前，这个事务对其他用户就不是有效的。
事务的一般过程
 通过START TRANSACTION或BEGIN WORK来开启一个事务。 运行事务中的SQL语句 检查事务中SQL是否安装你的要求执行了 如果时的话，执行COMMIT命令。否知执行ROLLBACK操作恢复之前的状态 即使在提交之后，如果您正在使用或可能最终使用galera/pxc，也要检查错误。  2. COMMIT，ROLLBACK，AUTOCOMMIT AUTOCOMMIT</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十四)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-44.html</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-44.html</guid>
      <description>MyISAM转换为InnoDB 1. 基本转换 ALTER TABLE ENGINE=InnoDB;  这个操作转换了两个数据表的引擎，但是不关心这两种引擎之间的差异。大部分差别是没有影响的，特别是对小表来说。但是多于常用的表来说，还要考虑其他的因素。转换注意点。
2. 转换一个数据库的所有表 使用下面的命令可以方便的吧一个数据库中所有的表进行转换。
SET @DB_NAME = DATABASE(); SELECT CONCAT(&#39;ALTER TABLE `&#39;, table_name, &#39;` ENGINE=InnoDB;&#39;) AS sql_statements FROM information_schema.tables WHERE table_schema = @DB_NAME AND &#39;ENGINE&#39; = &#39;MyISAM&#39; AND &#39;TABLE_TYPE&#39; = &#39;BASE TABLE&#39;;   注意：你应该连接上数据让DATABASE()正常工作，否则这个方法将会返回NULL。这主要适用于随服务器提供的标准MySQL客户机，因为它允许在不指定数据库的情况下进行连接。
 运行这个表获取你数据库中所有的MyISAM表。
最后，复制输出的SQL然后执行他们。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十三)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-43.html</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-43.html</guid>
      <description>MyISAM引擎 1. ENGINE=MyISAM CREATE TABLE foo ( ... ) ENGINE=MyISAM;  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十二)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-42.html</link>
      <pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-42.html</guid>
      <description>字符集和排序 1. 什么是字符集和排序？ 有几十种字符集和数百种排序规则。(一种排序规则只属于一种字符串)。查看SHOW COLLATION;的输出。
通常只有4中字符集比较重要：
ascii -- 基础的7位编码 latin1 -- ascii, 加上大多数西欧语言需要的字符 utf8 -- the 1-, 2-, and 3-byte subset of utf8. 不包括 Emoji and 一些中文. utf8mb4 -- UTF8字符的全集合，包含当前所有的语言  全部包括英文字符，编码相同。utf8是utf8mb4的子集。
最好用法：
 将utf8mb4用于包含多种语言的TEXT和VARCHAR列 对于十六进制字符串（UUID、MD5等）和简单代码（国家/地区代码、邮政编码等），使用ASCII（Latin1是OK）。  在MySQL5.3.3之前是没有utf8mb4这个字符集的，所以在之前的版本中utf8是最有效的。
在MySQL之外的环境中，&amp;rdquo;UTF8&amp;rdquo;表示的是和MySQL中utf8mb4是想同的，而不是utf8。
排序规则以字符集开头，以_ci结尾表示&amp;rdquo;大小写和重音区分&amp;rdquo;，以&amp;rdquo;_bin&amp;rdquo;结尾表示已二进制比较。
最新的uttf8mb4排序规则是utf8mb4_unicode_520_ci，是基于Unicode 5.20。如果你基于一个语言，那么你可能用到&amp;rdquo;utf8mb4_polish_ci&amp;rdquo;，它将根据波兰语惯例稍微重新排列字母。
2. 设置表和字段的字符集 你可以为每个表和每个单独的字段设置字符集，使用CHARACTER SET和charset语句。
CREATE TABLE Address ( `AddressID` INTEGER NOT NULL PRIMARY KEY, `Street` VARCHAR(80) CHARACTER SET ASCII, `City` VARCHAR(80), `Country` VARCHAR(80) DEFAULT &amp;quot;United States&amp;quot;, `Active` BOOLEAN DEFAULT 1, ) Engine=InnoDB default charset=UTF8;  City和Country将会使用UTF8编码，这个是这个表的默认字符集。Street使用ASCII编码，我们专门指定的。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十一)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-41.html</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-41.html</guid>
      <description>使用Docker-Compose安装MySQL容器 1. 简单的Docker-Compose例子 下面是使用Docker创建MySQL服务器的简单例子。
创建docker-compose.yml文件：
注意：如果你想为你所有的项目使用相同的容器，需要在你的HOME_PATH中创建一个PATH。如果你想要在你的每个项目中创建这个文件，你需要在项目中创建一个docker目录。
version: &#39;2&#39; services: cabin_db: image: mysql:latest volumes: - &amp;quot;./.mysql-data/db:/var/lib/mysql&amp;quot; restart: always ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: rootpw MYSQL_DATABASE: cabin MYSQL_USER: cabin MYSQL_PASSWORD: cabinpw  运行
cd PATH_TO_DOCKER-COMPOSE.YML docker-compose up -d  连接到服务器
mysql -h 127.0.0.1 -u root -P 3306 -p rootpw -- 成功了  终止服务器
 docker-compose stop  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四十)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-40.html</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-40.html</guid>
      <description>ENUM 1. 什么是ENUM？ ENUM提供了一个为一行数据增加属性的功能。具有少量非数字选项的属性效果最好。例子：
reply ENUM(&#39;yes&#39;, &#39;no&#39;) gender ENUM(&#39;male&#39;, &#39;female&#39;, &#39;other&#39;, &#39;decline-to-state&#39;)  它们的值是字符串：
INSERT ... VALUES (&#39;yes&#39;, &#39;female&#39;) SELECT ... --&amp;gt; yes female  2. VARCHAR是一种可选方案 假设我们有下面的内容：
type ENUM(&#39;fish&#39;, &#39;mammal&#39;, &#39;bird&#39;); -- 下面是另一种方案 type VARCHAR(20) COMENT &#39;fish,mammal,bird等等&#39;  这是相当开放的，因为新的类型是很容易添加的。
比较，以及是否比枚举更好或更差：
 (相同) INSERT:简单的提供相同的字符串 (更糟？) INSERT：拼写错误可能注意不到 (相同) SELECT：返回实际的字符串 (更坏) 需要更多的存储空间。  3. 添加一个选项 ALTER TABLE tbl MODIFY COLUMN type ENUM(&#39;fish&#39;,&#39;mammal&#39;,&#39;bird&#39;,&#39;insect&#39;);  注意：
 和其他的MODIFY COLUMN一样，你需要包含NOT NULL，以及任何其他之前拥有的限定符，不然会丢失一些东西 如果添加在列表的末尾，并且列表的数量小于256个，ALTER操作将会正常执行修改表结构的操作。也就是说，不会有冗长的表副本。（旧版本的MySQL没有这种优化。）  4. NULL VS NOT NULL 下面是当NULL和&amp;rsquo;错误值&amp;rsquo;存储到NULLable和非NULL时什么将会发生的例子。也展示了通过+0来转换为数字的操作。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十九)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-39.html</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-39.html</guid>
      <description>事件 1. 创建一个事件 MySQL有它的事件功能，可以避免复杂的cron交互，当您计划的大部分内容与SQL相关，而与文件关联较少时。查看事件手册。把事件想象为定时执行的存储过程。
要节省调试事件相关问题的时间，请记住必须打开全局事件处理程序才能处理事件。
SHOW VARIABLES WHERE variable_name = &#39;even_scheduler&#39;; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | event_scheduler | OFF | +-----------------+-------+  当配置关闭的时候，什么都不会触发。使用下面的命令打开这个配置：
SET GLOBAL event_scheduler = ON;  测试的表
CREATE TABLE theMessage ( Id INT AUTO_INCREMENT PRIMARY KEY, userId INT NO NULL, message VARCHAR(255) NOTT NULL, updateDt DATETIME NOT NULL, KEY (updateDt) ); INSERT theMessages(userId,message,updateDt) VALUES (1,&#39;message 123&#39;,&#39;2015-08-24 11:10:09&#39;); INSERT theMessages(userId,message,updateDt) VALUES (7,&#39;message 124&#39;,&#39;2015-08-29&#39;); INSERT theMessages(userId,message,updateDt) VALUES (1,&#39;message 125&#39;,&#39;2015-09-03 12:00:00&#39;); INSERT theMessages(userId,message,updateDt) VALUES (1,&#39;message 126&#39;,&#39;2015-09-03 14:00:00&#39;);  上述插入件用于显示起点。请注意，下面创建的两个事件将清除行。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十八)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-38.html</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-38.html</guid>
      <description>配置和调整 1. InnoDB性能 在my.cnf中有几百个配置项。对于MySQL的&amp;rdquo;普通&amp;rdquo;用户来说，他们并不关心这个。
一旦你的数据库变得重要了，非常建议设置下面的参数：
innodb_buffer_pool_size  这应该被设置为有效RAM的70%(如果你至少有4GB的内存；如果你的内存较小或机器比较老，这个值还有更小一些。)这个配置控制这InnoDB引擎使用的缓存数量。因此这个配置对于InnoDB的性能是非常重要的。
2. 允许大数据插入的参数 如果我们需要在一个列中存储图片或视频这种大文件，我们需要修改下面的配置项，用来满足我们应用的需要：
max_allowed_packet = 10M M is Mb, G in Gb, K in Kb  3. 增加group_concat的字符串限制 group_concat用来将一个分组的非NULL的值的拼接组合。这个的结果字符串的最大长度可以使用group_concat_max_len选项来控制：
SET [GLOBAL | SESSION] group_concat_max_len = val;  设置变量的GLOBAL模式，将会设置一个永久的值，而设置SESSION模式，将会只在这个这个会话下有效果。
4. 最小InnoDB配置项 这是使用InnoDB表的MySQL服务器的最低配置。使用InnoDB使用查询缓存。删除表或数据时收回硬盘空间。当使用SSD时，刷新是一个冗余的操作(SSD不是连续的)。
default_storage_engine = InnoDB query_cache_type = 0 innodb_file_per_table = 1 innodb_flush_neighbors = 0  并发
通过将innodb_thread_concurrency设置为0，确保我们可以创建超过默认4个线程。这使用InnoDB可以根据最佳执行情况进行设置。
innodb_thread_concurrency = 0 innodb_read_io_threads = 64 innodb_write_io_threads = 64  硬盘利用率
设置MySQL的IOPS的容量(平均负载)和最大容量(最大负载)。对于HDD，默认200是可以的。但是现在，对于SSD可以达到数千的IOPS，你可能需要设置这个值。可以运行很多的测试来确定IOPS。如果您运行的是一个专用的mysql服务器，上面的值应该接近这个限制。如果您在同一台机器上运行任何其他服务，则应根据需要进行分配。
innodb_io_capacity = 2500 innodb_io_capacity_max = 3000  RAM利用率</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-37.html</link>
      <pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-37.html</guid>
      <description>触发器 1. 基础触发器 创建表
mysql&amp;gt; CREATE TABLE account(acct_num INT, amount DECIMAL(10, 2)); Query OK, 0 rows affected (0.03 sec)  创建触发器
mysql&amp;gt; CREATE TRIGGER ins_sum BEFORE INSERT ON account -&amp;gt;FOR EACH ROW SET @sun = @sum + NEW.amount; Query OK, 0 rows affected (0.06 sec)  这个CREATE TRIGGER语句创建一个名为ins_sum的触发器，并且关联到account表上面。它也包含指明触发器时间，触发器时间和触发器执行什么操作的语句。
插入数据
想要使用触发器，将累加变量(@sum)设置为0，执行一个INSERT语句，然后查看这个变量的值：
mysql&amp;gt; SET @sum = 0; mysql&amp;gt; INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00); mysql&amp;gt; SELECT @sum AS &#39;Total amount inserted&#39;; +-----------------------+ | Total amount inserted | +-----------------------+ | 1852.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十六)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-36.html</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-36.html</guid>
      <description>MySQL管理员 1. 原子重命名和表格重新加载 RENAME TABLE t TO t_old, t_copy TO t;  当执行RENAME TABLE操作期间，没有其他请求可以访问这个表，这样重命名操作没有并发的问题。
原子重命名特别适用于在不等待删除和加载完成的情况下重新加载表：
CREATE TABLE new LIKE real; load `new` by whatever means - LOAD DATA, INSERT, whatever RENAME TABLE real TO old, new TO real; DROP TABLE old;  2. 修改root密码 mysaladmin -u root -p&#39;old-password&#39; password &#39;new-password&#39;  3. 删除数据库 用来删除数据库和所有表的脚本：
mysqladmin -u[username] -p[password] drop [database]  使用时要格外小心。
想要使用SQL语句删除数据库(你需要在这个数据库上面拥有DROP权限)：
DROP TABLE database_name  或者：
DROP SCHEMA database_name  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十五)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-35.html</link>
      <pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-35.html</guid>
      <description>从JSON类型提取数据    参数 描述     json_doc 有效的JSON数据   path 成员路径    MySQL5.7.8支持原生的JSON类型。因为你有不同的方法来创建json对象，你也可以访问和读取元素使用不同的方法。
主要的方法是JSON_EXTRACT，因此-&amp;gt;和-&amp;gt;&amp;gt;运算符更加友好。
1. 读取JSON数组值 创建JSON类型的@myjson变量：
SET @myjson = CAST(&#39;[&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, {&amp;quot;id&amp;quot;:1, &amp;quot;label&amp;quot;:&amp;quot;C&amp;quot;}]&#39; as JSON);  SELECT查询其中的元素：
SELECT JSON_EXTRACT( @myjson , &#39;$[1]&#39; ) , JSON_EXTRACT( @myjson , &#39;$[*].label&#39;) , JSON_EXTRACT( @myjson , &#39;$[1].*&#39; ) , JSON_EXTRACT( @myjson , &#39;$[2].*&#39;) ; -- result values: &#39;\&amp;quot;B\&amp;quot;&#39;, &#39;[\&amp;quot;C\&amp;quot;]&#39;, NULL, &#39;[1, \&amp;quot;C\&amp;quot;]&#39; -- visually: &amp;quot;B&amp;quot;, [&amp;quot;C&amp;quot;], NULL, [1, &amp;quot;C&amp;quot;]  2.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十四)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-34.html</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-34.html</guid>
      <description>JSON MySQL5.7.8开始支持元素的JSON数据类型，允许方便的访问JSON数据。https://dev.mysql.com/doc/refman/5.7/en/json.html
1. 创建带有主键和JSON字段的表 CREATE TABLE table_name ( id INT NOT NULL AUTO_INCREMENT, json_col JSON, PRIMARY KEY (id) );  2. 插入一个简单的JSON INSERT INTO table_name(json_col) VALUES (&#39;{&amp;quot;City&amp;quot;:&amp;quot;Galle&amp;quot;, &amp;quot;Description&amp;quot;: &amp;quot;Best damn city in the world&amp;quot;}&#39;);  这个是很容易的，但是注意因为JSON的键必须包围在双引号内，所以整个JSON字符串必须包围在单引号内。如果查询成功了，这个数据将会存储为二进制格式。
3. 更新JSON字段 在前面的例子中，我们查看了组合类型数据怎么存储到一个JSON字段中。如果我们想要更新这个字段怎么办？我们想在之前的数据中数据一个键为variations，值为scheveningen的内容：
UPDATE myjson SET dict=JSON_ARRAY_APPEND(dict, &#39;$.variations&#39;, &#39;scheveningen&#39;) WHERE id = 2;  注意：
 在我们json字典中的$.variations数组。$符合表示json文档。有关mysql识别的JSON路径的完整解释，请参阅https://dev.mysql.com/doc/refman/5.7/en/json-path-syntax.html 因为我们没有使用JSON进行查询的例子，所以这个例子使用主键。  现在，如果我们执行SELECT * FROM myjson，我们将看到：
+----+--------------------------------------------------------------------------------+ | id | dict | +---+---------------------------------------------------------------------------------+ | 2 | {&amp;quot;opening&amp;quot;: &amp;quot;Sicilian&amp;quot;, &amp;quot;variations&amp;quot;: [&amp;quot;pelikan&amp;quot;, &amp;quot;dragon&amp;quot;, &amp;quot;najdorf&amp;quot;, &amp;quot;scheveningen&amp;quot;]} | +----+--------------------------------------------------------------------------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十三)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-33.html</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-33.html</guid>
      <description>PREPARE语句 1. PREPARE, EXECUTE和DEALLOCATE PREPARE语句 PREPARE准备一个将要执行的语句。
EXECUTE执行一个准备好的语句。
DEALLOCATE PREPARE释放一个准备好的语句。
SET @s = &#39;SELECT SQRT(POW(?,2) + POW(?, 2)) AS hypotenuse&#39;; PREPARE stmt2 FROM @s; SET @a = 6; SET @b = 8; EXECUTE stmt2 USING @a, @b;  结果：
+------------+ | hypotenuse | +------------+ | 10 | +------------+  最后：
DEALLOCATE PREPARE stmt2;  注意：
 你必须使用@variable，而不是声明的变量，对于FROM @s语句 PREPARE的主要用途是构造一种情况的查询（绑定但是还不能工作的），然后插入表名之后就可以执行  2. 修改表增加列 SET v_column_definition := CONCAT( v_column_name , &amp;quot; &amp;quot;, v_column_type , &#39; &#39;, v_column_options ); SET @stmt := CONCAT(&#39;ALTER TABLE ADD COLUMN &#39;, v_column_definition); PREPARE stmt FROM @stmt; EXECUTE stmt; DEALLOCATE PREPARE stmt;  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十二)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-32.html</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-32.html</guid>
      <description>全文搜索 MySQL提供有全文搜索。它在包含文本的列的表中搜索单词和短语的最佳匹配项。
1. 简单的全文搜索 SET @searchTerm = &#39;Database Programming&#39;; SELECT MATCH (Title) AGAINST (@searchTerm IN NATURAL LANGUAGE MODE) SCORE, ISBN, Author, Title FROM book WHERE MATCH (TITLE) AGAINST (@searchTerm IN NATURAL LANGUAGE MODE) ORDER BY MATCH (Titile) AGAINST (@searchTerm IN NATURAL LANGUAGE MODE) DESC;  有一个名叫book的表，这个表里面有ISBN, TITLE, Author这几个列。这个语句搜索匹配到Database Programming的记录。这首先显示匹配最好的记录。
想要这个正常工作的话，一个Title列的全文索引必须是有效的：
ALTER TABLE book ADD FULLTEXT INDEX Fulltext_title_index(Title);  2. 简单的布尔值搜索 SET @searchTerm = &#39;Database Programming =Java&#39;; SELECT MATCH (Title) AGAINST (@searchTerm IN BOOLEAN MODE) Score, ISBN, Author, Title FROM book WHERE MATCH (Title) AGAINST (@searchTerm IN BOOLEAN MODE) ORDER BY MATCH (Title) AGAINST (@searchTerm IN BOOLEAN MODE) DESC;  表名为book的表有ISBN, Title, Author，这将会搜索数据标题中有Database和Programming但是不包含Java的书籍。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十一)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-31.html</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-31.html</guid>
      <description>索引和键 1. 创建索引 -- 创建my_table中name列的索引 CREATE INDEX idx_name ON my_table(name);  2. 创建唯一索引 一个唯一索引用来避免在表中插入重复的数据。一个唯一索引的列可以插入多个NULL值(因为，默认情况下NULL是和其他值都不相同的，包括其他的NULL)。
-- 创建my_table表中name列的唯一索引 CREATE UNIQUE INDEX idex_name ON my_table(name);  3. AUTO_INCREMENT键 CREATE TABLE ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, ... PRIMARY KEY(id), ... );  主要注意点：
 从1开始并且自动增加1当你没有在INSERT语句中指定值，或者指定这个值为NULL 这个id一直都是和其他的不一样的，但是 不要对id进行假设(如没有间隙、连续生产、不重用等)，除了在任何时候都是唯一的。  细微注意点：
 当重启服务器的时候，&amp;rdquo;下一个&amp;rdquo;值就是MAX(id)+1这么计算的 如果在系统关闭或崩溃之前的最后一个操作是删除最大的id值，这个id可能被重用(这根据引擎决定)。所以，不要详细自增量永久是唯一的，它们只是在任何时刻是唯一的。 对弈多主机或集群解决方案，查看auto_increment_offset和auto_increment_increment 有些时候简单的使用INDEX(id)而不是PRIMARY KEY也是可以的。(这在某些情况下是有中性能提升) 使用AUTO_INCREMENT作为PARTITION key是很少有好处的，所以不要这么做 各种操作都可能&amp;rdquo;毁坏&amp;rdquo;值。这发送在当他们预分配的值，不要这么使用：INSERT IGNORE(使用重复键)，REPLACE(这等价于DELETE加上INSERT)，和其他的操作。ROLLBACK是另外造成id间隙的操作。 在主从复制过程中，不能信任ID以升序到达从服务器。尽管ID是按照练习顺序分配的，但是InnoDB是按照提交顺序发送到从系统的。  4. 创建组合索引 这将会在两个键上面创建联合索引，mystring和mydatetime，提升在这两个键上面的WHERE查询的速度。
CREATE INDEX idx_mmycol_myothercol ON my_table(mycol, myothercol);  注意：这个顺序是很重要的！如果在查下语句的WHERE条件中没有包含这两个列，那将会用到最左的索引。在这样的情况下，当查询的WHERE语句中包括mycol将会使用这个索引，一个查询包含myothercol将不会使用索引。详细信息查看这个blog。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三十)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-30.html</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-30.html</guid>
      <description>存储例程(程序和函数)    参数 详情     RETURNS 指定从函数返回的值的数据类型   RETURN RETURN后面实际的变量或值是调用函数返回的值    1. 带有IN OUT INOUT参数的存储过程 DELIMITER $$ DROP PROCEDURE IF EXISTS sp_nested_loop$$ CREATE PROCEDURE sp_nested_loop(IN i INT, IN j INT, OUT x INT, OUT y INT, INOUT z INT) BEGIN DECLARE a INTEGER DEFAULT 0; DECLARE b INTEGER DEFAULT 0; DECLARE c INTEGER DEFAULT 0; WHILE a &amp;lt; i DO WHILE b &amp;lt; j DO SET c = c + 1; SET b = b + 1; END WHILE; SET a = a + 1; SET b = 0; END WHILE; SET x = a, y = c; SET z = x + y + z; END $$ DELIMITER ;  调用这个存储过程：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十九)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-29.html</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-29.html</guid>
      <description>错误码 1. 1064：语法错误 SELECT LastName, FirstName, FROM Person;  返回信息：
 Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &amp;lsquo;from Person&amp;rsquo; at line 2.
 从MySQL获取&amp;rdquo;1064 error&amp;rdquo;的错误信息意味着查询有语法错误。换句话说，MySQL不能有效解析查询语句。
错误信息中引号包围的信息时MySQL指出的自己不知道如何解析的查询的最开始的位置。在这个例子中，MySQL在上下文中无法理解&amp;rdquo;from Person&amp;rdquo;。在这个例子中，是在from Person中有一个额外的逗号。这个逗号告诉MySQL在SELECT语句中需要另外的一个列。
一个语法错误通常是这样的结构… near &#39;…&#39;。引号包围的部分是离错误最近的地方。想要定位一个错误，查看引号包围部分的最开始部分和引号前面的最后的部分。
有时候，你会遇到… near &#39;&#39;，这时候，引号中没有任何东西。这意味着MySQL不能指出错误在语句的开始还是结束位置。这通常意味着查询语句包含不完整的引号(&amp;lsquo;或者&amp;rdquo;)，或者不完整的括号，或者之前没有正确终止该语句。
对于存储例程，你可能忘记使用DELIMITER。
所以，当你遇到了一个1064错误，查看查询语句，查看错误信息中指明的位置。检查错误信息说明位置周围的查询语句。
如果你寻找某些人来帮助你解决一个1064错误，最好提供完整的查询语句和错误信息内容。
2. 1175：安全更新 这个错误通常出现在你更新或删除表中的记录，但是没有包含一个条件WHERE语句。
想要不出现这个错误，可以修改下面的配置项：
SET SQL_SAFE_UPDATES = 0;  重新启用的话，输入下面的内容：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十八)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-28.html</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-28.html</guid>
      <description>MySQL表的锁 1. 行级锁 如果一个表是InnoDB引擎的，MySQL会自动使用行级锁，便于多个事务可以同时对一个表进行读写，而不用彼此等待。
如果两个事务视图修改同一个行并且两个事务都是用行级锁，那么一个事务需要等待另一个事务执行完毕。
也可以同通多对预期要修改的每一行使用SELECT … FRO UPDATE语句来获得。
假设有两个连接来详细介绍行级锁：
连接1
START TRANSACTION; SELECT ledgerAmount FROM accDetails WHERE id=1 FOR UPDATE:  在连接1中使用SELECT … FOR UPDATE来获取行级锁。
连接2
UPDATE accDetails SET ledgerAmount = ledgerAmount + 500 WHERE id=1;  但某些人在连接2中其他更新相同的行，将需要等待连接1事务执行完毕，或者达到innodb_lock_wait_timeout配置(默认的时间是50秒)的超时时间，出现一个错误。
 Error Code: 1205. Lock wait timeout exceeded; try restarting transaction  想要查看这个锁的详细信息，使用SHOW ENGINE INNODB STATUS。
---TRANSACTION 1973004, ACTIVE 7 sec updating mysql tables in use 1, locked 1 LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s) MySQL thread id 4, OS thread handle 0x7f996beac700, query id 30 localhost root update UPDATE accDetails SET ledgerAmount = ledgerAmount + 500 WHERE id=1 ------- TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:  连接2</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-27.html</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-27.html</guid>
      <description>删除表    参数 详情     TEMPORARY 可选。如果指定的话，只能使用DROP TABLE语句删除临时表   IF EXISTS 可选。如果指定，如果表不存在的话，DROP TABLE语句将不会报一个错误    1. 删除表 DROP TABLE可以用来删除数据库中的一个表。
创建表
创建一个名字为tbl的表，然后删除这个表。
CREATE TABLE tbl( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(100) NOT NULL, author VARCHAR(40) NOT NULL, submission_date DATE, PRIMARYY KEY (id) );  删除表
DROP TABLE tbl;   注意
删除表将会从数据库中删除表的全部信息，包括所有的信息，所以这个操作没法恢复。
 2. 从数据库删除表 DROP TABLE Database.table_name  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十六)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-26.html</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-26.html</guid>
      <description>更改表 1. 修改存储引擎;重建表;修改file_per_table 例如，如果一个表t1当前不是InnoDB表，下面的语句将会修改这个表的存储引擎为InnoDB：
ALTER TABLE t1 ENGINE=InnoDB;  如果这个表已经是InnoDB存储引擎了，这个语句将会重建表和索引，并且和OPTIMIZE TABLE的操作效果相同。你可能获取一些硬盘空间的改进。
如果innodb_file_per_table的值和t1构建时的值不同，就会将这个值转换为(或从)file_per_table。
2. 修改表的列 CREATE TABLE stackoverflow; USE stackoverflow; CREATE TABLE stack( id_user INT NOT NULL, usernaem VARCHAR(30) NOT NULL, password VARCHAR(30) NOT NULL ); ALTER TABLE stack ADD COLUMN submit date NOT NULL; -- 增加新列 ALTER TABLE stack DROP COLUMN submit; -- 删除列 ALTER TABLE stack MODIFY submit DATETIME NOT NULL; -- 修改列类型 ALTER TABLE stack CHANGE submit submit_date DATETIME NOT NULL; -- 修改列类型和名称 ALTER TABLE stachk ADD COLUMN mod_id INT NOT NULL AFTER id_user; -- 增加新列在存在的列之后  3.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十五)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-25.html</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-25.html</guid>
      <description>创建表 1. 创建表带有主键 CREATE TABLE Person ( PersonID INT UNSIGNED NOT NULL, LastName VARCHAR(66) NOT NULL, FirstName VARCHAR(66), Address VARCHAR(255), City VARCHAR(66), PRIMARY KEY (PersonID) );  一个主键就是一个NOT NULL的单独或者多列的标识符，这个标识符可以表示表中唯一的行。创建了一个索引，但是没有显示声明为非空的话，MySQL将会以静默和隐式的方式声明他们。
一个表只可以有一个PRIMARY KEY，并且每个表都推荐有一个。InnoDB将会在不存在的情况下创建一个(像MySQL文档中说明的)，尽管这是不可取的。
通常，一个AUTO_INCREMENT INT被认为是&amp;rdquo;代理键&amp;rdquo;，用于索引优化和其他表的关系。当添加新纪录的时候，这个列的值(通常)会从默认值1开始加1。
然而，尽管它的名字是这个，但是目的不是为了保证值是递增的，而是保证值是连续的和唯一的。
一个递增的INT并不会恢复默认的初始值，当这个表的行都被删除的时候。除非这个表被truncate处理了，使用TRUNCATE TABLE语句。
定义一列为主键(行内定义)
如果主键只是一个单独的列的话，可以在列定义的行中添加PRIMARY KEY：
CREATE TABLE Person ( PersonID INT UNSIGNED NOT NULL PRIMARY KEY, LastName VARCHAR(66) NOT NULL, FirstName Varchar(66), Address Varchar(255), City VARCHAR(66) );  这个命令的格式是简单并且易读的。
定义多列为主键
定义主键包含多个列也是可能的。可能会在关联外键关系的子表中这么做。多列主键是通过在单独的主键子句中列出参与列来定义的。这里行内定义就不行了，行内主键定义只能用于当个列。例如：
CREATE TABLE invoice_line_items( LineNum SMALLINT UNSIGNED NOT NULL, InvoiceNum INT UNSIGNED NOT NULL, --- 其他列 PRIMARY KEY (InvoiceNum, LineNum), FOREIGN KEY (InvoiceNum) REFERENCES -- 一个表属性的引用 );  注意：主键的列应该按照逻辑顺序指定，这可能和列的定义顺序不一样，就像上面的例子一样。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十四)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-24.html</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-24.html</guid>
      <description>视图    参数 详情     view_name 视图名称   SELECT 语句 要打包到视图中的SQL语句。它可以是一条SELECT语句，用于从一个或多个表中提取数据。    1. 创建视图 特权
CREATE VIEW语句需要视图的CREATE VIEW权限，以及SELECT语句选择的每一列的权限。对于SELECT语句中其他地方使用的列，必须具备SELECT权限。如果使用了OR REPLACE语句，你必须具有视图的DROP权限。依赖于DEFINER值，CREATE VIEW也需要SUPER权限，这在后面会说明。
当引用视图的时候，将会进行权限的检查。
一个视图是依赖于一个数据库的。默认情况下，一个新视图是在默认数据库上面创建的。想要显示在一个数据库上面创建视图，需要使用完整的数据库名。
例如：
db_name.view_name
mysql&amp;gt; CREATE VIEW test.v AS SELECT * FROM t;  注意：在一个数据库里面，基本的表和视图使用同一个命名空间，所以表和视图不能有相同的名字。
一个视图可以：
 可以从多种SELECT语句中创建 引用一个基本表或其他视图 使用join，union和子查询 SELECT甚至不需要引用任何表  另外的例子
下面的例子定义了一个视图，从另外的表中查询两个列表，和这两个列的计算表达式。
mysql&amp;gt; CREATE TABLE t(qty INT, price INT); mysql&amp;gt; INSERT INTO t VALUES(3, 50); mysql&amp;gt; CREATE VIEW v AS SELECT qty, price, qty * price AS value FROM t; mysql&amp;gt; SELECT * FROM v; +------+-------+-------+ | qty | price | value | +------+-------+-------+ | 3 | 50 | 150 | +------+-------+-------+  限制</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十三)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-23.html</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-23.html</guid>
      <description>正则表达式 正则表达式是为复杂搜索指定模式的一种强大方法。
REGEXP / RLIKE REGEXP或者别名RLIKE运算符允许基于正则表达式的模式匹配。
假设有下面的employee的表：
+-------------+-------------+-------------+--------------+----------+ | EMPLOYEE_ID | FIRST_NAME | LAST_NAME | PHONE_NUMBER | SALARY | +-------------+-------------+-------------+--------------+----------+ | 100 | Steven | King | 515.123.4567 | 24000.00 | | 101 | Neena | Kochhar | 515.123.4568 | 17000.00 | | 102 | Lex | De Haan | 515.123.4569 | 17000.00 | | 103 | Alexander | Hunold | 590.423.4567 | 9000.00 | | 104 | Bruce | Ernst | 590.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十二)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-22.html</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-22.html</guid>
      <description>处理时区 获取指定时区的当前日期和时间 获取本地时区的NOW()值，获取印度时区的值，获取UTC的值。
SELECT NOW(); SET time_zone=&#39;Asia/Kolkata&#39;; SELECT NOW(); SET time_zone=&#39;UTC&#39;; SELECT NOW();  转换存储的DATE或DATETIME值到另外的时区 如果你在表中的某个列中存储了DATE或DATETIME格式的时间值，这是相对于某个时区的值，但是在MySQL中，时区是没有和值存储在一起的。如果你想要把这个时间转换为另外时区的时间，你可以做，但是你必须知道原本的时区值。然后使用CONVERT_TZ()来实现这个转换过程。下面的例子显示把UTC的时区的时间转换为California的时区时间。
SELECT CONVERT_TZ(date_sold, &#39;UTC&#39;, &#39;America/Los_Angeles&#39;) date_sold_local FROM sales WHERE state_sold=&#39;CA&#39;;  获取TIMESTAMP值的指定时区值 这非常简单。所有TIMESTAMP的值都是世界时间值，只需要设置你想要显示的time_zone时区值，就可以了。
SET SESSION time_zone=&#39;America/Los_Angeles&#39;; SELECT timestamp_sold FROM sales WHERE state_sold=&#39;CA&#39;;  为什么是这样？TIMESTAMP的值是基于UNIX time_t数据格式的。这些UNIX的时间戳存的是从1970:01:01 00:00:00 UTC到现在的秒数。
注意：TIMESTAMP存储的是世界时间。DATE和DATETIME存储是依赖存储时的时区。
本地时区配置 每个服务器都有一个默认的全局时区配置，由服务器的拥有者设置。你可以使用下面的命令查看当前的时区配置：
SELECT @@time_zone  不幸的是，这将会返回SYSTEM，这表示MySQL的时区使用服务器系统的时区配置。
下面的查询队列(是的，这有些hack)，会在几分钟内返回服务器时区配置和UTC的偏移量。
CREATE TEMPORARY TABLE times (dt DATETIME, ts TIMESTAMP); SET time_zone = &#39;+0:00&#39;; INSERT INTO times VALUES(NOW(), NOW()); SET time_zone = &#39;SYSTEM&#39;; SELECT dt, ts, TIMESTAMPDIFF(MINUTE, dt, ts)offset FROM times; DROP TEMPORARY TABLE times;  这是怎么实现的呢？临时表里面的两列有不同的时间格式。DATETIME存储当地时间到表里面，TIMESTAMP存储UTC时间到表里面。所以当时区设置为UTC的时候，INSERT语句插入列个完全相同的日期/时间值。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十一)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-21.html</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-21.html</guid>
      <description>日期和时间运算 日期计算 NOW() + INTERVAL 1 DAY --明天的这个时间 CURDATE() - INTERVAL 4 DAY --4天之前的凌晨  线上3到10个小时之间（180分到600分之前）存储的mysql问题
SELECT qId,askDate,minuteDiff FROM ( SELECT qId,askDate TIMESTAMPDIFF(MINUTE, askDate, now()) as minuteDiff FROM questions_mysql ) xDerived WHERE minuteDiff BETWEEN 180 AND 600 ORDER BY qId DESC LIMIT 50; +----------+---------------------+------------+ | qId | askDate | minuteDiff | +----------+---------------------+------------+ | 38546828 | 2016-07-23 22:06:50 | 182 | | 38546733 | 2016-07-23 21:53:26 | 195 | | 38546707 | 2016-07-23 21:48:46 | 200 | | 38546687 | 2016-07-23 21:45:26 | 203 | | .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二十)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-20.html</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-20.html</guid>
      <description>字符串运算符    名称 描述     ASCII() 返回最左侧字符的数值   BIN() 返回包含数字的二进制表示的字符串   BIT_LENGTH() 返回以位为单位的参数长度   CHAR() 返回整数参数对应的字符   CHAR_LENGTH() 返回参数中的字符数量   CONCAT() 返回拼接的字符串   CONCAT_WS() 返回指定分隔符拼接的字符串   ELT() 返回指定索引位置的字符串   EXPORT_SET() 返回一个字符串，使得对于值位中设置的每个位，您获得一个on字符串，并且对于每个未设置的位，您将获得一个off字符串   FIELD() 返回第一个参数在随后参数中的索引位置   FIELD_IN_SET() 返回第一个参数在第二个参数中的索引位置   FORMAT() 返回一个指定数量小数位格式化的数字   FROM_BASE64() 解码一个base64字符串并且返回结果   HEX() 返回十进制或字符串的十六进制表示   INSERT() 在指定位置插入一个子字符串，最多可插入指定的字符数   INSTR() 返回子字符串第一次出现的位置   LCASE() LOWER()的别名   LEFT() 返回指定的最左边的字符数   LENGH() 返回字符串的字节数量   LIKE 简单的模式匹配   LOAD_FILE() 加载命名的文件   LOCATE() 返回子串第一次初夏你的位置   LOWER() 返回参数的小写格式   LPAD() 返回字符串参数，用指定的字符串左填充   LTRIM() 删除前导空格   MAKE_SET() 返回一组逗号分隔的字符串，这些字符串在位集中具有相应的位   MATCH 全文本搜索   MID() 返回指定位置开始的子字符串   NOT LIKE 简单模式匹配的否定   NOT REGEXP 正则表达式的否定   OCT() 返回包含数字的八进制表示形式的字符串   OCT_LENGTH() LENGTH()方法的别名   ORD() 返回参数最左边的字符的字符代码   POSITION() LOCATE()的别名   QUOTE() 对SQL中的参数进行转义   REGEXP 正则表达式模式   REPEAT() 重复一个字符串指定的次数   REPLACE() 替换指定字符串的出现次数   REVERSE() 反转一个字符串的字符   RIGHT() 返回字符串指定最右边的值   RILIKE REGEXP 的别名   RPAD() 附加字符串指定的次数   RTRIM() 移除尾部的空格   SOUNDEX() 返回Soundex字符串   SOUNDS LIKE 比较读音   SPACE() 返回指定空格数的字符串   STRCMP() 比较两个字符串   SUBSTR() 返回指定的子字符串   SUBSTRING() 返回指定的子字符串   SUBSTRING_INDEX() 在指定的分隔符出现次数之前从字符串返回子字符串   TO_BASE64() 将参数转换为base64位字符串   TRIM() 移除开头和末尾的字符串   UCASE() UPPER()的别名   UNHEX() 返回一个包含数字十六进制表示的字符串   UPPER() 返回参数的大写格式   WEIGHT_STRING() 返回字符串的权重字符串    LENGTH() 返回字符串的字节数量。因为字符串的字符可能编码超过一个字节，所以想要获取字符的数量使用CHAR_LENGTH()。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十九)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-19.html</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-19.html</guid>
      <description>算术 算术运算符 MySQL提供了下面的算术运算符。
   运算符 名称 例子     + 加法 SELECT 3+5; -&amp;gt; 8 SELECT 3.5+5.5 -&amp;gt; 9.0 SELECT 3.5 + 2 -&amp;gt; 5.5   - 减法 SELECT 3 - 5; -&amp;gt; -2   * 乘法 SELECT 3 * 5; -&amp;gt; 15   / 除法 SELECT 20 / 4; -&amp;gt; 5 SELECT 355 / 133; -&amp;gt; 3.1416 SELECT 10.0 / 0; -&amp;gt; NULL   DIV 整除 SELECT 5 DIV 2; -&amp;gt; 2   % 或者 MOD 取余 SELECT 7 % 3; -&amp;gt; 1 SELECT 15 MOD 4; -&amp;gt; 3 SELECT 15 MOD -4; -&amp;gt; 3 SELECT -15 MOD 4; -&amp;gt; -3 SELECT -15 MOD -4; -&amp;gt; -3 SELECT 3 MOD 2.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十八)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-18.html</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-18.html</guid>
      <description>UNION 使用UNION组合SELECT语句 你可以使用UNION来组合两个结果相同的查询的结果。
例如，你想要两个独立表的所有联系信息，authors和editors，你可以使用UNION关键字：
SELECT name, email, phone_number FROM authors UNION SELECT name, email, phone_number FROM editors;  使用UNION将会自动过滤重复信息。如果你想要保留重复信息，你可以使用UNION ALL。
组合不同列的数据 SELECT name. caption as title, year, pages FROM books UNION SELECT name. title, year, 0 as pages FROM movies;  将两个不同列的记录集组合时，使用默认值模拟确实的列。
ORDER BY 如果你需要排序UNION之后的结果集，使用下面的语法：
( SELECT ... ) UNION ( SELECT ... ) ORDER BY  如果没有添加括号的话，ORDER BY语句将会添加到最后的SELECT语句上面。
OFFSET分页 当在UNION上添加LIMIT的时候，下面这个语法可以使用:
( SELECT ... ORDER BY x LIMIT 10 ) UNION ( SELECT .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/mysql-section-17.html</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/mysql-section-17.html</guid>
      <description>JOIN表带有相同列 join 3个带有相同列的表 CREATE TABLE Table1 ( id INT UNSIGNED NOT NULL, created_on DATE NOT NULL, PRIMARY KEY (id) ) CREATE TABLE Table2 ( id INT UNSIGNED NOT NULL, personName VARCHAR(255) NOT NULL, PRIMARY KEY (id) ) CREATE TABLE Table3 ( id INT UNSIGNED NOT NULL, accountName VARCHAR(255) NOT NULL, PRIMARY KEY (id) )  在建表之后，你就可以使用一个查询语句从三个表中寻找具有相同名称的id：
SELECT t1.id AS table1Id, t2.id AS table2Id, t3.id AS table3Id FROM Table1 t1 LEFT JOIN Table2 t2 ON t2.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-16.html</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-16.html</guid>
      <description>JOIN JOIN可视化效果 如果您是一个面向视觉的人，这个venn图可以帮助您理解MySQL中存在的不同类型的连接。
与子查询join(&amp;ldquo;派生&amp;rdquo;表) SELECT x,... FROM ( SELECT y, ... FROM ...) AS a JOIN tbl ON tbl.x = a.y WHERE ...  这将会执行一个子查询放入一个临时表，然后join这个临时tbl。
在5.6之前，临时表上面不能有索引，因此这可能是非常低效：
SELECT ... FROM ( SELECT y, ... FROM ... ) AS a JOIN ( SELECT x, ... FROM ... ) AS b WHERE ...  在5.6，优化器可以计算出最好的索引然后在运行中创建它(这会有一些开销，所以仍然不是&amp;rdquo;完美的&amp;rdquo;)。
另外通用的方式是在子查询中创建一些东西：
SELECT @n := @n + 1, ... FROM ( SELECT @n:=0 ) AS initialize JOIn the_real_table ORDER BY .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-15.html</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-15.html</guid>
      <description>ERROR 1055 最新版本的MySQL开始为之前的一些查询产生1055的错误。这个主题就是来介绍一下这样的错误。MySQL团队一直在努力让GROUP BY的扩展失效，或者至少让开发人员便于编写这样的查询。
无用GROUP BY返回不可预测的结果：墨菲定律 SELECT item.item_id, users.category, COUNT(*) number_of_uses FROM item JOIN uses ON item.item_id = uses.item_id GROUP item.item_id  将会显示 item表的行，并且显示表uses中关联的行数。也会显示uses.category中的值。
这个查询在(ONLY_FULL_GROUP_BY标识出现之前)MySQL中可以执行。这里使用了非标准的GROUP BY。
但是这有个问题：如果在JOIN语句的ON条件中匹配到了多个uses记录，那么MySQL将会从这些记录中返回一行的category字段值。哪一条？查询优化器，应用的用户都不能提前知道。准确的说：结果是不可预期的。MySQL将会返回任何想要返回的值。
*不可预期就是随机的*，有一个显著的区别。有人希望每次都有一个随机的选择。因此，如果一个选择的随机的，你可以在调试或测试中观察到这个情况。不可预期的结果是坏的：MySQL每次返回相同的结果，知道不相同了。有时候在新版本的MySQL中会有不同的结果。有时候这是导致问题的增长的表。什么会出问题，什么将会出问题，什么时候出问题你不知道。这叫做墨菲定律。
MySQL团队在努力让开发者更难犯这个错误。新版本的MySQL有一个叫做ONLY_GROUP_BY的sql_mod标签。当这个标识设置了，MySQL将会返回一个1055错误， 拒绝运行这个查询。
无用SELECT * ，如果修复 有时候有一个像下面这样的查询，在SELECT中使用*：
SELECT item.*, COUNT(*) number_of_uses FROM item JOIN uses ON item.item_id = uses.item_id GROUP BY item.item_id  当设置了ONLY_FULL_GROUP_BY，这样的查询就需要优化了。
要做优化的话，需要使用一个带有GROUP BY子句的子查询，让这个子查询返回每个item_id对应的number_of_uses字段。这个子查询很短也很简洁，因为它只需要查询uses表。
SELECT item_id, COUNT(*) number_of_uses FROM uses GROUP BY item_id;  然后我们和item表一起使用这个子查询：
SELECT item.*,usecount.number_of_uses FROM item JOIN ( SELECT item_id, COUNT(*) number_of_uses FROM uses GROUP BY item_id ) usecount ON item_item_id = usecount.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-14.html</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-14.html</guid>
      <description>GROUP BY    参数 详情     expression1, expression2,&amp;hellip;expression_n 没有包含在聚合函数中的表达式必须是GROUP BY中的表达式   aggregate_function 像SUM COUNT MIN MAX 或者 AVG这样的函数   tables 你希望获取数据的表。在FROM语句中至少包含一个表   WHERE condition 可选的。要选择的记录必须满足的条件。    HAVING SELECT department, COUNT(*) AS &amp;quot;Man_Power&amp;quot; FROM employees GROUP BY department HAVING COUNT(*) &amp;gt;= 10;  使用GROUP BY … HAVING来过滤聚合记录类似于使用SELECT … WHERE过滤单个记录。
你也可以使用HAVING Man_Power &amp;gt;= 10因为在HAVING已经能够理解这些别名。
GROUP_CONCAT GROUP_CONCAT用来拼接表达式的值，而不是每个列一个结果。这意味着选择的多列会把作为一列返回&amp;rdquo;Name(1):Score(*)&amp;ldquo;。
Name Score Adam A+ Adam A- Adam B Adam C+ Bill D- John A- SELECT Name, GROUP_CONCAT(Score ORDER BY Score DESC SEPERATOR &amp;quot; &amp;quot;) AS Grades FROM Grade GROUP BY Name  结果</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十三)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-13.html</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-13.html</guid>
      <description>ORDER BY 语境 下面的SELECT语句包含指定的顺序：
SELECT ... FROM ... WHERE ... GROUP by ... HAVING ... ORDER BY ... LIMIT ... OFFSET ...; (SELECT ... )UNION ( SELECT ... ) ORDER BY ... --排序union之后的结果 SELECT ... GROUP_CONCAT(DISTINCT x ORDER BY ... SEPARATOR ... ) ... ALTER TABLE ... ORDER BY ... -- 对MyISAM可能有用，对InnoDB无  基础用法 ORDER BY x
x可以是任何数据类型
 NULL比非NULL值优先 默认是ASC，升序 字符串(VARCHAR等)按照定义时的COLLATION来排序 ENUM按照定义时的顺序排序  升序/降序 ORDER BY x ASC -- 和默认行为一样 ORDER BY x DESC --降序 ORDER BY lastname,firstname --两列排序 ORDER BY submit_date DESC --最新的 ORDER BY submit_date DESC, id ASC -   ASC = Ascending DESC=Descending NULL首先出现，即使是降序 在上面的例子中，增加索引 INDEX(x) INDEX(lastname, firstname) INDEX(submit_date)可以提升性能  一些技巧 ORDER BY FIND_IN_SET(card_type, &amp;quot;MASTER-CARD, VISA, DISCOVER&amp;quot;) -- MASTER-CARD先 ORDER x IS NULL, x -- 按照x排序，NULL放最后  自定义排序</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十二)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-12.html</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-12.html</guid>
      <description>UPDATE JOIN语句更新 考虑有一个生存表叫做questions_mysql和一个表示批量导入CSV数据的最后一个记录iwtQuestions使用LOAD_DATA_INFILE。工作表在导入前被截断，数据被导入，并且这个过程在这里不显示。
更新生产表数据使用一个和导入数据表的join语句。
UPDATE questions_mysql q JOIN iwtQuestions i ON i.qId = q.qId SET q.closeVotes = i.closeVotes, q.votes = i.votes, q.answers = i.answers, q.views = i.views;  这里别名q和i是变量使用表名的简写。这简化开发和可读性。
主键qId代表题目id。这里join匹配的四个列会被更新。
基本更新 更新一行
UPDATE customers SET email=&#39;luke_smith@email.com&#39; WHERE id=1;  这个查询语句更新customers表中id为1的记录的email字段的内容，这里修改为luke_smith@email.com。数据表中老内容和新内容在下面显示了：
更新所有行
UPDATE customers SET lastname=&#39;smith&#39;;  这个查询更新customers表中所有记录的lastname字段为smith。下面是老内容和新内容的对比：
注意：在UPDATE语句中使用WHERE是很必要的。如果你没有使用条件语句的话，表中所有记录都会被更新。在上面例子中customers表中所有记录的lastname都更新为smith。
批量更新 使用不同的值更新多行时，可以使用批量更新：
UPDATE people SET name = (CASE id WHEN 1 THEN &#39;Karl&#39; WHEN 2 THEN &#39;Tom&#39; WHEN 3 THEN &#39;Mary&#39; END) WHERE id IN (1, 2, 3);  这里使用一条查询更新多条记录而不是每行使用一条查询。这个CASE语句需要包含WHERE语句中的所有制。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十一)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-11.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-11.html</guid>
      <description>DELETE    参数 详情     LOW_PRIORITY 如果提供了LOW_PRIORITY，删除操作只有在没有其他进程从数据表上读取数据的时候才会执行   IGNORE 如果提供了IGNORE，任何删除时遇到的错误都将忽略   table 你想要删除记录的表   WHERE conditions 指定要删除数据的条件表达式。如果没有指定条件的话，所有的表记录都会被删除。   ORDER BY expression 如果提供了ORDER BY，将会按照顺序删除记录   LIMIT 控制删除的最大记录数量。提供的number_rows将会被删除。    多表删除 MySQL的DELETE语句可以用于JOIN语句，允许指定需要删除的表。这用来避免嵌套语句很有用。下面是一个表：
create table people ( id int primary key, name varchar(100) not null, gender char(1) not null ); insert into people(id, name, gender) values (1, &#39;Kathy&#39;, &#39;f&#39;),(2, &#39;John&#39;, &#39;m&#39;),(3,&#39;Paul&#39;,&#39;m&#39;),(4,&#39;Kim&#39;,&#39;f&#39;); create table pets ( id int auto_increment primary key, ownerId int not null, name varchar(100) not null, color varchar(100) not null ); insert into pets(ownerId, name, color) values (1, &#39;Rover&#39;, &#39;beige&#39;), (2, &#39;Bubbles&#39;, &#39;purple&#39;), (3, &#39;Spot&#39;, &#39;black and white&#39;), (1, &#39;Rover2&#39;, &#39;white&#39;); id name gender 1 Kathy f 2 John m 3 Paul m 4 Kim f id ownerId name color 1 1 Rover beige 2 2 Bubbles purple 3 3 black and white 4 1 Rover2 white  如果你想要删除Paul的宠物：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-10.html</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-10.html</guid>
      <description>INSERT ON DUPLICATE KEY UPDATE INSERT INTO `table_name` (`index_field`, `other_field_1`, `other_filed_2`) VALUES (`index_value`, `insert_value`, `other_value`) ON DUPLICATE KEY UPDATE `other_field_1` = &#39;update_value&#39;, `other_field_2` = VALUES(`other_field_2`);  这将会在table_name中插入指定的值，但是当唯一键存在的时候，将会更新other_field_1的值为一个新值。
有时候，但重复主键时使用VALUES()来获取原本的值，而不是更新为一个新值。这种方式下，你可以使用INSERT和UPDATE设置不同的值。在上面的例子中，other_field_1在INSERT的时候设置为insert_value或者在UPDATE的时候设置为update_value。但是other_field_2将一直设置为other_value。
对于插入重复Key更新(IODKU)工作的至关重要的一样就是表 包含唯一的键，这将会是造成重复的原因。这个唯一的键可以是主键，也可以不是。它可以是单列的唯一键，也可以是多了的组合键。
插入多个行 INSERT INTO `my_table` (`field_1`, `field_2`) VALUES (&#39;data_1&#39;, &#39;data_2&#39;), (&#39;data_1&#39;, &#39;data_3&#39;), (&#39;data_4&#39;, &#39;data_5&#39;);  这是一次性添加多条记录的INSERT语句。
这种匹配插入数据的操作比一条一条的插入数据快的多。特别是一次插入100条数据是单条数据插入的10倍。
忽略已存在的行
在插入大行数据集时，在某些情况下，最好跳过通常由于列限制(如重复主键)而导致插入失败的情况。这可以通过INSERT IGNORE来实现这个功能。
假设有下面这样的数据：
SELECT * FROM `people`; --- Produces: +----+------+ | id | name | +----+------+ | 1 | john | | 2 | anna | +----+------+ INSERT IGNORE INTO `people` (`id`, `name`) VALUES (&#39;2&#39;, &#39;anna&#39;), -- 没有IGNORE的话，这行将会产生错误 (&#39;3&#39;， &#39;mike&#39;); SELECT * FROM `people`; --- Produces: +----+--------+ | id | name | +----+--------+ | 1 | john | | 2 | anna | | 3 | mike | +----+--------+  最重要的事是记住INSERT IGNORE也会静静的跳过那些错误，下面是MySQL文档的说明：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(九)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-09.html</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-09.html</guid>
      <description>MySQL的注释 增加注释 有多种类型的注释：
# 注释到行尾 -- 注释到行尾 /* 注释符号内部 */ /* 多行注释 */  例子：
SELECT * FROM t1; --这是一个注释 CREATE TABLE stack ( /* username varchar(30), */ id int );  —符号要求在符号后面，注释前面有一个空格，否则将认为是一个命令，并且引发一个错误。
#注释正常 /*注释正常*/ --注释错误  表定义注释 CREATE TABLE menagerie.bird( bird_id INT NOT NULL AUTO_INCREMENT, species VARCHAR(300) DEFAULT NULL COMMENT &#39;字段注释&#39;, INDEX idx_species(species) COMMENT &#39;索引&#39;， PRIMARY KEY (bird_id) ) ENGINE=InnoDB COMMENT &amp;quot;表注释&amp;quot;;  在COMMENT后面添加一个=是可选的。查看手册。
这些注释不像其他的注释，保存在schema中，可以使用SHOW CREATE TABLE或从information_schema中获取。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(八)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-08.html</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-08.html</guid>
      <description>变量 设置变量 有一些方法来设置变量：
 可以使用SET将变量设置为特定的、字符串、数字和日期  SET @var_string = &amp;quot;my_var&amp;quot;; SET @var_num = &#39;2&#39;; SET @var_date = &#39;2015-07-20&#39;;   你可以使用下面的方法设置变量为select语句的结果：  Select @var := &#39;123&#39;; (注意：当你没有使用SET设置变量的时候，你需要使用:=，因为在其他的语句(select, update)中，&amp;quot;=&amp;quot;是用来比较的，所以当你在等号前面增加一个冒号的时候，这表明这不是一个比较语句，而是一个SET语句)   你可以使用INTO设置一个变量作为select语句的返回值  (当我需要动态选择要查询的分区时，这是特别有用的)
SET @start_date = &#39;2015-07-20&#39;; SET @end_date = &#39;2016-01-31&#39;; #这获取年月来确定使用的分区 SET @start_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @start_date)); SET @end_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @end_date)); #把分区放入变量 SELECT GROUP_CONCAT(partition_name) FROME information_schema.partitions p WHERE table_name=&#39;partitioned_table&#39; AND SUBSTRING_INDEX(partition_name, &#39;P&#39;, -1) BETWEEN @start_yearmonth AND @end_yearmonth INTO @partitions; #把查询放入变量。因为MySQL不会把我们的变量任务是一个变量，所有我们需要拼接语句并执行这个语句 SET @query = CONCAT(&#39;CREATE TABLE part_of_partitioned_table(PRIMARY KEY(id)) SELECT partitioned_table.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(七)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-07.html</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-07.html</guid>
      <description>创建数据库    参数 详情     CREATE DATABASE 创建一个指定名称的数据库   CREATE SHEMA CREATE DATABASE 的别名   IF NOT EXISTS 如果指定的数据库存在的话，使用这个语句避免出现错误   create_specification create_specification指定的数据库的特征：像CHARACTER SET和COLLATE(数据库排序特征)    创建数据库，用户和授权 创建数据库。注意可以使用别名SCHEMA。
CREATE DATABASE Baseball; --创建名称为Baseball的数据库  如果数据库已经存在了，将会返回错误1007。想要避免这个错误，使用：
CREATE DATABASE IF NOT EXISTS Baseball;  相似的：
DROP DATABASE IF EXISTS Baseball; --当数据库存在时删除数据库 DROP DATABASE xyzl; --数据库如果不存在，返回1008错误  因为可以存在上面的错误，所以DDL语句通常和IF EXISTS一起使用。
用户创建数据库时，可以同时设置默认的字符集和排序规则，例如：
CREATE DATABASE Baseball CHARACTER SET utf8 COLLATE utf8_general_ci; SHOW CREATE TABLE Baseball; +----------+-------------------------------------------------------------------+ | Database | Create Database | +----------+-------------------------------------------------------------------+ | Baseball | CREATE DATABASE `Baseball` /*!</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-06.html</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-06.html</guid>
      <description>Limit和Offset Limit和Offset的关系 假设有下面这样的users表：
   id username     1 User1   2 User2   3 User3   4 User4   5 User5    为了限制SELECT查询中返回的结果集数量，可以使用LIMIT语句加上一个或两个整数作为参数(0也可以)。
LIMIT语句一个参数
当只提供了一个参数，这将只会限制返回的行数：
SELECT * FROM users ORDER BY id ASC LIMIT 2; id username 1 User1 2 User2  如果参数是0的话，将会返回0个值。
还需要注意，这里ORDER BY语句是很重要的，用来指定第一行的结果(当按照另一列排序时)。
LIMIT使用两个参数
当LIMIT语句使用两个参数时：
 第一个参数表示从结果集中显示的行-这个值通常是offset，因为这个值表示受约束结果集的开始之前的行。这个值允许是0，表示非约束结果集的第一行。 第二个参数表示结果集要显示的最大结果数量。  查看下面的查询：
SELECT * FROM users ORDER BY id ASC LIMIT 2,3; id username 3 User3 4 User4 5 User5  注意当第一个参数为0时，这个结果集等价于只传入了一个参数。这意味着下面两个语句由相同的结果：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-05.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-05.html</guid>
      <description>NULL NULL的使用  不知道的数据：像end_date，rating 可选的数据：像middle_initial(尽管空字符是更加合适的) 0/0：某些运算的结果，像0除以0 NULL不等于空字符&amp;rdquo;&amp;ldquo;或者0 其他？  验证NULL  IS NULL或IS NOT NULL：= NULL将不会像你预期的一样 x &amp;lt;=&amp;gt; y是一种&amp;rdquo;null安全&amp;rdquo;的比较  在LEFT JOIN语句中检查a中的行在b中没有合适的行对应。
SELECT ... FROM a LEFT JOIN b ON ... WHERE b.id IS NULL:  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-04.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-04.html</guid>
      <description>倒引号 倒引号用法 有很多例子在查询中使用倒引号，但是还是有很多人不清楚在什么时候或什么地方使用倒引号`。
倒引号主要用于防止一个调用&amp;rdquo;MySQL保留字&amp;rdquo;的错误。当你使用PHPmyAdmin创建一个表的时候，可能会遇到一个警告或提示：你正在使用MySQL的保留字。
例如，你创建一个包含字段&amp;rdquo;group&amp;rdquo;的表，你会遇到这个警告。这是因为你可能会使用下面的查询：
SELECT student_name, AVG(test_score) FROM student GROUP BY group;  为了确保你的查询不会出现错误，你可以在关键字上面增加倒引号：
SELECT student_name, AVG(test_score) FROM student GROUP BY `group`;  表
不仅仅列名需要添加倒引号，表名也需要添加倒引号。例如，当你需要JOIN多个表的时候：
SELECT `users`.`username`, `groups`.`group` FROM `users`;  易于阅读
正如你看到的，在表名或列表两边添加倒引号，也让查询更加容易阅读。
例如当你在书写全是小写时的查询时：
select student_name, AVG(test_score) from student group by group select `student_name`, AVG(`test_score`) from `student` group by `group`  查看MySQL关键字和保留字的手册。带有(R)标识的是保留字。其他的都是关键字。保留字需要特别小心。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-03.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-03.html</guid>
      <description>SELECT SELECT语句用来从一个或多个表中获取搜索到的行。
DISTINCT 在SELECT后面添加DISTINCT表示删除重复的行。
CREATE TABLE `car` ( `car_id` INT UNSIGNED NOT NULL PRIMARY KEY, `name` VARCHAR(20), `price` DECIMAL(8,2) ); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (1, &#39;Audi A1&#39;, &#39;20000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (2, &#39;Audi A1&#39;, &#39;15000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (3, &#39;Audi A2&#39;, &#39;40000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (4, &#39;Audi A2&#39;, &#39;40000&#39;); SELECT DISTINCT `name`, `price` FROM CAR; ----------------- name | price Audi A1 | 20000.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-02.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-02.html</guid>
      <description>数据格式 CHAR(n) CHAR(n)是包含固定长度的n个字符的字符串。如果CHARACTER SET utf8mb4，这意味着它完全占用4个字节，不管里面包含什么文本。
大多数使用情况下CHAR(n)处理包含英文字符的字符串，因此应该设置ascii字符集(latin1也可以)。
country_code CHAR(2) CHARACTER SET ascii, postal_code CHAR(6) CHARACTER SET ascii, uuid CHAR(39) CHARACTER SET ascii, -- more discussion elsewhere  DATE DATETIME TIMESTAMP YEAR TIME DATE处理日期不包含时间部分。格式是&#39;YYYY-MM-DD&#39;，范围是1000-01-01到9999-12-31。
DATETIME是包含时间的日期格式&#39;YYYY-MM-DD HH:MM:SS&#39;。范围是1000-01-01 00:00:00到9999-12-31 23:59:59。
TIMESTAMP是整数类型的时间格式，包括日期和时间两部分。使用的范围是1970-01-01 00:00:01到2038-01-19 03:14:07 UTC (使用4个字节)
YEAR表示年份，范围从1901到2155(使用1个字节)
TIME表示一个&amp;rsquo;HH:MM:SS&amp;rsquo;格式的时间。范围从-838:59:59到838:59:59。
存储大小：
   数据类型 MySQL5.6.4之前 MySQL5.6.4及之后     YEAR 1字节 1字节   DATE 3字节 3字节   TIME 3字节 3字节+分数秒存储   DATETIME 8字节 5字节+分数秒存储   TIMESTAMP 4字节 4字节+分数秒存储    分数秒(5.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(一)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/mysql-section-01.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/mysql-section-01.html</guid>
      <description>开始学习MySQL 版本历史
   1.0 1995-05-23     3.19 1996-12-01   3.20 1997-01-01   3.21 1998-10-01   3.22 1999-10-01   3.23 2001-01-22   4.0 2003-03-01   4.1 2004-10-01   5.0 2005-10-01   5.1 2008-11-27   5.5 2010-11-01   5.6 2013-02-01   5.7 2015-10-01    开始 创建MySQL数据库 CREATE DATABASE mydb;  返回：
 Query OK, 1 row affected (0.</description>
    </item>
    
  </channel>
</rss>