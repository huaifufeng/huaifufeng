<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 24 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL专业笔记(十)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-10.html</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-10.html</guid>
      <description>INSERT ON DUPLICATE KEY UPDATE INSERT INTO `table_name` (`index_field`, `other_field_1`, `other_filed_2`) VALUES (`index_value`, `insert_value`, `other_value`) ON DUPLICATE KEY UPDATE `other_field_1` = &#39;update_value&#39;, `other_field_2` = VALUES(`other_field_2`);  这将会在table_name中插入指定的值，但是当唯一键存在的时候，将会更新other_field_1的值为一个新值。
有时候，但重复主键时使用VALUES()来获取原本的值，而不是更新为一个新值。这种方式下，你可以使用INSERT和UPDATE设置不同的值。在上面的例子中，other_field_1在INSERT的时候设置为insert_value或者在UPDATE的时候设置为update_value。但是other_field_2将一直设置为other_value。
对于插入重复Key更新(IODKU)工作的至关重要的一样就是表 包含唯一的键，这将会是造成重复的原因。这个唯一的键可以是主键，也可以不是。它可以是单列的唯一键，也可以是多了的组合键。
插入多个行 INSERT INTO `my_table` (`field_1`, `field_2`) VALUES (&#39;data_1&#39;, &#39;data_2&#39;), (&#39;data_1&#39;, &#39;data_3&#39;), (&#39;data_4&#39;, &#39;data_5&#39;);  这是一次性添加多条记录的INSERT语句。
这种匹配插入数据的操作比一条一条的插入数据快的多。特别是一次插入100条数据是单条数据插入的10倍。
忽略已存在的行
在插入大行数据集时，在某些情况下，最好跳过通常由于列限制(如重复主键)而导致插入失败的情况。这可以通过INSERT IGNORE来实现这个功能。
假设有下面这样的数据：
SELECT * FROM `people`; --- Produces: +----+------+ | id | name | +----+------+ | 1 | john | | 2 | anna | +----+------+ INSERT IGNORE INTO `people` (`id`, `name`) VALUES (&#39;2&#39;, &#39;anna&#39;), -- 没有IGNORE的话，这行将会产生错误 (&#39;3&#39;， &#39;mike&#39;); SELECT * FROM `people`; --- Produces: +----+--------+ | id | name | +----+--------+ | 1 | john | | 2 | anna | | 3 | mike | +----+--------+  最重要的事是记住INSERT IGNORE也会静静的跳过那些错误，下面是MySQL文档的说明：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(九)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-09.html</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-09.html</guid>
      <description>MySQL的注释 增加注释 有多种类型的注释：
# 注释到行尾 -- 注释到行尾 /* 注释符号内部 */ /* 多行注释 */  例子：
SELECT * FROM t1; --这是一个注释 CREATE TABLE stack ( /* username varchar(30), */ id int );  —符号要求在符号后面，注释前面有一个空格，否则将认为是一个命令，并且引发一个错误。
#注释正常 /*注释正常*/ --注释错误  表定义注释 CREATE TABLE menagerie.bird( bird_id INT NOT NULL AUTO_INCREMENT, species VARCHAR(300) DEFAULT NULL COMMENT &#39;字段注释&#39;, INDEX idx_species(species) COMMENT &#39;索引&#39;， PRIMARY KEY (bird_id) ) ENGINE=InnoDB COMMENT &amp;quot;表注释&amp;quot;;  在COMMENT后面添加一个=是可选的。查看手册。
这些注释不像其他的注释，保存在schema中，可以使用SHOW CREATE TABLE或从information_schema中获取。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(八)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-08.html</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-08.html</guid>
      <description>变量 设置变量 有一些方法来设置变量：
 可以使用SET将变量设置为特定的、字符串、数字和日期  SET @var_string = &amp;quot;my_var&amp;quot;; SET @var_num = &#39;2&#39;; SET @var_date = &#39;2015-07-20&#39;;   你可以使用下面的方法设置变量为select语句的结果：  Select @var := &#39;123&#39;; (注意：当你没有使用SET设置变量的时候，你需要使用:=，因为在其他的语句(select, update)中，&amp;quot;=&amp;quot;是用来比较的，所以当你在等号前面增加一个冒号的时候，这表明这不是一个比较语句，而是一个SET语句)   你可以使用INTO设置一个变量作为select语句的返回值  (当我需要动态选择要查询的分区时，这是特别有用的)
SET @start_date = &#39;2015-07-20&#39;; SET @end_date = &#39;2016-01-31&#39;; #这获取年月来确定使用的分区 SET @start_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @start_date)); SET @end_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @end_date)); #把分区放入变量 SELECT GROUP_CONCAT(partition_name) FROME information_schema.partitions p WHERE table_name=&#39;partitioned_table&#39; AND SUBSTRING_INDEX(partition_name, &#39;P&#39;, -1) BETWEEN @start_yearmonth AND @end_yearmonth INTO @partitions; #把查询放入变量。因为MySQL不会把我们的变量任务是一个变量，所有我们需要拼接语句并执行这个语句 SET @query = CONCAT(&#39;CREATE TABLE part_of_partitioned_table(PRIMARY KEY(id)) SELECT partitioned_table.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(七)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-07.html</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-07.html</guid>
      <description>创建数据库    参数 详情     CREATE DATABASE 创建一个指定名称的数据库   CREATE SHEMA CREATE DATABASE 的别名   IF NOT EXISTS 如果指定的数据库存在的话，使用这个语句避免出现错误   create_specification create_specification指定的数据库的特征：像CHARACTER SET和COLLATE(数据库排序特征)    创建数据库，用户和授权 创建数据库。注意可以使用别名SCHEMA。
CREATE DATABASE Baseball; --创建名称为Baseball的数据库  如果数据库已经存在了，将会返回错误1007。想要避免这个错误，使用：
CREATE DATABASE IF NOT EXISTS Baseball;  相似的：
DROP DATABASE IF EXISTS Baseball; --当数据库存在时删除数据库 DROP DATABASE xyzl; --数据库如果不存在，返回1008错误  因为可以存在上面的错误，所以DDL语句通常和IF EXISTS一起使用。
用户创建数据库时，可以同时设置默认的字符集和排序规则，例如：
CREATE DATABASE Baseball CHARACTER SET utf8 COLLATE utf8_general_ci; SHOW CREATE TABLE Baseball; +----------+-------------------------------------------------------------------+ | Database | Create Database | +----------+-------------------------------------------------------------------+ | Baseball | CREATE DATABASE `Baseball` /*!</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-06.html</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-06.html</guid>
      <description>Limit和Offset Limit和Offset的关系 假设有下面这样的users表：
   id username     1 User1   2 User2   3 User3   4 User4   5 User5    为了限制SELECT查询中返回的结果集数量，可以使用LIMIT语句加上一个或两个整数作为参数(0也可以)。
LIMIT语句一个参数
当只提供了一个参数，这将只会限制返回的行数：
SELECT * FROM users ORDER BY id ASC LIMIT 2; id username 1 User1 2 User2  如果参数是0的话，将会返回0个值。
还需要注意，这里ORDER BY语句是很重要的，用来指定第一行的结果(当按照另一列排序时)。
LIMIT使用两个参数
当LIMIT语句使用两个参数时：
 第一个参数表示从结果集中显示的行-这个值通常是offset，因为这个值表示受约束结果集的开始之前的行。这个值允许是0，表示非约束结果集的第一行。 第二个参数表示结果集要显示的最大结果数量。  查看下面的查询：
SELECT * FROM users ORDER BY id ASC LIMIT 2,3; id username 3 User3 4 User4 5 User5  注意当第一个参数为0时，这个结果集等价于只传入了一个参数。这意味着下面两个语句由相同的结果：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-05.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-05.html</guid>
      <description>NULL NULL的使用  不知道的数据：像end_date，rating 可选的数据：像middle_initial(尽管空字符是更加合适的) 0/0：某些运算的结果，像0除以0 NULL不等于空字符&amp;rdquo;&amp;ldquo;或者0 其他？  验证NULL  IS NULL或IS NOT NULL：= NULL将不会像你预期的一样 x &amp;lt;=&amp;gt; y是一种&amp;rdquo;null安全&amp;rdquo;的比较  在LEFT JOIN语句中检查a中的行在b中没有合适的行对应。
SELECT ... FROM a LEFT JOIN b ON ... WHERE b.id IS NULL:  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-04.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-04.html</guid>
      <description>倒引号 倒引号用法 有很多例子在查询中使用倒引号，但是还是有很多人不清楚在什么时候或什么地方使用倒引号`。
倒引号主要用于防止一个调用&amp;rdquo;MySQL保留字&amp;rdquo;的错误。当你使用PHPmyAdmin创建一个表的时候，可能会遇到一个警告或提示：你正在使用MySQL的保留字。
例如，你创建一个包含字段&amp;rdquo;group&amp;rdquo;的表，你会遇到这个警告。这是因为你可能会使用下面的查询：
SELECT student_name, AVG(test_score) FROM student GROUP BY group;  为了确保你的查询不会出现错误，你可以在关键字上面增加倒引号：
SELECT student_name, AVG(test_score) FROM student GROUP BY `group`;  表
不仅仅列名需要添加倒引号，表名也需要添加倒引号。例如，当你需要JOIN多个表的时候：
SELECT `users`.`username`, `groups`.`group` FROM `users`;  易于阅读
正如你看到的，在表名或列表两边添加倒引号，也让查询更加容易阅读。
例如当你在书写全是小写时的查询时：
select student_name, AVG(test_score) from student group by group select `student_name`, AVG(`test_score`) from `student` group by `group`  查看MySQL关键字和保留字的手册。带有(R)标识的是保留字。其他的都是关键字。保留字需要特别小心。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-03.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-03.html</guid>
      <description>SELECT SELECT语句用来从一个或多个表中获取搜索到的行。
DISTINCT 在SELECT后面添加DISTINCT表示删除重复的行。
CREATE TABLE `car` ( `car_id` INT UNSIGNED NOT NULL PRIMARY KEY, `name` VARCHAR(20), `price` DECIMAL(8,2) ); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (1, &#39;Audi A1&#39;, &#39;20000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (2, &#39;Audi A1&#39;, &#39;15000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (3, &#39;Audi A2&#39;, &#39;40000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (4, &#39;Audi A2&#39;, &#39;40000&#39;); SELECT DISTINCT `name`, `price` FROM CAR; ----------------- name | price Audi A1 | 20000.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-02.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-02.html</guid>
      <description>数据格式 CHAR(n) CHAR(n)是包含固定长度的n个字符的字符串。如果CHARACTER SET utf8mb4，这意味着它完全占用4个字节，不管里面包含什么文本。
大多数使用情况下CHAR(n)处理包含英文字符的字符串，因此应该设置ascii字符集(latin1也可以)。
country_code CHAR(2) CHARACTER SET ascii, postal_code CHAR(6) CHARACTER SET ascii, uuid CHAR(39) CHARACTER SET ascii, -- more discussion elsewhere  DATE DATETIME TIMESTAMP YEAR TIME DATE处理日期不包含时间部分。格式是&#39;YYYY-MM-DD&#39;，范围是1000-01-01到9999-12-31。
DATETIME是包含时间的日期格式&#39;YYYY-MM-DD HH:MM:SS&#39;。范围是1000-01-01 00:00:00到9999-12-31 23:59:59。
TIMESTAMP是整数类型的时间格式，包括日期和时间两部分。使用的范围是1970-01-01 00:00:01到2038-01-19 03:14:07 UTC (使用4个字节)
YEAR表示年份，范围从1901到2155(使用1个字节)
TIME表示一个&amp;rsquo;HH:MM:SS&amp;rsquo;格式的时间。范围从-838:59:59到838:59:59。
存储大小：
   数据类型 MySQL5.6.4之前 MySQL5.6.4及之后     YEAR 1字节 1字节   DATE 3字节 3字节   TIME 3字节 3字节+分数秒存储   DATETIME 8字节 5字节+分数秒存储   TIMESTAMP 4字节 4字节+分数秒存储    分数秒(5.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(一)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-01.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-01.html</guid>
      <description>开始学习MySQL 版本历史
   1.0 1995-05-23     3.19 1996-12-01   3.20 1997-01-01   3.21 1998-10-01   3.22 1999-10-01   3.23 2001-01-22   4.0 2003-03-01   4.1 2004-10-01   5.0 2005-10-01   5.1 2008-11-27   5.5 2010-11-01   5.6 2013-02-01   5.7 2015-10-01    开始 创建MySQL数据库 CREATE DATABASE mydb;  返回：
 Query OK, 1 row affected (0.</description>
    </item>
    
  </channel>
</rss>