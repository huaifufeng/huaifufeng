<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PHP on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/categories/php/</link>
    <description>Recent content in PHP on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 31 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/categories/php/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PHP专业笔记（六十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-61.html</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-61.html</guid>
      <description>使用MongoDB 1. 连接MongoDB 创建一个MongoDB连接，之后你可以在这个连接查询数据：
$manager = new \MongoDB\Driver\Manager(&#39;mongodb://localhost:27017&#39;);  在下面的例子中，你可以知道怎么在连接对象上面怎么进行查询。
这个扩展将会自动的关闭连接，所有不是必须手动关闭的。
2. 获取多个文档 - find() 搜索多个名称为Mike的用户的例子：
$filter = [&#39;name&#39; =&amp;gt; &#39;Mike&#39;]; $query = new \MongoDB\Driver\Query($filter); $cursor = $manger-&amp;gt;executeQuery(&#39;database_name.collection_name&#39;, $query); foreach ($cursor as $doc) { var_dump($doc); }  3. 获取一个文档 - findOne() 获取指定id对应的一个用户的信息的例子，你可以使用：
$options = [&#39;limit&#39; =&amp;gt; 1]; $filter = [&#39;_id&#39; =&amp;gt; new \MongoDB\BSON\ObjectID(&#39;578ff7c3648c940e008b457a&#39;)]; $query = new \MongoDB\Driver\Query($filter, $options); $cursor = $manager-&amp;gt;executeQuery(&#39;database_name.collection_name&#39;, $query); $cursorArray = $cursor-&amp;gt;toArray(); if(isset($cursorArray[0])) { var_dump($cursorArray[0]); }  4.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-60.html</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-60.html</guid>
      <description>SQLite3 1. SQLite3快速开始指导 这是一个使用SQLite3相关API的一个完整例子。目的是帮助你可以很快的开始并运行真实的例子。你也可以获取一个指导的可执行PHP文件。
创建/打开数据库
首先让我们创建一个新的数据库。只有在文件不存在的情况下创建，然后打开准备读取/写入。文件的扩展名由你自己觉得，但是.sqlite是非常常见的，并且不需要解释说明的。
$db = new SQLite3(&#39;analytics.sqlite&#39;, SQLITE3_OPEN_CREATE | SQLITE3_OPEN_READWRITE);  创建表
$db-&amp;gt;query(&#39;CREATE TABLE IF NOT EXISTS &amp;quot;visits&amp;quot; ( &amp;quot;id&amp;quot; INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, &amp;quot;user_id&amp;quot; INTEGER, &amp;quot;url&amp;quot; VARCHAR, &amp;quot;time&amp;quot; DATETIME )&#39;);  插入示例
建议将相关的查询放入到一个事务中（包含在关键字BEGIN和COMMIT中），即使你不关心原子性。如果你没有这么做的话，SQLite会把每个查询都放到一个事务中，这将会极大降低每个事情的执行。如果你是刚开始使用SQLite，你会很奇怪为什么INSERT语句这么慢。
$db-&amp;gt;exec(&#39;BEGIN&#39;); $db-&amp;gt;query(&#39;INSERT INTO &amp;quot;visits&amp;quot; (&amp;quot;user_id&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;time&amp;quot;) VALUES (42, &amp;quot;/test&amp;quot;, &amp;quot;2017-01-14 10:11:23&amp;quot;)&#39;); $db-&amp;gt;query(&#39;INSERT INTO &amp;quot;visits&amp;quot; (&amp;quot;user_id&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;time&amp;quot;) VALUES (42, &amp;quot;/test2&amp;quot;, &amp;quot;2017-01-14 10:11:44&amp;quot;)&#39;); $db-&amp;gt;exec(&#39;COMMIT&#39;);  使用preapre语句插入潜在风险的数据。你可以使用命名参数完成这个功能：
$statement = $db-&amp;gt;prepare(&#39;INSERT INTO &amp;quot;visits&amp;quot; (&amp;quot;user_id&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;time&amp;quot;) VALUES (:uid, :url, :time)&#39;); $statement-&amp;gt;bindValue(&#39;:uid&#39;, 1337); $statement-&amp;gt;bindValue(&#39;:url&#39;, &#39;/test&#39;); $statement-&amp;gt;bindValue(&#39;:time&#39;, date(&#39;Y-m-d H:i:s&#39;)); $statement-&amp;gt;execute(); //you can reuse the statement with different values  获取数据</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十九）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-59.html</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-59.html</guid>
      <description>PHP MySQLi mysqli接口是mysql的一种改进方案（含义是&amp;rdquo;MySQL Improvement 扩展&amp;rdquo;），而mysql接口在PHP5.5标记为不推荐使用，在PHP7.0中移除。mysqli扩展（也被称为MySQL优化扩展）为MySQL4.1.3之后的新特性开发的。mysqli扩展在PHP5之后开始支持。
1. 关闭连接 当我们在数据库上面的查询结束之后，强烈建议关闭连接来释放资源。
面向对象方式
$conn-&amp;gt;close();  面向过程方式：
mysqli_close($conn);  注意：服务器的连接在脚本执行结束之后就会立即关闭，除非在结束之前使用close方法进行关闭。
用例：如果我们的脚本在获取全部结果之后还有很多的处理要进行，那我们肯定应该关闭连接。如果不这么做，当Web服务器大量使用的时候，MySQL服务器可能达到连接限制。
2. Mysqli 连接 面向对象：
连接服务器：
$conn = new mysqli(&amp;quot;localhost&amp;quot;, &amp;quot;my_user&amp;quot;, &amp;quot;my_password&amp;quot;);  设置默认的数据库：$conn-&amp;gt;select_db(&amp;quot;my_db&amp;quot;);
连接一个数据库：
$conn = new mysqli(&#39;localhost&#39;, &#39;my_user&#39;, &#39;my_password&#39;, &#39;my_db&#39;);  面向过程：
连接服务器
$conn = mysqli_connect(&#39;localhost&#39;, &#39;mysql_user&#39;, &#39;my_password&#39;);  设置默认的数据库：mysqli_select_db($conn, &#39;my_db&#39;);
连接数据库：
$conn = mysqli_connect(&#39;localhost&#39;, &#39;my_user&#39;, &#39;my_password&#39;, &#39;my_db&#39;);  验证数据库连接
面向对象方式
if ($conn-&amp;gt;connect_errno &amp;gt; 0) { trigger_error($db-&amp;gt;connect_error); } //else 正确的逻辑  面向过程方式</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十八）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-58.html</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-58.html</guid>
      <description>PDO PDO(PHP数据对象)扩展允许开发人员连接到不同类型的数据库，并以统一的、面向对象的方式对他们进行查询。
1. 使用参数化查询避免SQL注入 SQL注入是一种攻击方式：允许任意用户修改SQL查询，在其中添加不希望的命令。例如，下面的代码是很脆弱的：
$sql = &amp;quot;SELECT name, email, user_level FROM users WHERE userID=&amp;quot; . $_GET[&#39;user&#39;]; $conn-&amp;gt;query($sql);  这允许脚本的任何用户随意的修改我们的数据库。例如，下面的查询字符串：
page.php?user=0;%20TRUNCATE%20TABLE%20users;  这就会把我们的查询修改为：
SELECT name, email, user_level FROM users WHERE userID = 0; TRUNCATE TABLE users;  虽然这是一个极端的例子（大多数SQL注入的攻击不是为了删除数据，也不是大多数的PHP查询支持多查询），这是一个说明通过不小心组装查询来实现SQL注入攻击的例子。不幸的是，这样的攻击非常常见，而且由于编码人员未能采取适当的预防措施来包含他们的数据，这种攻击非常有效。
要避免SQL注入的发送，prepare语句是推荐的解决办法。不是将用户的数据直接拼接到查询语句中，在查询中使用占位符。然后单独发送数据，这意味着SQL引擎不会混淆命令和用户数据。
 虽然这里介绍的事PDO，但是要注意PHP的MySQLi扩展也是支持prepare语句的。
 PDO支持两种类型的占位符（占位符不能用于列名或表名，只适用于值）
 命名的占位符。一个冒号(:)，后面跟上一个唯一的名称(例如：:user)  $sql = &amp;quot;SELECT name,email,user_level FROM users WHERE userID=:user&amp;quot;; $prep = $conn-&amp;gt;prepare($sql); $prep-&amp;gt;execute([&#39;:user&#39; =&amp;gt; $_GET[&#39;user&#39;]]); $result = $prep-&amp;gt;fetchAll();   传统的SQL位置占位符，就是?:  $sql = &#39;SELECT name, user_level FROM users WHERE userID = ?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十七）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-57.html</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-57.html</guid>
      <description>Sockets 1. TCP客户端scoket 创建一个使用TCP的socket：
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);  一定要确保socket创建成功了。onSocketFailure函数是这个主题中用来处理socket错误的例子。
if (!is_resource($sokcet)) { onSocketFailure(&amp;quot;Failed to create socket&amp;quot;); }  连接指定地址的socket
连接失败的话，第二行可以处理失败情况：
socket_connect($socket, &#39;chat.stackoverflow.com&#39;, 6667) or onSocketFailure(&amp;quot;Failed to connect to chat.stackoverflow.com:6667&amp;quot;, $socket);  向服务端发送数据
socket_write函数通过一个socket发送字节数据。在PHP中，一个字节数组是由字符串表示的，通常不区分编码。
socket_write($socket, &amp;quot;NICK Alice\r\nUSER alice 0 * :Alice\r\n&amp;quot;);  从服务器接收数据
下面的代码片段使用socket_read从服务器接收一些数据。
当给函数传入PHP_NORMAL_READ这第三个参数的时候，当遇到\r或\n的时候会中断读取，直接返回读取的值，这个值包括这两个字符。
当第三个参数传入PHP_BINARY_READ时，将会从数据流中读取到需要的字节数量。
当在方法之前调用了socket_set_nonblock方法，那么将会使用PHP_BINARY_READ，socket_read将会立即返回false。否则，方法将会阻塞直到获取到足够的数据（达到第二个参数设置的长度，或者遇到一个行结束符）或者socket被关闭了。
下面的例子是从一个假设的IRC服务器读取数据：
while(true) { //读取数据 $line = socket_read($socket, 1025, PHP_NORMAL_READ); if (substr($line, -1) === &#39;\r&#39;) { //判断是不是换行，是就在读取\n socket_read($socket, 1, PHP_BINARY_READ); } $message = parseLine($line); if ($message-&amp;gt;type === &#39;QUIT&#39;) { break; } }  关闭socket</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-56.html</link>
      <pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-56.html</guid>
      <description>类型转换和非严格比较问题 1. 什么是类型转换？ PHP是一种弱类型语音。这意味着，默认情况下表达式中的操作数不需要具有相同(或兼容)的类型。例如，你可以在字符串后面追加一个数字，并且希望它正常工作。
var_dump(&amp;quot;This is example number &amp;quot; . 1);  这个输出将会是：
 string(24) &amp;ldquo;This is example number 1&amp;rdquo;
 PHP通过将不兼容的变量类型自动转换为允许执行请求的操作的类型来实现这点。在上面的例子中，将会把整数1转换为字符串，这意味着可以和前面的字符串字面量拼接起来。这被叫做类型转换。这是PHP一个非常强大的特性，但如果你不知道的话，可能会导致很多麻烦，甚至导致安全问题。
假设下面的代码：
if (1 == $variable) { //处理一些问题 }  这里目的似乎是让程序员检查变量的值是不是1。但是如果变量$variable的值是&amp;rdquo;1 and a half&amp;rdquo;，会发生什么？答案可能让你吃惊：
$variable = &amp;quot;1 and a half&amp;quot;; var_dump (1 == $variable);  这个结果是：
 bool(true)
 为什么会是这个结果？这是因为PHP意思到&amp;rdquo;1 and a half&amp;rdquo;是一个字符串，但是它需要和一个整数1进行比较。为了避免失败，PHP进行了类型转换，试着将这个字符串转换为整数。PHP通过将字符串开头的可以转换为整数的部分转换为整数。一遇到一个不能转换为整数的字符串就立刻停止。因此&amp;rdquo;1 and a half&amp;rdquo;转换为整数1。
当然，这是认为设计的一个例子，但这足以说明一些问题。接下来的例子将会涵盖这些情况，我在实际软件开发中因为类型转换造成的问题。
2. 从文件读取 当我们读取一个文件的内容时，我们想要知道什么时候我们到文件的末尾了。fgets()方法在到达文件末尾的时候，会返回一个false，所以我们可以在循环中用这个作为判断条件。然而，如果数据返回的是一个可转换为false的内容，这个循环就会提前中断执行。
$handle = fopen(&amp;quot;/path/to/my/file&amp;quot;, &#39;r&#39;); if ($handle === false) { throw new Exception(&amp;quot;Failed to open file for reading&amp;quot;); } while($data = fgets($handle)) { echo(&amp;quot;Current file line is $data\n&amp;quot;); } fclose($handle);  如果文件的内容包含一个空行，while循环在遇到这个空行的时候会中断执行，因为空字符串会被识别为 false。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-55.html</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-55.html</guid>
      <description>读取请求的数据 1. 读取原始POST数据 使用POST请求发送的数据通常是MIME类型为application/x-www-form-urlencoded的键/值的数据格式。然而很多应用像web服务要求原始的数据格式，像XML或JSON格式。这个数据可以使用两个方法中的一个进行获取。
php://input提供访问原始请求数据体的数据流。
$rawdata = file_get_contents(&amp;quot;php://input&amp;quot;); //假如是json数据 $decoded = json_decode($rawdata);  在PHP5.6之前，$HTTP_RAW_POST_DATA是一个包含元素POST数据的全局变量。只有在php.ini中的always_populate_raw_post_data选项开启的时候有效。
$rawdata = $HTTP_RAW_POST_DATA; //假设是xml数据 $decoded = simplexml_load_string($rawdata);  从PHP5.6开始不推荐使用了，在PHP7.0的时候移除。
当数据的类型是multipart/form-data的时候，上面的方法都没有效果，因为我们这些数据是用来上传文件的。
2. 读取POST数据 一个POST请求中的数据是存储在超全局变量$_POST中的关联数组中。
注意访问数组中不存在的元素将会产生一个notice错误，所以在访问数组元素之前需要使用isset()或empty()函数或null船运算符进行元素存在性的检查。
例如：
$from = isset($_POST[&#39;name&#39;]) ? $_POST[&#39;name&#39;] : &#39;NO NAME&#39;; $message = isset($_POST[&#39;message&#39;]) ? $_POST[&#39;message&#39;] : &#39;NO MESSAGE&#39;; echo &amp;quot;Message from $from: $message&amp;quot;; //在PHP7.0之后 $from = $_POST[&#39;name&#39;] ?? &#39;NO NAME&#39;; $message = $_POST[&#39;message&#39;] ?? &#39;NO MESSAGE&#39;; echo &amp;quot;Message from $from: $message&amp;quot;;  3.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-54.html</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-54.html</guid>
      <description>Closure 1. 闭包的基本用法 一个closure等价于PHP中的匿名函数，例如一个没有名称的方法。即使这在技术上不正确，闭包的行为仍然与函数的行为相同，只有一些额外的特性。
一个闭包就是一个Closure类的对象，通过创建一个没有名称的方法实现。例如：
&amp;lt;?php $myClosure = function() { echo &#39;Hello world!&#39;; }; $myClosure(); // Shows &amp;quot;Hello world!&amp;quot;  注意$myClosure就是Closure的一个实例，让你知道你做了什么。(https://www.php.net/manual/zh/class.closure.php)
Closure的经典用法就是在你必须使用一个callable的方法，例如usort。
下面是一个示例，其中数组按每个人的兄弟姐妹数排序：
&amp;lt;?php $data = [ [ &#39;name&#39; =&amp;gt; &#39;John&#39;, &#39;nbrOfSiblings&#39; =&amp;gt; 2, ], [ &#39;name&#39; =&amp;gt; &#39;Stan&#39;, &#39;nbrOfSiblings&#39; =&amp;gt; 1, ], [ &#39;name&#39; =&amp;gt; &#39;Tom&#39;, &#39;nbrOfSiblings&#39; =&amp;gt; 3, ] ]; usort($data, function($e1, $e2) { if ($e1[&#39;nbrOfSiblings&#39;] == $e2[&#39;nbrOfSiblings&#39;]) { return 0; } return $e1[&#39;nbrOfSiblings&#39;] &amp;lt; $e2[&#39;nbrOfSiblings&#39;] ? -1 : 1; }); var_dump($data); // Will show Stan first, then John and finally Tom  2.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-53.html</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-53.html</guid>
      <description>序列化    参数 详情     value 要序列化的值，serialize()接受所有的类型，除了资源类型。你甚至可以序列化包含自身引用的数组。包含循环引用的数组和对象也是可以处理的。任何其他的引用都会丢失。当序列化的时候，PHP会在序列化之前首先调用__sleep()方法。这允许对象在序列化的最后一分钟进行数据的清理工作。同样，在调用unserialize()方法的时候，会首先调用__wakeup()方法。对象的私有属性前添加类型；受保护的属性前面会有&amp;rdquo;*&amp;ldquo;。这些预先准备好的值两边都有空字节。    1. 序列化不同的类型 生成一个值的可存储格式。
这在存储或传输PHP值而不丢失值的类型和结构的时候很有用。
想要把序列化的结果返回PHP的值，可以使用unserialize()方法。
序列化string
$string = &amp;quot;Hello world&amp;quot;; echo serialize($string); // 输出: // s:11:&amp;quot;Hello world&amp;quot;;  序列化double
$double = 1.5; echo serialize($double); // 输出: // d:1.5;  序列化float
float和double的序列化效果相同。
序列化integer
$integer = 65; echo serialize($integer); // 输出: // i:65;  序列化boolean
$boolean = true; echo serialize($boolean); // Output: // b:1; $boolean = false; echo serialize($boolean); // Output: // b:0;  序列化NULL</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-52.html</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-52.html</guid>
      <description>对象序列化 1. serialize / unserialize serialize()返回一个包含PHP中存储的任何值的字节流格式的字符串。unserialize()将会把这个变量转换为初始的值。
序列化对象
serialize($object);  反序列化对象
unserialize($object)  例子
$array = array(); $array[&amp;quot;a&amp;quot;] = &amp;quot;Foo&amp;quot;; $array[&amp;quot;b&amp;quot;] = &amp;quot;Bar&amp;quot;; $array[&amp;quot;c&amp;quot;] = &amp;quot;Baz&amp;quot;; $array[&amp;quot;d&amp;quot;] = &amp;quot;Wom&amp;quot;; $serializedArray = serialize($array); echo $serializedArray; //output: a:4:{s:1:&amp;quot;a&amp;quot;;s:3:&amp;quot;Foo&amp;quot;;s:1:&amp;quot;b&amp;quot;;s:3:&amp;quot;Bar&amp;quot;;s:1:&amp;quot;c&amp;quot;;s:3:&amp;quot;Baz&amp;quot;;s:1:&amp;quot;d&amp;quot;;s:3:&amp;quot;Wom&amp;quot;;}  2. Serializable接口 简介
 实现这个接口的类不在支持__sleep()和wakeup()魔术方法。当实例序列化的时候，serialize方法将会调用。除非在方法内部编程，否则这将不会调用__destruct()和其他有副作用的方法。当类的数据要反序列化的时候unserialize()方法将会作为构造函数调用，而不是__construct()。如果你想要执行标准的构造方法，就在这个方法里面调用。
 基本用法
class obj implents Serializable { private $data; public function __construct() { $this-&amp;gt;data = &amp;quot;My private data&amp;quot;; } public function serialize() { return serialize($this-&amp;gt;data); } public function unserialize($data) { $this-&amp;gt;data = unserialize($data); } public function getData() { return $this-&amp;gt;data; } } $obj = new Obj(); $user = serialize($obj); var_dump($user); //string(38) &amp;quot;C:3:&amp;quot;obj&amp;quot;:23:{s:15:&amp;quot;My private data&amp;quot;;}&amp;quot; $newObj = unserialize($user); var_dump($newobj-&amp;gt;getData()); // string(15) &amp;quot;My private data&amp;quot;  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-51.html</link>
      <pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-51.html</guid>
      <description>怎么分解URL 在编写PHP代码的时候，你可能需要将URL地址分解为多个部分。根据你的需要显然有不止一种方式实现这个功能。这个主题就是介绍这些方法，从中你可以选择自己最合适的方法。
1. parse_url()  parse_url()：这个函数解析URL并且放回URL任何部分的一个关联数组。
 $url = parse_url(&#39;http://example.com/project/controller/action/param1/param2&#39;); Array ( [scheme] =&amp;gt; http [host] =&amp;gt; example.com [path] =&amp;gt; /project/controller/action/param1/param2 )  如果你需要获取将path进行分隔，你可以使用explode方法：
$url = parse_url(&#39;http://example.com/project/controller/action/param1/param2&#39;); $url[&#39;sections&#39;] = explode(&#39;/&#39;, $url[&#39;path&#39;]); Array ( [scheme] =&amp;gt; http [host] =&amp;gt; example.com [path] =&amp;gt; /project/controller/action/param1/param2 [sections] =&amp;gt; Array ( [0] =&amp;gt; [1] =&amp;gt; project [2] =&amp;gt; controller [3] =&amp;gt; action [4] =&amp;gt; param1 [5] =&amp;gt; param2 ) )  如果你想要获取section最后的部分，你可以使用下面的方法：
$last = end($url[&#39;sections&#39;]);  如果URL中有GET的变量，你可以获取这些值：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-50.html</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-50.html</guid>
      <description>URL 1. 解析URL 想要把一个URL解析到各自单独的部分，使用parse_url()函数：
$url = &amp;quot;http://blog.huaifufeng.com/page?foo=1&amp;amp;bar=baz#anchor&amp;quot;; $parts = parse_url($url);  在上面执行之后，$parts里面的内容就像下面这样：
Array ( [scheme] =&amp;gt; http [host] =&amp;gt; www.example.com [path] =&amp;gt; /page [query] =&amp;gt; foo=1&amp;amp;bar=baz [fragment] =&amp;gt; anchor )  你也可以选择一个部分而不是整个部分，可以使用下面的方法：
$url = &#39;http://www.example.com/page?foo=1&amp;amp;bar=baz#anchor&#39;; $queryString = parse_url($url, PHP_URL_QUERY); //输出：foo=1&amp;amp;bar=baz  支持下面的常量: PHP_URL_SCHEME, PHP_URL_HOST, PHP_URL_PORT, PHP_URL_USER, PHP_URL_PASS, PHP_URL_PATH, PHP_URL_QUERY and PHP_URL_FRAGMENT.
像要把query字符串解析进入一个键值对，可以使用parse_str()：
Array ( [foo] =&amp;gt; 1 [bar] =&amp;gt; baz )  2. 将数组生成一个URL加密的参数字符串 http_build_query()可以将数组或对象生成一个参数字符串。这些参数可以被追加到网址后面生成一个GET请求，或者用在一个POST请求，例如cURL：
$parameters = [ &#39;parameter1&#39; =&amp;gt; &#39;foo&#39;, &#39;parameter2&#39; =&amp;gt; &#39;bar&#39;, ]; $queryString = http_build_query($parameters);  $queryString将会有下面的内容：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十九）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-49.html</link>
      <pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-49.html</guid>
      <description>Unicode支持 1. 使用PHP转换Unicode字符为&amp;rsquo;\uxxxx&amp;rsquo; 你可以使用下面的方法进行字符类型转换：
if (!function_exists(&#39;codepoint_encode&#39;)) { function codepoint_encode($str) { return substr(json_encode($str), 1, -1); } } if (!function_exists(&#39;codepoint_decode&#39;)) { function codepoint_decode($str) { return json_decode(sprintf(&#39;&amp;quot;%s&amp;quot;&#39;, $str)); } }  怎么使用：
echo &amp;quot;\\nUse JSON encoding / decoding\\n&amp;quot;; var_dump(codepoint_encode(&#39;我好&#39;)); var_dump(codepoint_decode(&#39;\\u6211\\u597d&#39;));  输出：
Use JSON encoding / decoding string(12) &amp;quot;\\u6211\u597d&amp;quot; string(6) &amp;quot;我好&amp;quot;  2. 使用PHP转换Unicode字符为他们的数字值和/或HTML实体 可以使用下面的代码进行转换操作：
if (!function_exists(&#39;mb_internal_encoding&#39;)) { function mb_internal_encoding($encoding = NULL) { return ($encoding === NULL) ? iconv_get_encoding() : iconv_set_encoding(encoding); } } if (!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十八）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-48.html</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-48.html</guid>
      <description>UTF-8 1. 输入  你需要在任何地方存储和使用接收到的UTF-8格式的数据。PHP的mb_check_encoding可以完成这个功能，但是你要始终如一的使用。确实没有办法解决这个问题，因为恶意客户机可以用他们想要的任何编码提交数据。  $string = $_REQUEST[&#39;user_comment&#39;]; if (!mb_check_encoding($string, &#39;UTF-8&#39;)) { $actualEncoding = mb_detect_encoding($string); $string = mb_convert_encoding($string, &#39;UTF-8&#39;, $actualEncoding); }   如果你使用的事HTML5，你可以忽略这一点。你希望浏览器发送给你的所有数据都是UTF-8的。唯一有效的方式是在你的&amp;lt;form&amp;gt;标签中添加accept-charset属性。  &amp;lt;form action=&amp;quot;somepage.php&amp;quot; accept-charset=&amp;quot;UTF-8&amp;quot;&amp;gt;  2. 输出  如果你的系统传输文本到另外的系统，需要通知他们编码方式。在PHP中，你可以在php.ini中设置default_charset选项，或者手动设置Content-Type这个MIME头。这是针对现代浏览器的首选项：  header(&#39;Content-Type: text/html; charset=utf-8&#39;);   如果你不能设置响应头的话，你需要在HTML文件中修改HTML的源信息。
 HTML5  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;   老版本的HTML
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;   3. 数据存储和访问  这个主题主要讨论UTF-8以及在数据库中使用的注意点。如果你想要了解更多的PHP中使用数据库的信息，查看更多的信息。
 存储数据到数据库
 指定你数据库中所有的表和文本列为utf8mb4，这使得MySQL可以物理地存储和检索以UTF-8编码的值。   如果指定了utf8mb4_*排序集（没有显示指定字符集），MySQL将会隐式的使用utf8mb4编码
  老版本的MySQL(早于5.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十七）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-47.html</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-47.html</guid>
      <description>生成器 Yield关键字 一个yield和一个return语句很像，除了终止函数的执行并返回，yield语句返回一个Generator对象并且终止generator函数的执行。
下面是一个使用yield实现的range函数的例子：
function gen_one_to_three() { for ($i = 0; $i &amp;lt; 3; $i++) { yield $i; } }  通过var_dump函数可以看到这个方法返回一个Generator对象。
var_dump(gen_one_to_three()); 输出： class Generator (0) { }  Yield值
之后Generator像数组一样被迭代处理：
foreach (gen_one_to_three() as $value) { echo &amp;quot;$value\n&amp;quot;; }  上面的例子会输出：
1 2 3  带有key的Yield值
处理Yield值之后，你可以使用Yield的键/值对：
function gen_one_to_three() { $keys = [&amp;quot;first&amp;quot;, &amp;quot;second&amp;quot;, &amp;quot;third&amp;quot;]; for ($i = 1; $i &amp;lt;= 3; $i++) { // Note that $i is preserved between yields.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-46.html</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-46.html</guid>
      <description>过滤和过滤函数    参数 详情     variable 要进行筛选的值。注意标量的值在进行筛选之前，在筛选之前内部会将标量值转换为字符串。   filter 将要应用的筛选的ID。手册中列出了有效的变量筛选类型。如果忽略的话，默认会使用FILTER_DEFAULT，这等价于FILTER_UNSAFE_RAW。这将导致默认情况下不进行过滤。   options 选项的关联数组或者标志位的二进制表示。如果筛选器接受选项，标志位可以在数组的&amp;rdquo;flags&amp;rdquo;字段中添加。对于&amp;rdquo;回调&amp;rdquo;筛选器，应该传入可调用类型。这个回调方法必须接受一个参数，就是要筛选的值，并在筛选/清理后返回这个值。    这个扩展通过验证或清理数据来筛选数据。当数据源中包含未知(或外部)的数据(如用户输入的数据)时，是非常有用的。例如，这些数据来自HTML的表格。
1. 验证布尔值 var_dump(filter_var(true, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); //true var_dump(filter_var(false, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); //false var_dump(filter_var(1, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(0, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;1&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(&#39;0&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39; &#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;true&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(&#39;false&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var([], FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // NULL var_dump(filter_var(null, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false  2.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-45.html</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-45.html</guid>
      <description>类型提示 1. 类和接口提示 在PHP5的时候，增加了类和接口的提示。
类提示
&amp;lt;?php class Student { public $name = &#39;Chris&#39;; } class School { public $name = &#39;University of Edinburgh&#39;; } function enroll(Student $student, School $school) { echo $student-&amp;gt;name . &#39; is being enrolled at &#39; . $school-&amp;gt;name; } $student = new Student(); $school = new School(); enroll($student, $school);  上面的例子将会输出：
 Chris is being enrolled at University of Edinburgh
 接口提示
&amp;lt;?php interface Enrollable {}; interface Attendable {}; class Chris implements Enrollable { public $name = &#39;Chris&#39;; } class UniversityOfEdinburgh implements Attendable { public $name = &#39;University of Edinburgh&#39;; } function enroll(Enrollable $enrollee, Attendable $premises) { echo $enrollee-&amp;gt;name .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-44.html</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-44.html</guid>
      <description>流    参数名字 描述     流资源 由&amp;lt;schema&amp;gt;://&amp;lt;target&amp;gt;语法组成的数据提供程序    1. 注册流包装器 流包装器可以为一个或多个特定方案提供处理程序。
下面的例子显示了一个简单的流包装器，当流关闭的的时候发送一个PATCH的HTTP请求。
//注册FooWrapper类作为 foo://URL stream_wrapper_register(&amp;quot;foo&amp;quot;, FooWrapper::class, STREAM_IS_URL) or die(&amp;quot;Duplicate stream wrwapper registered&amp;quot;); class FooWrapper { public $context; private $url; public function stream_open(string $path, string $mode, int $options, string &amp;amp;$openedPath) : bool { $url = parse_url($path); if ($url === false) { return false; } $this-&amp;gt;url = $url[&#39;host&#39;] . &#39;/&#39; . $url[&#39;path&#39;]; return true; } public function stream_write(string $data) : int { $this-&amp;gt;buffer .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-43.html</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-43.html</guid>
      <description>文件处理    参数 描述     filename 要读取的文件名称   use_include_path 如果你想要在include_path中搜索这个文件，可以选择可选的第二个参数，并且把这个参数设置为TRUE。   context 一个环境流资源    1. 便捷方法 1.1 原始直接IO file_get_contents和file_put_contents提供了在一次请求中便捷的从一个文件读取内容到字符串或者将字符串写入一个文件中。
file_put_contents也可以使用FILE_APPEND位标识符来像文件中追加内容，而不是截断或覆盖文件的内容。也可以使用LOCK_EX位标识符来为写文件操作增加一个额外的锁。位标识符可以使用|二进制或来添加。
$path = &#39;file.txt&#39;; //从文件中读取内容 $contents = file_get_contents($file); //做一些修改，比如讲CRLF替换为LF $contents = str_replace(&amp;quot;\r\n&amp;quot;, &amp;quot;\n&amp;quot;, $contents); //将修改后的内容写入文件 file_put_contents($path, $contents);  FILE_APPEND用来像日志文件追加内容，LOCK_FILE用来解决多个进程同时写内容的竞争冲突。例如，将当期session的内容写入文件中：
file_put_contents(&#39;logins.log&#39;, &amp;quot;{$_SESSION[&amp;quot;username&amp;quot;]} logged in&amp;quot;, FILE_APPEND | LOCK_EX);  1.2 CSV IO fgetcsv($file, $length, $separator)  fgetcsv解析读入的行并找出 CSV 格式的字段，成功返回一个包含这些字段的数组，失败的时候返回FALSE。
默认情况下，将只会读取CSV文件中的一行：
$file = fopen(&#39;contacts.csv&#39;, &amp;quot;r&amp;quot;); print_r(fgetcsv($file)); print_r(fgetcsv($file, 5, &amp;quot; &amp;quot;)); fclose($file);  contacts.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-42.html</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-42.html</guid>
      <description>魔术方法 __call()和__callStatic() __call()和__callStatic()将会在某些人调用不存在的对象方法或者静态方法的时候调用。
class Foo { /** * 这个方法将会在某些人调用对象不存在的方法时调用，像 * $foo-&amp;gt;method($arg, $arg1); * * 第一个参数是方法名称 就像上面的method * 第二个参数是由$arg和$arg1组成的数组 */ public function __call($method, $arguments) { $snakeName = CaseHelper::camelToSnake($method); $subMethod = substr($snakeName, 0, 3); $propertyName = substr($snakeName, 4); switch($subMethod) { case &#39;get&#39;: return $this-&amp;gt;data[$propertyName]; case &#39;set&#39;: $this-&amp;gt;data[$propertyName] = $arguments[0]; break; case &#39;has&#39;: return isset($this-&amp;gt;data[$propertyName]); default: throw new BadMethodCallException(&amp;quot;Undefined method $method&amp;quot;); } } public static function __callStatic($method, $arguments) { print_r(func_get_args()); } }  例子</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-41.html</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-41.html</guid>
      <description>Composer依赖关联    参数 详情     license 定义项目想要使用什么类型的证书   authors 定义项目的作者，包括作者的详细信息   support 定义支持邮寄，irc通道，其他的任何连接   require 定义实际依赖的包和包的版本信息   require-dev 定义开发这个项目必须的包   sugget 定义包的建议信息，包括这个包可以有什么作用   autoload 定义项目的自动加载逻辑   autoload-dev 定义开发这个项目的自动加载逻辑    Composer是PHP最常用的依赖管理工具。它就像是Node的npm，Python的pip，.NET的NuGet。
Composer是什么？ Composer是PHP的依赖/包管理工具。这可以用于安装，追踪，更新你的项目依赖。Composer也负责自动加载应用程序所依赖的依赖项，让你可以轻松的在项目中使用依赖项，而不必担心将他们包含在任何文件的顶部。
你项目的依赖信息都放在项目更目录中的composer.json文件中。这个文件包含生产环境和开发环境依赖的包的版本信息。
可以在Composer网站上看到一个composer.json的完整格式信息。
这个文件可以通过编辑器手动编辑，也可以通过composer require &amp;lt;package&amp;gt;或者composer require-dev &amp;lt;package&amp;gt;自动的进行添加。
想要在你的项目中使用composer，你需要在项目中创建composer.json文件。你可以手动创建这个文件，或者通过composer init这个命令创建。在你在终端中运行composer init之后，这将会让你提供项目的一些信息：项目名(vendor/package 例如 laravel/laravel)，描述(可选的)，作者和其他的一些信息，像最低稳定版本，许可证和依赖的包信息等等。
composer.json中的require关键字指明你项目依赖的包名。require关键字使用一个对象来存储包名(monolog/monolog)和相应的版本号。
{ &amp;quot;require&amp;quot;: { &amp;quot;composer/composer&amp;quot;: &amp;quot;1.2.*&amp;quot; } }  想要按照这里定义的依赖包的话，你需要使用composer install命令，这将会下载定义的指定版本的包，并把这个包下载到vendor目录。这非常方便的把第三方的代码放到vendor目录中。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-40.html</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-40.html</guid>
      <description>Trait 什么是Trait PHP只允许单继承。换句话说，一个类只可以继承一个类。但是当你想要包含不在父类中的功能怎么办？在PHP5.4之前你必须要有创造性，但是在PHP5.4中，引入了Trait。Trait允许你&amp;rdquo;复制并粘贴&amp;rdquo;一个类的一部分到你的类中。
trait Talk { /** @var string */ public $phrase = &#39;Well Wilbur...&#39;; public function speak() { echo $this-&amp;gt;phrase; } } class MrEd extends Horse { use Talk; public function __construct() { $this-&amp;gt;speak(); } public function setPhrase($phrase) { $this-&amp;gt;phrase = $phrase; } }  现在我们有一个继承了Horse的MrEd类。但是不是所有的Horse类都具备Talk的功能，所以我们使用了Trait。注意这里我们是怎么做的。
首先，我们定义了我们的Trait。我们可以使用自动加载和命名空间。然后我们在MrEd中使用use关键字引入。
你注意到MrEd使用Talk的方法和变量但是没有定义他们。还记得我们之前说的&amp;rdquo;复制和粘贴&amp;rdquo;吗？这些方法和变量在类中定义了，就像这个类已经定义了这写方法和变量。
Trait和抽象类很像，定义了变量和方法。你不可以直接实现一个Trait(new Trait())。Trait不能像抽象类和接口那样，让一个类隐式定义一个方法。Trait只用于显示定义(因为你可以实现任意多个接口)。
什么时候应该使用Trait？
讨论Trait时，首先需要考虑的问题就是这个问题。
 我可以通过重构我的代码来避免使用Trait吗？
 答案往往是肯定的。Trait是有单一继承引起的边缘情况。滥用或过度使用Trait的可能性很高。但是考虑到Trait为代码引入了另外的源，这意味着还有另一层复杂性。在这个例子中，我们处理了3个类。但是Trait意味着你不止处理这些。对于每一个特性，您的类都变得更加难以处理，因为您现在必须参考每个特性来找出它定义了什么（并且可能在发生冲突的地方，请参见冲突解决）。理想情况下，代码中的特征应该尽可能少。
促进水平代码重用 假设我们有一个Log的接口：
interface Logger { function log($message); }  现在我们有两个Logger接口的实现类：FileLogger和ConsoleLogger：
class FileLogger implements Logger { public function log($message) { //添加代码实现 } } class ConsoleLogger implements Logger { public function log($message) { //添加实现 } }  现在如果你定义了一个Foo类，你想要实现一些日志任务，你可以像下面一样：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十九）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-39.html</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-39.html</guid>
      <description>正则表达式    参数 详情     $pattern 一个正则表达式的字符串(PCRE)    全局正则表达式匹配 一个全局正则表达式匹配可以使用preg_match_all。preg_match_all返回目标字符串中所有匹配的结果(与只返回第一个匹配结果的preg_match不同)。
preg_match_all返回匹配的数量。$matches包含所有匹配到的结果，并且有第四个参数控制格式。
如果提供一个数组，$matches包含和preg_match返回相同的格式，除了preg_match在第一个匹配之后就终止，但是preg_match_all会迭代整个字符串，直到字符串处理完毕，返回一个包含匹配结果的多维数组，这个数组的格式有第四个参数控制。
第四个参数$flag控制$matches的格式。默认的值是PREG_PATTERN_ORDER，可能的其他值PREG_SET_ORDER和PREG_PATTERN_ORDER。
下面的代码展示栏preg_match_all的用法：
$subject = &#39;a1b c2d3e f4g&#39;; $pattern = &#39;/[a-z]([0-9])[a-z]/&#39;; var_dump(preg_match_all($pattern, $subject, $matches, PREG_SET_ORDER)); //int(3) var_dump($matches); preg_match_all($pattern, $subject, $matches); //默认使用PREG_PATTERN_ORDER var_dump($matches); preg_match($pattern, $subject, $matches); var_dump($matches);  第一个var_dump将会使用PREG_SET_ORDER作为第四个参数：
array(3) { [0]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;a1b&amp;quot; [1]=&amp;gt; string(1) &amp;quot;1&amp;quot; } [1]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;c2d&amp;quot; [1]=&amp;gt; string(1) &amp;quot;2&amp;quot; } [2]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;f4g&amp;quot; [1]=&amp;gt; string(1) &amp;quot;4&amp;quot; } }  $matchs有3个子数组，每个数组代表一个匹配结果，有着和preg_match相同的格式。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十八）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-38.html</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-38.html</guid>
      <description>解析HTML 从字符串解析HTML PHP实现了一个DOM Level 2的解析器，允许你使用getElementById()和appendChild()这样的方法来处理HTMl。
$html = &#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;span id=&amp;quot;text&amp;quot;&amp;gt;Hello World!&amp;lt;/span&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;; $doc = new DOMDocument(); libxm_use_internal_errors(true); $doc-&amp;gt;loadHTML($html); echo $doc-&amp;gt;getElementById(&#39;text&#39;)-&amp;gt;textContent;  输出：
Hello World!  注意对应HTML的问题，PHP都会发出警告，特别是在导入文档片段的时候。为了避免这些警告，通过libxml_use_internal_errors()来通知DOM库(libxml)处理自己的错误。如果需要的话，可以使用libxml_get_errors()来处理错误。
XPath $html = &#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;span class=&amp;quot;text&amp;quot;&amp;gt;Hello, World!&amp;lt;/span&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;; $doc = new DOMDocument(); $doc-&amp;gt;loadHTML($html); $xpath = new DOMXPath($doc); $span = $xpath-&amp;gt;query(&amp;quot;//span[@class=&#39;text&#39;]&amp;quot;)-&amp;gt;item(0); echo $span-&amp;gt;textContent;  输出：
Hello, World!  SimpleXML 介绍
 SimpleXML是一个提供了便捷处理XML文档的PHP库(特别是读取和迭代XML数据) 唯一的限制就是XML文档必须是格式良好的。  过程方法
// Load an XML string $xmlstr = file_get_contents(&#39;library.xml&#39;); $library = simplexml_load_string($xmlstr); // Load an XML file $library = simplexml_load_file(&#39;library.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十七）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-37.html</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-37.html</guid>
      <description>SimpleXML SimpleXML读取数据 字符串 使用simplexml_load_string从字符串创建一个SimpleXMLElement。
$xmlString = &amp;quot;&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&amp;gt;&amp;quot;; $xml = simplexml_load_string($xmlString) or die(&amp;quot;Error: Cannot create object&amp;quot;);  注意这里使用or而不是||,因为or的优先级比=低。or后面的代码只有在$xml解析为false时才会执行。
文件 使用simplexml_load_file从一个文件地址加载数据：
$xml = simplexml_load_string(&amp;quot;filePath.xml&amp;quot;); $xml = simplexml_load_string(&amp;quot;https://example.com/doc.xml&amp;quot;);  这个URL可以是任何PHP支持的格式，或者自定义的流封装。
参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-36.html</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-36.html</guid>
      <description>XML 使用DomDocument创建XML 使用DomDocument创建XML，我们需要使用createElement()和createAttribute()来创建所有的标签和属性。然后会用appendChild()来创建XML的结构。
下面的例子包含标签，属性，CDATA部分和第二个标签的不同命名空间：
$dom = new DOMDocument(&#39;1.0&#39;, &#39;utf-8&#39;); $dom-&amp;gt;preserveWhiteSpace = false; $dom-&amp;gt;formatOutput = true; //创建没有值的主标签 $books = $dom-&amp;gt;createElement(&#39;books&#39;); $book_1 = $dom-&amp;gt;createElement(&#39;book&#39;); //创建带值的标签 $name_1 = $dom-&amp;gt;createElement(&#39;name&#39;, &#39;PHP - An Introduction&#39;); $price_1 = $dom-&amp;gt;createElement(&#39;price&#39;, &#39;$5.95&#39;); $id_1 = $dom-&amp;gt;createElement(&#39;id&#39;, &#39;1&#39;); //创建并添加属性 $attr_1 = $dom-&amp;gt;createAttribute(&#39;version&#39;); $attr_1 -&amp;gt; value = &#39;1.0&#39;; $id_1-&amp;gt;appendChild($attr_1); //创建第二个不同命名空间的标签 $namespace = &#39;www.example.com/libraryns/1.0&#39;; //在books标签前面添加命名空间 $books-&amp;gt;setAttributeNS(&#39;http://www.w3.org/2000/xmlns/&#39;, &#39;xmlns:ns&#39;, $namespace); $book_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:book&#39;); $name_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:name&#39;); //创建CDATA部分，并放入name标签 $name_cdata = $dom-&amp;gt;createCDATASection(&#39;PHP - Advanced&#39;); $name_2 -&amp;gt; appendChild($name_cdata); $price_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:price&#39;, &#39;$25.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-35.html</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-35.html</guid>
      <description>依赖注入 依赖注入(DI)是&amp;rdquo;传入&amp;rdquo;的一种花哨说法。这实际含义就是对一个对象的依赖通过构造函数或set方法来传入，而不是在对象内部创建这些依赖对象。依赖注入也可能指的是自动构造和注入的依赖注入容器。
构造函数注入 对象通常依赖于另外的对象。相对于在构造函数中创建依赖对象，应该把依赖对象作为参数传入构造函数。这样可以确保对象之间没有紧密耦合，并且可以更改对类实例化的依赖性。这有许多好处，包括通过使依赖关系显式化使代码更容易阅读，以及使测试更简单，因为依赖关系可以更容易地被切换和模拟。
在下面的例子中，Component依赖一个Logger实例，但是它不创建这个实例。而是在构造函数中通过参数传入。
interface Logger { public function log(string $message); } class Component { private $logger; public function __construct(Logger $logger) { $this-&amp;gt;logger = $logger; } }  没有依赖注入的话，代码就像下面这样：
class Component { private $logger; public function __construct() { $this-&amp;gt;logger = new FooLogger(); } }  在构造函数中使用new来创建新对象表明没有使用依赖注入(或者使用不完全)，这里代码是高度绑定的。这也说明代码没有完全测试，或者可能有一些脆弱的测试，这些测试对程序状态做出错误的假设。
在上面的例子中，我们使用依赖注入，如果需要的话，我们可以很方便的修改使用不同的Logger对象。例如，我们可能需要使用不同的Logger实现来把日志存放到不同的位置，或者使用不同的日志格式，或者把日志存入数据库而不是文件。
Setter注入 依赖也可以使用setter方法进行注入：
interface Logger { public function log($message); } class Component { private $logger; private $databaseConnection; public function __construct(DatabaseConnection $databaseConnection) { $this-&amp;gt;databaseConnection = $databaseConnection; } public function setLogger(Logger $logger) { $this-&amp;gt;logger = $logger; } public function core() { $this-&amp;gt;logSave(); return $this-&amp;gt;databaseConnection-&amp;gt;save($this); } public function logSave() { if ($this-&amp;gt;logger) { $this-&amp;gt;logger-&amp;gt;log(&#39;saving&#39;); } } }  当类的core方法不依赖于依赖项的话，这是很有意思的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-34.html</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-34.html</guid>
      <description>反射 类或对象的特征 类的特征检查可以使用property_exists和method_exists来实现。
class MyClass { public $public_field; protected $protected_field; private $private_field; static $static_field; const CONSTANT = 0; public function public_function() {} protected function protected_function() {} } // check properties $check = property_exists(&#39;MyClass&#39;, &#39;public_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;protected_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;private_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;static_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;other_field&#39;); // check methods $check = method_exists(&#39;MyClass&#39;, &#39;public_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;protected_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;private_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;static_function&#39;); // however.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-33.html</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-33.html</guid>
      <description>cURL扩展 curl_init 初始化一个cURL
   参数 详情     url 应用cURL请求的url网址    curl_setopt 设置cURL传输的选项
   参数 详情     ch cURL处理的对象(curl_inti()返回的值)   option CURLOPT_XXX将用来设置选项，查看PHP手册查看选项和接受值的列表   value 设置cURL选项的值    curl_exec 执行以cURL请求
   参数 详情     ch cURL处理的对象(curl_init()返回的值)    curl_close 结束一个cURL请求
   参数 详情     ch cURL处理的对象(curl_init()返回的值)    基本用法(GET请求) cURL是一个使用URL语法传输数据的工具。支持HTTP，FTP，SCP和其他的类型(curl&amp;gt;=7.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-32.html</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-32.html</guid>
      <description>SOAP客户端    参数 详情     $wsdl WSDL的URI，如果不是 WSDL模式的化，是Null   options Soap客户端的选项数组，非WSDL模式要设置location和uri，其他的选项是可选的。查看下面的值    WSDL模式 首先，创建一个新的SoapClient对象，传入一个WSDL文件的URL和选项的数组。
$soap = new SoapClient(&#39;https://example.com/soap.wsdl&#39;, [ &#39;soap_version&#39; =&amp;gt; SOAP_1_2, &#39;compression&#39; =&amp;gt; SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_GIZP, &#39;cache_wsdl&#39; =&amp;gt; WSDL_CACHE_BOTH, &#39;trace&#39; =&amp;gt; TRUE, &#39;exceptions&#39; =&amp;gt; TRUE ]);  然后使用$soap对象调用SOAP的方法：
$result = $soap-&amp;gt;requestData([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);  非WSDL模式 这个和WSDL模式相似的，传入WSDL文件的地址为NULL，必须传下location和uri选项。
$soap = new SoapClient(NULL, [ &#39;location&#39; =&amp;gt; &#39;https://example.com/soap/endpoint&#39;, &#39;uri&#39; =&amp;gt; &#39;namespace&#39; ]);  类图 当在PHP中创建SOAP客户端的时候，你可以使用classmap键的配置数组。classmap定义了WSDL实际使用的类型，而不是默认的stdClass。使用这个的原因是因为你可以获取这些类自实现的字段和方法调用，而不是猜测stdClass有什么字段。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-31.html</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-31.html</guid>
      <description>JSON json_encode
   参数 详情     value 进行编码的值。除了资源类型外其他都可以。所有字符串数据必须是UTF-8的格式。   options 二进制位标识符，包括JSON_HEX_QUOT,JSON_HET_TAG,JSON_HEX_AMP,JSON_HEX_APOS,JSON_NUMERIC_CHECK,JSON_PRETTY_PRINT,JSON_UNESCAPED_SLASHES,JSON_FORCE_OBJECT,JSON_PRESERVE_ZERO_FRACTION,JSON_UNESCAPED_UNICODE,JSON_PARTIAL_OUTPUT_ON_ERROR.这些常量的行为在jSON常量页有详细描述。   depth 设置最大的深度。必须是一个大于0的数    json_decode
   参数 详情     json 需要被解码的json字符串。这个函数只能处理UTF-8编码的字符串。   assoc 函数返回关联数组而不是对象   options JSON解码的二进制标识选项。当前只支持JSON_BIGINT_AS_STRING(默认会把大数字处理为浮点数)    JSON(JavaScript对象表示法)是一个平台和语言无关的将对象序列化到一个字符串的方法。因为这经常被用到web中，所以PHP中上线了一个JSON的基本扩展。
解码JSON字符串 json_decode()函数获取一个JSON编码的字符串作为第一个参数，将这个值解码到一个PHP变量中。
通常，json_decode()函数根据参数的不同会返回不同的结果，如果JSON对象的顶层元素是一个字典，将会返回一个\stdClass的对象；如果是一个数组，将会返回一个索引数组。对于某些标量值，像一些简单字符串&amp;rdquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;,&amp;ldquo;null&amp;rdquo;，将会返回标量值或NULL。在错误的时候将会返回Null。
$json_string = &#39;{&amp;quot;name&amp;quot;:&amp;quot;Jeff&amp;quot;, &amp;quot;age&amp;quot;:20, &amp;quot;active&amp;quot;:true, &amp;quot;colors&amp;quot;:[&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]}&#39;; $object = json_decode($json_string); //返回一个对象 printf(&amp;quot;Hello %s, You are %s years old.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-30.html</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-30.html</guid>
      <description>输出缓存    方法 详细说明     ob_start() 开启输出缓存，任何这个位置之后的输出（处理http头）都会被捕获不会直接显示   ob_get_contents() 返回ob_start()捕获的内容   ob_end_clean() 清空输出缓冲区并为当前嵌套级别关闭它   ob_get_clean() 执行ob_get_contents()和ob_end_clean()两个操作   ob_get_level() 返回输出缓冲区的当前嵌套级别   ob_flush() 在不结束缓存的情况下，输出缓存的内容并发送给浏览器   ob_implict_flush() 开启隐式刷新，在每次输出之后都会刷新   ob_end_flush() 刷新内容缓冲区并将其发送到浏览器，同时结束缓冲区    获取内容并清空 输出缓存允许你把一些文本内容(text，html)存储到一个变量中，然后在脚本结束之后一次性发送给浏览器。默认情况下，PHP解析内容之后会直接发送给浏览器：
&amp;lt;?php //开启缓存 ob_start(); //输出内容 print &amp;quot;Hello&amp;quot;; //可以跳出php ?&amp;gt; &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt; &amp;lt;?php //获取缓存内容并情况缓存 $content = ob_get_clean(); # $content = ob_get_contents(); # $did_clear_buffer = ob_end_clean(); print($content); //Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;  在ob_start()和ob_get_clean()之间的内容输出会被放到变量$content中。调用ob_get_clean()相当于同时调用了ob_get_contents()和ob_end_clean()。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-29.html</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-29.html</guid>
      <description>Cookie    参数 详细说明     name cookie的名称。这个也是你可以从$_COOKIE中获取值的名称。这个是唯一必须的参数   value cookie中存储的值。这个数据可以从浏览器中访问，所以不要在这放敏感信息·   expire 一个代表cookie过期时间的Unix的时间戳。如果过期时间设置为0，cookie将会在session失效时同时失效。如果设置一个比当前时间早的时间戳，cookie会立即失效。   path cookie的范围。如果设置为/这个cookie会在整个域名下有效。如果设置为/somePath/cookie将会只在这个路径和这个路径的子路径中有效。默认cookie会设置为当前问文件的路径   domain cookie有效的域名和子域名。如果设置为一级域名stackoverflow.com，这个cookie会在这个域名和子域名中有效。如果设置为sub.stackoverflow.com，这个cookie只会在这个子域名和子域名的子域名下面有效。   secure 如果设置为true，这个cookie只有当客户端和服务端为https时才会设置。   httponly 指明这个cookie只能通过http/s协议进行设置，不能使用JavaScript这样的客户端语音设置。只在PHP5.2之后有效    一个HTTP的cookie就是：当用户浏览器浏览的时候，一些从服务器发送到用户端，并存储在用户电脑浏览器下面的数据。
修改cookie 可以使用setcookie来修改cookie中存储的值：
setcookie(&#39;user&#39;, &#39;John&#39;, time()+86400, &#39;/&#39;);   cookie是HTTP头的一部分，所有setcookie()方法需要在发送数据到浏览器之前调用。当修改cookie的时候，需要保证path和domain的参数和原来cookie的值一致，否则将会创建一个新的cookie。当你发送cookie的时候，cookie的值部分会被自动的进行urlencode操作。当接收cookie的时候，会被自动的decode并且赋值给cookie名称相同的变量中。
 设置cookie 使用setcookie方法来设置一个cookie。因为cookie是HTTP头的一部分，所以你必须在发送数据到浏览器之前设置cookie。例如：
setcookie(&#39;user&#39;, &#39;Tom&#39;, time( + 86400), &#39;/&#39;);  参数说明：
 创建一个名称为user的cookie (可选)为这个cookie设置值Tom (可选)这个cookie将会在1天之后过期 (可选)这个cookie在整个站点/中都有效 (可选)cookie只能使用HTTPS传输 (可选)cookie不能被类似JavaScript的脚本语言访问   创建或修改一个cookie只能在(path和domain指定的)子请求生效，在$_COOKIE也不是立即生效的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-28.html</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-28.html</guid>
      <description>Session session_start() 开启PHP的session，我们可以给session_start函数传一个session的选项数组。例如：
&amp;lt;?php if(version_compare(PHP_VERSION, &#39;7.0.0&#39;) &amp;gt;= 0) { session_start([ &#39;cache_limiter&#39; =&amp;gt; &#39;private&#39;, &#39;read_and_close&#39; =&amp;gt; true, ]); } else { session_start(); }  这个功能在php.ini提供了新的配置项session.lazy_write，这个值默认是true，当session修改的时候session的数据将会被重写。
查看手册。
Session锁 正如我们知道的PHP会把session数据希尔服务器的一个文件中。当一个使用session_start启动session的脚本接收到一个请求的时候，PHP将会锁定这个session文件，从而阻止/等待同一session_id的其他请求。因此其他请求将会在session_start的位置阻塞，直到这个session文件释放锁定。
这个session文件将会被锁定，直到脚本执行完毕或者session手动关闭了。为了避免这种情况(避免多个请求被阻塞)。我们开启一个session并且当操作完毕之后关闭这个session，这样就会释放文件锁，其他的请求就可以继续进行。
// php &amp;lt; 7.0 // start session session_start(); // write data to session $_SESSION[&#39;id&#39;] = 123; // session file is locked, so other requests are blocked // close the session, release lock session_write_close();  现在有些人会想，如果session关闭，我们如何读取到session值。在session关闭后，session仍然是可用的。所以，我们仍然可以读取session数据。
echo $_SESSION[&#39;id&#39;]; //123  在PHP7.0之后，我们可以使用只读session，读写session，延迟写session，这样我们就没有必要使用session_write_close()。
操作session数据 $_SESSION就是一个数组，所以你可以像普通数组一样检索和操作它。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-27.html</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-27.html</guid>
      <description>命名空间 声明命名空间 一个命名空间可以像下面这样：
 namespace MyProject 声明一个命名空间MyProject namespace MyProject\Security\Cryptography 声明一个嵌套的命名空间 namespace MyProject {…} 声明一个花括号包围的命名空间  虽然你可以在一个文件中声明多个命名空间，但是强烈建议一个文件只声明一个命名空间：
namespace First { class A { ... }; // Define class A in the namespace First. } namespace Second { class B { ... }; // Define class B in the namespace Second. } namespace { class C { ... }; // Define class C in the root namespace. }  每当你声明了一个命名空间，你在之后定义的类都在这个命名空间里面：
namespace MyProject\Shapes; class Rectangle { .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-26.html</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-26.html</guid>
      <description>类和对象 类和对象通过将相同功能代码组合起来来提高代码的效率和减少代码的重复。
一个类用来定义一组生成对象的数据结构和行为。然后通过这个结构生成多个对象。
类常量 类常量提供了在程序中保存固定值的方式。也就是，他们提供了一种将名称(以及相关的编译时检查)赋予类似3.14和apple这样值的方法。类常量只能使用const关键字定义，不能使用define这个方法。
例如下面这个例子，定义了π在程序中的简短表示。在类中使用const来将这些值保存下来：
class MathValues { const PI = M_PI; const PHI = 1.61803; } $area = MathValues::PI * $radius * $radius;  类常量使用双冒号运算符(所谓的作用域解析运算符)来访问，很像静态变量。但是和静态变量不同的是，类常量是在编译时确定的，不能进行赋值操作(例如MathValues::PI = 7将会产生致命错误)。
类常量可以用来定义类内部的内容，这些内容稍后可能需要更改(但更改频率不足以保存到数据库)。我们可以在内部使用self域名解析器来处理它(在实例和静态实现中都有效)。
class Labor { const LABOR_UNITS = 0.26; // const LABOR_COST = 12.75; public function getLaborConst($number_units) { return (self::LABOR_UNITS * self::LABOR_COST) * $number_units; } }  在PHP5.6之前，类常量只需要包含标量值。
在PHP5.6我们可以在常量定义使用表达式，这包括：数学运算，字符串拼接。
class Labor { const LABOR_COSTS = 12.75 * 0.26; public function getLaborCost($number_units) { return self::LABOR_COSTS * $number_units; } }  在PHP7，我们可以使用define定义常量的值为数组。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-25.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-25.html</guid>
      <description>字符串解析 分割字符串 explode和strstr是用来是用分隔符获取字符串子串的方法。
一个字符串包含使用相同分隔符分割的几部分，可以使用explode将字符串分成几部分：
$fruits = &amp;quot;apple,pear,grapefruit,cherry&amp;quot;; print_r(explode(&#39;,&#39;, $fruits)); // [&#39;apple&#39;, &#39;pear&#39;, &#39;grapefruit&#39;, &#39;cherry&#39;]  这个方法支持一个参数，用来限制分割的子串数量：
$fruits = &#39;apple,pear,grapefruit,cherry&#39;; print_r(explode(&#39;,&#39;,$fruits,0)); // [&#39;apple,pear,grapefruit,cherry&#39;]  如果这个参数是0，将会按照1处理。
如果这个限制参数是大于0的值，将会返回最多包含这个值的子串，其中最后一个子串包含所有剩余的部分。
print_r(explode(&#39;,&#39;,$fruits,2)); // [&#39;apple&#39;, &#39;pear,grapefruit,cherry&#39;]  如果这个参数为负数，将会返回处理最后这几个子串之外的其他子串：
print_r(explode(&#39;,&#39;,$fruits,-1)); // [&#39;apple&#39;, &#39;pear&#39;, &#39;grapefruit&#39;]  explode可以使用list来把子串放入不同的变量中：
$email = &amp;quot;user@example.com&amp;quot;; list($name, $domain) = explode(&amp;quot;@&amp;quot;, $email);  但是要保证explode返回足够的值，否则将会参数index未定义的错误。
strstr将会把字符串分为两部分，然后根据第二个参数确定返回哪部分，默认返回后面的部分：
$string = &amp;quot;1:23:456&amp;quot;; echo json_encode(explode(&amp;quot;:&amp;quot;, $string)); // [&amp;quot;1&amp;quot;,&amp;quot;23&amp;quot;,&amp;quot;456&amp;quot;] var_dump(strstr($string, &amp;quot;:&amp;quot;)); // string(7) &amp;quot;:23:456&amp;quot; var_dump(strstr($string, &amp;quot;:&amp;quot;, true)); // string(1) &amp;quot;1&amp;quot;  子串 substr返回字符串指定开始位置和指定长度的子字符串。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-24.html</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-24.html</guid>
      <description>字符串格式 字符串插值 你可以使用字符串插值在字符串中插入一个变量。字符串插值只在双引号字符串和heredoc表达式中有效。
$name = &#39;Joel&#39;; //$name会解析为Joel echo &amp;quot;&amp;lt;p&amp;gt;Hello $name, Nice to see you.&amp;lt;/p&amp;gt;&amp;quot;; //将会输出&amp;lt;p&amp;gt;Hello Joel, Nice to see you.&amp;lt;/p&amp;gt; //单引号，变量不会解析 echo &#39;Hello $name, Nice to see you.&#39;; //输出：Hello $name, Nice to see you.  复杂（花括号）语法提供了另一种在字符串中插入变量的语法，就是在变量的周围加上{}。这在变量和文本在一起时是很有用的，避免可能存在的变量和文本引起的歧义。
$name = &#39;Joel&#39;; // Example using the curly brace syntax for the variable $name echo &amp;quot;&amp;lt;p&amp;gt;We need more {$name}s to help us!&amp;lt;/p&amp;gt;&amp;quot;; #&amp;gt; &amp;quot;&amp;lt;p&amp;gt;We need more Joels to help us!&amp;lt;/p&amp;gt;&amp;quot; // This line will throw an error (as `$names` is not defined) echo &amp;quot;&amp;lt;p&amp;gt;We need more $names to help us!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-23.html</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-23.html</guid>
      <description>控制结构备用语法 if/else语句 &amp;lt;?php if ($condition): do_something(); elseif ($another_condition): do_something_else(); else: do_something_different(); endif; ?&amp;gt; &amp;lt;?php if ($condition): ?&amp;gt; &amp;lt;p&amp;gt;Do something in HTML &amp;lt;/p&amp;gt; &amp;lt;?php elseif ($another_condition): ?&amp;gt; &amp;lt;p&amp;gt;Do something else in HTML&amp;lt;/p&amp;gt; &amp;lt;?php else: ?&amp;gt; &amp;lt;p&amp;gt;Do something different in HTML &amp;lt;/p&amp;gt; &amp;lt;?php endif; ?&amp;gt;  for &amp;lt;?php for ($i = 0; $i &amp;lt; 10; $i++): do_something($i); endfor; ?&amp;gt; &amp;lt;?php for ($i=0; $i &amp;lt; 10; $i++): ?&amp;gt; &amp;lt;p&amp;gt;Do something in HTML with &amp;lt;?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-22.html</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-22.html</guid>
      <description>函数式编程 PHP的函数式编程依赖于函数。PHP中的函数提供了组织和重用代码段的功能。函数简化了编码过程，防止冗余的代码，并使代码编译维护。这个主题描述了PHP中函数、形参，实参，返回语句和作用域的声明和使用。
闭包 闭包就是一个不能外部访问的匿名函数。
当声明一个匿名函数，你也就创建了这个函数的&amp;rdquo;命名空间&amp;rdquo;。它现在只有在这个命名空间可以访问。
$externalVariable = &amp;quot;Hello&amp;quot;; $secondExternalVariable = &amp;quot;Foo&amp;quot;; $myFunction = function() { var_dump($externalVariable, $secondExternalVariable); //返回错误，因为变量没有定义 };  这个函数没有访问外部变量的权限。想要使用外部的变量，你可以使用use()来将外部变量放入闭包函数内部：
$myFunction = function() use($externalVariable, $secondExternalVariable) { var_dump($externalVariable, $secondExternalVariable); };  这主要由于PHP严格变量范围：如果一个变量没有在命名空间中定义，并且没有使用global引入进来，这个变量就没有定义。
也要注意：
 从父命名空间继承变量和使用全局变量是不一样的。全局变量在全局命名空间中，不论函数在哪里执行。闭包函数的父命名空间是闭包定义的地方(而不是函数实际调用的地方)。
 查看PHP手册。
在PHP中，闭包使用早期绑定方法。这意味着使用use关键字传递给闭包命名空间的变量的值是闭包定义时的值。
想要修改这种行为的话，可以使用引用传值：
$rate = .05; $calculateTax = function($value) use ($rate) { return $value * $rate; } $rate = .1; print $calculateTax(100); //5 $rate = .05; $calculateTax = function($value) use (&amp;amp;$rate) { return $value * $rate; } $rate = .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-21.html</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-21.html</guid>
      <description>函数 可变长度参数 Version&amp;gt;=5.6
PHP5.6提供了可变长度的参数列表。在变量名前添加…运算符表示这个变量是可变参数。这个变量将会包含这个位置之后所有参数的一个数组。
function variadic_func($nonVariadic, ...$variadic) { echo json_encode($variadic); } variadic_func(1, 2, 3, 4); // prints [2,3,4]  可以在...符号前面添加类型名称：
function foo(Bar ...$bars) {}  &amp;amp;可以添加在…之前，变量名称之后，就像下面这个例子：
class Foo{} function a(Foo &amp;amp;...$foos){ $i = 0; foreach($foos as &amp;amp;$foo){ // note the &amp;amp; $foo = $i++; } } $a = new Foo; $c = new Foo; $b =&amp;amp; $c; a($a, $b); var_dump($a, $b, $c);  这将会输出：
int(0) int(1) int(1)  另一方面，可以解压缩数组（或Traversable）以便以参数列表的形式传递给函数：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-20.html</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-20.html</guid>
      <description>循环 循环是编程语言非常重要的部分。这允许程序员创作循环执行几次的代码片段或者迭代处理。循环的次数可以是显示的(例如6次)，或者循环直到遇到了某个条件。
这个主题包括不同类型的循环结构，他们关联的控制结构，他们潜在的应用。
continue  continue中断一个循环中当前的迭代，但是不会中断这个循环。
 就像break语句一样，continu语句是在循环体内部的。当执行了continu语句，将会立即跳到循环条件判断语句。
在下面的例子中，循环根据数组的值输出指定的信息，但是跳过指定的值。
$list = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]; foreach ($list as $value) { if ($value == &#39;banana&#39;) { continue; } echo &amp;quot;I love to eat {$value} pie.&amp;quot; . PHP_EOL; }  这将会输出：
I love to eat apple pie. I love to eat cherry pie;  continue也可以用来中断外部循环通过为continue提供中断循环的级数。例如，data的数据向下面一样，为了找到花费小于5的水果派：
$data = [ [&#39;Fruit&#39; =&amp;gt; &#39;Apple&#39;, &#39;Color&#39; =&amp;gt; &#39;Red&#39;, &#39;Cost&#39; =&amp;gt; 1], [&#39;Fruit&#39; =&amp;gt; &#39;Banana&#39;, &#39;Color&#39; =&amp;gt; &#39;Yellow&#39;, &#39;Cost&#39; =&amp;gt; 7], [&#39;Fruit&#39; =&amp;gt; &#39;Cherry&#39;, &#39;Color&#39; =&amp;gt; &#39;Red&#39;, &#39;Cost&#39; =&amp;gt; 2], [&#39;Fruit&#39; =&amp;gt; &#39;Grape&#39;, &#39;Color&#39; =&amp;gt; &#39;Green&#39;, &#39;Cost&#39; =&amp;gt; 4] ]; foreach($data as $fruit) { foreach($fruit as $key =&amp;gt; $value) { if ($key == &#39;Cost&#39; &amp;amp;&amp;amp; $value &amp;gt;= 5) { continue 2; } } var_dump($fruit); }  当continue 2;执行的时候，程序立即跳转到$data as $fruit，然后开始执行下一个外部循环，调过了其他的代码(包括内部循环的条件语句)。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</guid>
      <description>控制结构 if else if语句允许当满足条件时，执行一段代码。当你想条件不满足时执行另外的代码可以使用if else。
if ($a &amp;gt; $b) { echo &amp;quot;a is greater than b&amp;quot;; } else { echo &amp;quot;a is not greater than b&amp;quot;; }  查看PHP手册。
三元运算符是if-else的短语法 三元预算符根据条件是true还是false来执行一些条件。这是一个比较预算符，通常用来将if-else语句变成简单的格式。这允许快速测试一个条件，然后通常用来替换多行的if语句，让你的代码更加紧凑。
下面就是一个三元运算符的例子，这里$a=1,$b=2:
echo ($a &amp;gt; $b) ? &amp;quot;a is greated than b&amp;quot; : &amp;quot;a is not greater than b&amp;quot;;  输出：a is not greater than b
控制结构备用语法 PHP提供了控制结构备用的语法：if while for foreach switch。
和普通的语法相比，不同的地方在于：这里使用:来代替开始花括号，使用endif; endwhile; endfor; endforeach; endswitch;来代替结束花括号。有关各个示例，请参阅有关控制结构的备用语法的主题。
if ($a == 42): echo &amp;quot;The answer to life, the universe and everything is 42.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</guid>
      <description>操作日期和时间 获取两个时间的差 最可行的方法是使用DateTime类。例如：
&amp;lt;?php //创建一个指定时间的对象 2年前 $twoYearAgo = new DateTime(&#39;2017-04-29 22:00:00&#39;); //创建一个当前时间的对象 $now = new DateTime(&#39;2019-04-29 22:00:00&#39;) //计算差 $diff = $now-&amp;gt;diff($twoYearAgo); //获取diff结果中的数据 $yearsDiff = $diff-&amp;gt;y; $monthsDiff = $diff-&amp;gt;m; $daysDiff = $diff-&amp;gt;d; $hoursDiff = $diff-&amp;gt;h; $minsDiff = $diff-&amp;gt;i; $secondsDiff = $diff-&amp;gt;s; //差别的天数 $totalDaysDiff = $diff-&amp;gt;days; var_dump($diff);  另外比较两个日期也是很简单的，直接使用比较运算符：
&amp;lt;?php // Create a date time object, which has the value of ~ two years ago $twoYearsAgo = new DateTime(&amp;quot;2014-01-18 20:05:56&amp;quot;); // Create a date time object, which has the value of ~ now $now = new DateTime(&amp;quot;2016-07-21 02:55:07&amp;quot;); var_dump($now &amp;gt; $twoYearsAgo); // prints bool(true) var_dump($twoYearsAgo &amp;gt; $now); // prints bool(false) var_dump($twoYearsAgo &amp;lt;= $twoYearsAgo); // prints bool(true) var_dump($now == $now); // prints bool(true)  转换日期格式 基本 最简单的转换日期的格式是联合使用strtotime和date。strtotime函数会把一个字符串时间转换为一个Unix时间戳。这个Unix的时间戳可以使用函数date转换为一个新的格式：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</guid>
      <description>Datetime类 可变到不可变 从PHP5.6之前的可变版本到现在的不可变版本。
在PHP5.6之后创建一个\DateTimeImmutable类：
\DateTimeImmutable::createFromMutable($concrete);  在PHP5.6之前：
\DateTimeImmutable::createFromFormat(\DateTime::ISO8601, $mutable-&amp;gt;format(\DateTime::ISO8601), $mutable-&amp;gt;getTimezone());  加减日期间隔 我们可以使用DateInterval在DateTime对象上增加或减少一定时间间隔。
下面的例子，我们在对象上增加7天，然后打印输出到屏幕上面：
$now = new DateTime();// empty argument returns the current date $interval = new DateInterval(&#39;P7D&#39;);//this objet represents a 7 days interval $lastDay = $now-&amp;gt;add($interval); //this will return a DateTime object $formatedLastDay = $lastDay-&amp;gt;format(&#39;Y-m-d&#39;);//this method format the DateTime object and returns a String echo &amp;quot;Samara says: Seven Days. You&#39;ll be happy on $formatedLastDay.&amp;quot;;  这将会输出(在2019-04-29时运行)：
  Samara says: Seven Days.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</guid>
      <description>一次处理多个数组 数组交集 array_intersect将会将所有数组中共有的值放入一个数组中。
$array_one = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]; $array_two = [&#39;two&#39;, &#39;three&#39;, &#39;four&#39;]; $array_three = [&#39;two&#39;, &#39;three&#39;]; $intersect = array_intersect($array_one, $array_two, $array_three); // $intersect contains [&#39;two&#39;, &#39;three&#39;]  第一个数组的key将会被保留，数字索引不会。
array_intersect只会检查数组的值，array_intersect_assoc将会对key也进行比较：
$array_one = [1 =&amp;gt; &#39;one&#39;,2 =&amp;gt; &#39;two&#39;,3 =&amp;gt; &#39;three&#39;]; $array_two = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;, 3 =&amp;gt; &#39;two&#39;, 4 =&amp;gt; &#39;three&#39;]; $array_three = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;]; $intersect = array_intersect_assoc($array_one, $array_two, $array_three); // $intersect contains [1 =&amp;gt;&#39;one&#39;,2 =&amp;gt; &#39;two&#39;]  array_intersect_key将会检查数组的key，将会返回数组中都存在的key：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</guid>
      <description>操作数组 筛选数组 从数组中筛选值，并且把按照筛选条件找出的值放入一个新数组中，可以使用array_filter函数。
筛选非空数组 一个简单例子来筛选非空的值：
$myArray = [1, 0, 2, null, 3, &#39;&#39;, 4, [], 5, 6, 7, 8]; $nonEmpties = array_filter($myArray); //[1, 2, 3, 4, 5, 6, 7, 8];  使用回调筛选 我们可以定义我们自己的筛选规则。这里假设我们想要偶数值：
$myArray = [1, 2, 3, 4, 5, 6, 7, 8]; $evenNumbers = array_filter($myArray, function($number) { return $number % 2 === 0; })  array_filter的第一个参数是等待筛选的数组，第二个参数是定义筛选规则的回调函数。
按索引筛选 Version &amp;gt;= 5.6
array_filter的第三个参数是用来决定哪个值传递给回调函数。这个参数有两个选项：ARRAY_FILTER_USE_KEY 或 ARRAY_FILTER_USE_BOTH。这决定回调函数的参数是数组的key还是key和值都有。例如，你想要使用索引而不是值：
$numbers = [16,3,5,8,1,4,6]; $even_indexed_numbers = array_filter($numbers, function($index) { return $index % 2 === 0; }, ARRAY_FILTER_USE_KEY);  筛选结果数组的索引 注意：array_filter函数会保留原本数组的key。一个常见的错误是使用for循环处理筛选后的数组：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</link>
      <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</guid>
      <description>对数组操作 对数组每个元素进行函数处理 对数组每一个元素进行函数的处理，使用array_map函数。这将会返回一个新的数组。
$array = array(1,2,3,4,5); //each array item is iterated over and gets stored in the function parameter. $newArray = array_map(function($item) { return $item + 1; }, $array);  返回的新数组$newArray的值是array(2,3,4,5,6)。
除了使用匿名函数外，还可以使用一个命名的函数。上面的例子也可以写成下面这样：
function addOne($item) { return $item + 1; } $array = array(1, 2, 3, 4, 5); $newArray = array_map(&#39;addOne&#39;, $array);  如果这个命名函数是一个类的方法，在使用的时候需要保护类的一个对象：
class Example { public function addOne($item) { return $item + 1; } public function doCalculation() { $array = array(1, 2, 3, 4, 5); $newArray = array_map(array($this, &#39;addOne&#39;), $array); } }  另外的对数组每个元素使用方法的函数是array_walk()和array_walk_recursive()。在这些函数中使用的调用函数解释数组每个元素的键/值作为参数。这两个函数不返回一个新的数组，而是函数执行成功与否的布尔值。例如：打印一个简单数组的每个元素：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</guid>
      <description>数组迭代 一次迭代多个数组 有时候两个数组由相同的长度，需要一起迭代处理：
$people = [&#39;Tim&#39;, &#39;Tony&#39;, &#39;Turanga&#39;]; $foods = [&#39;chicken&#39;, &#39;beef&#39;, &#39;slurm&#39;];  array_map可以简单的实现这个要求：
array_map(function($person, $food) { retrun &amp;quot;$person likes $food\n&amp;quot;; }, $people, $foods);  这将会输出：
Tim likes chicken Tony likes beef Turanga likes slurm  这可以通过索引来实现：
assert(count($people) === count($foods)); for ($i = 0; $i &amp;lt; count($people); $i++) { echo &amp;quot;$people[$i] likes $foods[$i]\n&amp;quot;; }  如果没有递增的索引值，需要使用array_values($array)[$i]来代替$array[$i]。
如果两个数组拥有相同的索引，可以使用foreach来处理其中的一个数组：
foreach ($people as $index =&amp;gt; $person) { $food = $foods[$index]; echo &amp;quot;$person likes $food\n&amp;quot;; }  不同的数组只有当它们的长度一样，并且拥有一样的key时，才可以这么处理。这意味着要么多个数组是数字递增的，要么它们是相同的key按照相同的顺序排列的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</link>
      <pubDate>Fri, 12 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</guid>
      <description>数组    参数 详情     Key key是数组唯一的标识和索引。可以是string和integer。因此有效的key包括foo 5 10 a2b   Value 对于每个key都有一个值和其对应（否知就是null，在访问是会出问题）。这个值没有严格限制的类型    一个数组就是存储任意个元素到单独一个值中的数据结构。PHP中的数组实际是一个有序的映射，其中映射是一种键值关联的结构。
数组初始化 一个数组可以是空的。
//空数组 $foo = array(); //从PHP5.4的简短格式 $foo = [];  一个数组可以初始化，并且有值：
//创建3个值的简单数组 $fruit = array(&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;); //5.4之后的简短格式 $fruit = [&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;];  一个数组可以带有自定义索引的值（这时数组叫关联数组）：
//简单关联数组 $fruit = array( &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ); //也可以在之后赋值 $fruit[&#39;first&#39;] = &#39;apples&#39;; //短格式 $fruit = [ &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ];  如果一个变量之前没有用过，PHP将自动创建。虽然方便了，但也让代码更加难读了：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</guid>
      <description>引用 引用赋值 这是引用使用的第一个阶段。实际你在引用赋值的时候，这里允许你两个变量拥有相同的值。
$foo = &amp;amp;$bar;  $foo和$bar是相等的。它们指向相同的地址，而不是不同的地址。
你也可以在array()语言结构中使用引用赋值。并不是严格的引用赋值：
$foo = &#39;hi&#39;; $bar = array(1, 2); $array = array(&amp;amp;$foo, &amp;amp;$bar[0]);   注意：数组里面的引用是非常危险的一种行为。使用右侧引用对左侧进行普通赋值不会将左边变为引用。但是数组中这样的赋值引用将会被保留。在函数中，数组作为值传递时也有这个问题。
 引用赋值不限制在变量和数组中。在函数和所有&amp;rdquo;引用传递的值&amp;rdquo;都可以。
function incrementArray(&amp;amp;$arr) { foreach ($arr as $$val) { $var++; } } function &amp;amp;getArray() { statice $arr = [1, 2, 3]; return $arr; } incremetnArray(getArray()); var_dump(getArray()); //[2,3,4]  赋值是上面函数定义的关键点。不能通过引用传递表达式，只能传递值/变量。
返回引用 偶尔会出现让你通过引用隐藏返回的情况。
 引用返回在函数定义的参数是引用变量的时候非常有用。不要用返回引用来提升性能。PHP引擎会自动处理这些问题。只有在您有有效的技术原因时才返回引用。
 查看返回引用的PHP文档。
有很多不同的方式可以返回引用，包括下面的例子：
function parent(&amp;amp;$var) { echo $var; $var = &amp;quot;updated&amp;quot;; } function &amp;amp;child() { static $a = &amp;quot;test&amp;quot;; return $a; } parent(child()); //返回test parent(child()); //返回updated  引用返回不仅限于函数引用。您还可以隐式调用函数：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</guid>
      <description>运算符 一个运算符就是处理一个或多个值(或表达式，编程术语)，然后产生一个新的值(把本身构造成表达式)的符号。
可以根据运算符操作的数量把它们进行分组。
空合并运算符?? 空合并运算符是PHP7新增加的运算符。如果第一个操作数设置了并不为null，就返回这个运算符。否则返回第二个运算符的值。
下面是一个例子：
$name = $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面这个例子是等价的：
if (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  也和下面等价：
$name = isset($_POST[&#39;name&#39;]) ? $_POST[&#39;name&#39;] : &#39;nobody&#39;;  这个操作符也可以连着使用，从左到右进行处理：
$name = $_GET[&#39;name&#39;] ?? $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面是等价的:
if (isset($_GET[&#39;name&#39;])) { $name = $_GET[&#39;name&#39;]; } elseif (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  注意在字符串中使用空合并运算符，不要忘了使用括号：
$firstName = &amp;quot;John&amp;quot;; $lastName = &amp;quot;Doe&amp;quot;; echo $firstName ?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</guid>
      <description>类型 类型比较符 两种类型的比较符：松散比较符==和严格比较符===。严格比较符要求比较符两端的变量的类型和值都要相同。
// Loose comparisons var_dump(1 == 1); // true var_dump(1 == &amp;quot;1&amp;quot;); // true var_dump(1 == true); // true var_dump(0 == false); // true // Strict comparisons var_dump(1 === 1); // true var_dump(1 === &amp;quot;1&amp;quot;); // false var_dump(1 === true); // false var_dump(0 === false); // false // Notable exception: NAN — it never is equal to anything var_dump(NAN == NAN); // false var_dump(NAN === NAN); // false  你也可以使用严格比较符的相对于的反比较符!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</guid>
      <description>代码注释 单行注释 单行注释使用//或#开头。当遇到的时候，所有符号右边的文本都被PHP解析器忽略。
// This is a comment # This is also a comment echo &amp;quot;Hello World!&amp;quot;; // This is also a comment, beginning where we see &amp;quot;//&amp;quot;  多行注释 多行注释可以用来注释大块的代码，使用/*做开始，*/做结尾。
/* This is a multi-line comment. It spans multiple lines. This is still part of the comment. */  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</guid>
      <description>魔术常量 __FUNCTION__和__METHOD__的不同 __FUNCTION__只返回函数的名称，__METHOD__返回带有类名的函数名称：
&amp;lt;?php class trick { public function doit() { echo __FUNCTION__; } public function doitagain() { echo __METHOD__; } } $obj = new trick(); $obj-&amp;gt;doit(); // Outputs: doit $obj-&amp;gt;doitagain(); // Outputs: trick::doitagain  __CLASS__、get_class和get_called_class的不同 __CLASS__和get_class没有参数情况下的结果一样，都是这两者定义所在的类的名称(调用这个常量或方法的地方)。
相反，get_class($this)和get_called_class()函数都会返回实际调用的类的名称。
&amp;lt;?php class Definition_Class { public function say(){ echo &#39;__CLASS__ value: &#39; . __CLASS__ . &amp;quot;\n&amp;quot;; echo &#39;get_called_class() value: &#39; . get_called_class() . &amp;quot;\n&amp;quot;; echo &#39;get_class($this) value: &#39; . get_class($this) . &amp;quot;\n&amp;quot;; echo &#39;get_class() value: &#39; .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</link>
      <pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</guid>
      <description>常量 定义常量 常量可以使用const语句或者define函数定义。惯例是使用全大写字母作为常量的名称。
明确值定义常量 const PI = 3.14; //float define(&amp;quot;EARTH_IS_FLAT&amp;quot;, false); //boolean const UNKNOWN = null; //null define(&amp;quot;APP_ENV&amp;quot;, &amp;quot;dev&amp;quot;); //string const MAX_SESSION_TIME = 60 * 60; //integer，标量表达式也是可以的 const APP_LANGUAGES = [&amp;quot;de&amp;quot;, &amp;quot;en&amp;quot;]; //数组 define(&amp;quot;BETTER_APP_LANGUAGES&amp;quot;, [&amp;quot;lu&amp;quot;, &amp;quot;de&amp;quot;]); //数组  用常量定义常量 如果你有一个常量，你可以用这个常量定义另外的常量。
cosnt TAU = PI * 2; define(&amp;quot;EARTH_IS_ROUND&amp;quot;, !EARTH_IS_FLAT); define(&amp;quot;MORE_UNKNOWN&amp;quot;, UNKNOWN); define(&amp;quot;APP_ENV_UPPERCASE&amp;quot;, strtoupper(APP_ENV)); //字符串操作也是可以的 //上面的示例(函数调用)不适合const语句 //cosnt TIME = time(); 出现致命错误，不是标量表达式 define(&amp;quot;MAX_SESSION_TIME_IN_MINUTES&amp;quot;, MAX_SESSION_TIME / 60); const APP_FUTURE_LANGUAGES = [-1 =&amp;gt; &#39;es&#39;] + APP_LANGUAGES; //数组操作 define(&amp;quot;APP_BETTER_FUTURE_LANGUAGES&amp;quot;, array_merge([&#39;fr&#39;], APP_BETTER_LANGUAGES));  保留常量 一些常量名称是被PHP保留的，不能被重新定义。下面的例子都是失败的：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</link>
      <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</guid>
      <description>输出变量的值 创建一个动态的、交互的PHP项目，输出变量和他们的值是有用的。PHP提供了多个变量值的输出方法。这里主要介绍标准的输出方法和这些方法的使用场景。
echo和print echo和print是语言结构，不是函数。这意味着它们不想函数那样需要括号在参数的周围(当然也可以在参数的周围添加括号，这样也没有什么问题)。这将会输出变量、常量和表达式的字符串格式。不能用来输出数组和对象。
 把字符串joel赋值给变量$name
$name = &#39;joel&#39;;  使用echo和print来输出$name的值
echo $name; #&amp;gt; Joel print $name; #&amp;gt; Joel  括号不是要求的，但是可以使用
echo($name); #&amp;gt; Joel print($name); #&amp;gt; Joel  使用多个参数(只有echo支持)
echo $name, &amp;quot;Smith&amp;quot;; #&amp;gt; JoelSmith echo($name, &amp;quot; &amp;quot;, &amp;quot;Smith&amp;quot;); #&amp;gt; Joel Smith  print不像echo，是一个返回值为1的表达式，可以被用在更多的地方
print(&amp;quot;hey&amp;quot;) &amp;amp;&amp;amp; print(&amp;quot; &amp;quot;) &amp;amp;&amp;amp; print(&amp;quot;you&amp;quot;); #&amp;gt; you11  下面和上面是相等的
print (&amp;quot;hey&amp;quot; &amp;amp;&amp;amp; (print (&amp;quot; &amp;quot; &amp;amp;&amp;amp; print &amp;quot;you&amp;quot;))); #&amp;gt; you11   echo的简短写法 在outside of PHP tags，echo的简短写法是有效的。使用&amp;lt;?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</guid>
      <description>超全局变量 超全局变量是内建的在任何地方都一直有效的变量。
一些预定义的PHP变量叫做&amp;rdquo;超全局变量&amp;rdquo;，这意味着这些变量在一个脚本的任何作用域都是有效的。不用在函数或方法内使用global $variable来访问这些变量。
超全局变量解释 简介 简单来说，这些变量就是在你的脚本中全部作用域有效的变量。
这意味着没有必要把它们作为参数传递给你的函数，或者为了让不同的作用域访问这些变量把他们存放在块作用域之外。
什么是超全局变量？ 如果你认为它们就像超级英雄一样-它们不是的。
在PHP 7.1.3之后，有9个超全局变量，下面是它们的列表：
 $GLOBALS：包含所有的全局变量 $_SERVER：服务器和执行环境的信息 $_GET：HTTP GET的变量 $_POST：HTTP POST的变量 $_FILES：HTTP文件上传变量 $_COOKIE：HTTP的Cookie $_SESSION：Session变量 $_REQUEST：HTTP的请求变量 $_ENV：环境变量  查看文档。
更多信息 这里是它的参考资料。
是时候解释这些超全局变量了。
$GLOBALS  一个定义了当前脚本定义的所有全局作用域的变量的关联数组。变量名就是这个数组的键。
 代码：
$myGlobal = &amp;quot;global&amp;quot;; function test() { $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&#39;myGlobal&#39;]); } test(); var_dump($myLocal); var_dump($myGlobal);  输出：
string &#39;local&#39; (length=5) string &#39;global&#39; (length=6) null string &#39;global&#39; (length=6)  在上面的例子中$myLocal第二次没有显示因为这个变量定义在函数test()内部，当函数关闭之后这个变量就销毁了。
变为全局 实现这个有两种方法。
第一种方法：global关键字
function test() { global $myLocal; $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&amp;quot;myGloabl&amp;quot;]); }  这个关键字global放到变量前面，强制这个变量变为全局作用域变量。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</guid>
      <description>变量作用域 变量作用域表示变量可以被访问到的代码范围。这也经常被称为可见性。PHP的块作用域是函数，类定义的。一个全局作用域变量在整个应用都是有效的。
超全局变量 超全局变量是PHP定义的，可以在任何地方使用而不需要使用global关键字。
&amp;lt;?php function getPostValue($key, $default = NULL) { // $_POST is a superglobal and can be used without // having to specify &#39;global $_POST;&#39; if (isset($_POST[$key])) { return $_POST[$key]; } return $default; } // retrieves $_POST[&#39;username&#39;] echo getPostValue(&#39;username&#39;); // retrieves $_POST[&#39;email&#39;] and defaults to empty string echo getPostValue(&#39;email&#39;, &#39;&#39;);  静态属性和变量 定义为public的静态类属性和全局变量的功能类似。在任何类定义的地方都可以访问他们。
class SomeClass { public static int $counter = 0; } // The static $counter variable can be read/written from anywhere // and doesn&#39;t require an instantiation of the class SomeClass::$counter += 1;  可以在函数内部定义静态变量。这些静态变量可以在多次调用之间保持存在，这个定义在函数中的普通变量不同。这可以非常简单的实现单例模式。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</guid>
      <description>变量 变量的变量 可以通过动态的变量名字访问变量。任务允许被动态访问的变量的名字都可以放到另一个变量内。这样的变量就叫做变量的变量。
想要把一个变量放到另一个变量里面，可以在变量的前面添加一个额外的$符。
$variableName = &#39;foo&#39;; $foo = &#39;bar&#39;; //下面这些都是等价的，都会输出bar echo $foo; echo ${$variableName}; echo $$variableName; //下面相似的 $variableName = &#39;foo&#39;; $$variableName = &#39;bar&#39;; //下面的语句也会输出bar echo $foo; echo ${$variableName}; echo $$variableName;  变量的变量对于映射函数/方法非常有用。
function add($a, $b) { return $a + $b; } $funcName = &#39;add&#39;; echo $funcName(1, 2); // outputs 3  这在PHP的类里面是特别有用的：
class myClass { public function __construct() { $functionName = &#39;doSomething&#39;; $this-&amp;gt;$functionName(&#39;Hello World&#39;); } private function doSomething($string) { echo $string; // Outputs &amp;quot;Hello World&amp;quot; } }  可以单并不要求把变量$variableName放到{}里面：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</guid>
      <description>开始使用PHP PHP 7.x
   版本 支持截止时间 发版时间     7.1 2019-12-01 2016-12-01   7.0 2018-12-03 2015-12-03    PHP 5.x
   版本 支持截止时间 发版时间     5.6 2018-12-31 2014-08-28   5.5 2016-07-21 2013-06-20   5.4 2015-09-03 2012-03-01   5.3 2014-08-14 2009-06-30   5.2 2011-01-06 2006-11-02   5.1 2006-08-24 2005-11-24   5.0 2005-09-05 2004-07-13    PHP 4.</description>
    </item>
    
  </channel>
</rss>