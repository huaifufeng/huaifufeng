<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PHP on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/categories/php/</link>
    <description>Recent content in PHP on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 14 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/categories/php/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PHP专业笔记（一百零五）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-105.html</link>
      <pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-105.html</guid>
      <description>为PHP核心做贡献 1. 配置基本的开发环境 PHP的源码保存在GitHub上面。想要从源码构建，你首先要从代码复制一份。
mkdir /usr/local/src/php-7.0/ cd /usr/local/src/php-7.0/ git clone -b PHP-7.0 https://github.com/php/php-src .  如果你想要添加一个特性，最好是在自己的分支上面进行：
git checkout -b my_private_branch  最后，configure然后build：
./buildconf ./configure make make test make install  如果因为缺少依赖而configure失败，你需要使用你系统的包管理工具来安装依赖(yum， apt等)，或者下载从源码进行编译。
参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（一百零四）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-104.html</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-104.html</guid>
      <description>为PHP手册做贡献 PHP手册包含解释PHP主要特性的函数引用和语言引用。PHP手册不像大多数的语言手册，允许PHP开发者在手册的每一页添加它们自己的例子和注释。本主题解释了对PHP手册的贡献，以及最佳实践的提示、技巧和指南。
1. 改进官方文档 PHP有一个非常好的官方文档，在https://www.php.net/manual/zh/index.php。PHP手册记录了几乎所有的语言特性，核心库和大多数可用的扩展。有很多例子可以学习。PHP手册有多种语言和格式。
最重要的是，文档是免费的，允许任何人编辑。
PHP手册团队提供了一个PHP手册的在线编辑器，地址是https://edit.php.net。它支持多个单一登录服务，包括使用Stack Overflow账号。你可以在https://wiki.php.net/doc/editor 找到编辑器的介绍。
对PHP手册的更改需要得到拥有*Doc Karma*的PHP手册团队人员批准。Doc Karma有点像荣誉，但是很难获得。每个审查过程都只是要确保正确的信息进入手册。
这个手册是使用DocBook编写的，这是非常容易学习的编写图书的标记语言。乍一看，它可能有点复杂，但有一些模板可以让您开始。你当然不需要成为一个DocBook专家来做出贡献。
2. 为手册作出贡献的提示 以下是希望为PHP手册做出贡献的人员的提示列表：
 遵守手册的样式指南。确保始终遵循手册的样式指南，以保持一致性。 执行拼写和语法检查。确保使用正确的拼写和语法 - 否则提供的信息可能更难被接受，内容看起来也不专业。 解释要简明扼要。避免冗长，清楚简明的像查询手册的开发人员提供信息。 将代码和输出分开。这为开发人员提供了更清晰、更简单的代码示例。 检查页面章节的顺序。确保手册中页面所有的章节被以正确的顺序编写。手册的统一性使快速阅读和查找信息变得更加容易。 溢出PHP 4相关内容。考虑到PHP4的例子，关于它的特定提示不在需要。应将其从手册中删除，以防将其与不必要的信息混淆。 正确的版本文件。在文档中创建新文件的时候，确保文件的revision ID设置为nothing。像&amp;lt;!-- $Revision$ --&amp;gt; 把有用的注释合并到手册中。一些评论提供了手册可能从中受益的有用信息。这些应该合并到主页的内容中。 不要破坏文件的构建。在提交更改之前，一定要确保正确地构建PHP手册。  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（一百零三）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-103.html</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-103.html</guid>
      <description>密码hash函数 更安全的web服务器应该避免存储文本格式的密码，像PHP这样的语言提供了(非解密)的hash函数来支持更加安全的工业标准。这个主题主要介绍PHP的hash函数。
1. 创建一个密码hash 使用password_hash()生成密码的hash，使用当前工业最佳实践的标准hash或key派生。在编写时，标准是bcrypt。所以，PASSWORD_DEFAULT意味着PASSWORD_BCRYPT。
$options = [ &#39;cost&#39; =&amp;gt; 12, ]; $hashedPassword = password_hash($plaintextPassword, PASSWORD_DEFAULT, $options);  第三个参数是非必须的。
这个cost的值根据你生产服务器的硬件决定。增加这个值在生成密码是花费更多的资源。生产的成本越高，任何试图破解的人花费的成本越高。理想情况下，cost应该越高越好，但是实际它应该设置不是任何事情变太慢。通常0.1~0.4秒就可以了。如果有疑问就是用默认值。
Version &amp;lt; 5.5
在PHP低于5.5.0时，passowrd_*函数是无效的。你可以使用https://github.com/ircmaxell/password_compat来替代这些方法。注意这个兼容包要求PHP 5.3.7或者更高版本或者将$y2反向安装在其中的版本(如Redhat提供的版本)。
当你不能使用那些的时候，你可以使用crypt()函数实现一个密码hash方法。password_hash()是实现的crypt()函数的一个封装，你需要丢失一些功能。
// this is a simple implementation of a bcrypt hash otherwise compatible // with `password_hash()` // not guaranteed to maintain the same cryptographic strength of the full `password_hash()` // implementation // if `CRYPT_BLOWFISH` is 1, that means bcrypt (which uses blowfish) is available // on your system if (CRYPT_BLOWFISH == 1) { $salt = mcrypt_create_iv(16, MCRYPT_DEV_URANDOM); $salt = base64_encode($salt); // crypt uses a modified base64 variant $source = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;; $dest = &#39;.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十九）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-99.html</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-99.html</guid>
      <description>多线程扩展 1. 开始 想要开启多线程，你需要安装php的pthreads-ext扩展。可以使用下面的命令：
pecl install ptheads  然后在php.ini中添加条目。
简单的例子：
&amp;lt;?php //代码使用php7语法 class MyThead extends Thread { /** * @var string * 包含要显示信息的变量 */ private $message; public function __construct(string $message) { //设置信息内容 $this-&amp;gt;message = $message; } //另个线程中执行的方法 public function run() { echo $this-&amp;gt;message; } } //实例化MyThead $myThead = new MyThead(&amp;quot;来自另一个线程的问候&amp;quot;); //开启线程。始终显式的join线程是一个好实践 //Thread::start()用来初始化线程 $myThead-&amp;gt;start(); //Thread::join()通知环境等待线程执行结束 $myThead-&amp;gt;join();  2. 使用pool和worker  Pooling提供了更高级的Worker功能的抽象，包括pthreads所需的方式管理引用。https://www.php.net/manual/zh/class.pool.php
 Pools和Workers提供了更高级别的控制，并易于创建多线程。
&amp;lt;?php //这是被worker运行的 Work //这是你希望在worker中运行的work //这个类需要继承 \Threaded 或 \Collectable 或 \Thread类 class AwesomeWork extends Thread { private $workName; /** * @param string workName * 提供给每个work的名称 */ public function __construct(string $workName) { //你work的构造代码块，当work被添加到pool的时候执行 $this-&amp;gt;workName = $workName; printf(&amp;quot;新提交的work的名称是：%s\n&amp;quot;, $workName); } public function run() { //这个方法应该被worker调用 //所有这个方法的代码被另一个线程执行 $workName = $this-&amp;gt;workName; printf(&amp;quot;Work的名称%s开启.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十八）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-98.html</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-98.html</guid>
      <description>多进程 1. 内建的fork函数实现多进程 你可以使用内置函数以fork的形式来运行PHP进程。如果不需要线程进行通信，这是实现并行工作的最简单的方法。
这允许你将时间密集型任务(如将文件上传到另一个服务器或发送电子邮件)放到另一个线程，这样你的脚本加载更快，可以使用多核心，但是注意，这不是真正的多线程，你的主线程将不知道子线程在做什么。
注意 ，在Windows下面，这将使你启动的每个分叉都弹出另一个命令提示。
master.php
$cmd = &#39;php worker.php 10&#39;; if (strtoupper(substr(PHPP_OS, 0, 3)) === &#39;WIN&#39;) { //windows使用popen和pclose pclose(popen($cmd, &#39;r&#39;)); } else { //unix使用shell命令，&amp;amp;结尾 exec(&#39;bash -c &amp;quot;exec nohup setsid &#39;. $cmd . &#39; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;quot;&#39;); }  worker.php
//发送邮件，上传文件，分析日志等等 $sleeptime = $argv[1]; sleep($sleeptime);  2. 使用fork创建子进程 PHP有内建的函数pcntl_fork来创建子进程。pcntl_forl和unix的fork是相同的。它没有任何参数，然后一个用来区分父子进程的证书。下面是一个展示的例子：
&amp;lt;?php //$pid是子进程的PID $pid = pcntl_fork(); if ($pid == -1) { die(&amp;quot;创建子进程失败&amp;quot;); } else if ($pid) { //父进程 } else { //子进程 } ?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十七）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-97.html</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-97.html</guid>
      <description>性能 1. Xdebug分析 一个叫做Xdebug的PHP扩展用来帮助分析PHP英语程序以及运行时调试。当运行这个分析器的时候，输出将会以二进制格式写入到cachegrind文件中。每个平台都有应用程序来分析这个文件。
想要启用分析的话，需要安装这个扩展并且修改php.ini的配置。在我们的例子中，我们根据请求的参数允许分析。这允许我们保持配置静态，只在需要的时候启用分析。
// Set to 1 to turn it on for every request xdebug.profiler_enable = 0 // Let&#39;s use a GET/POST parameter to turn on the profiler xdebug.profiler_enable_trigger = 1 // The GET/POST value we will pass; empty for any value xdebug.profiler_enable_trigger_value = &amp;quot;&amp;quot; // Output cachegrind files to /tmp so our system cleans them up later xdebug.profiler_output_dir = &amp;quot;/tmp&amp;quot; xdebug.profiler_output_name = &amp;quot;cachegrind.out.%p&amp;quot;  然后在客户端中发起你希望进行分析的应用地址的请求：
http://example.com/article/1?XDEBUG_PROFILE=1  这个请求将会在类似下面名称的文件中写入数据：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十六）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-96.html</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-96.html</guid>
      <description>单元测试 1. 测试类规则 例如，我们有一个简单的LoginForm类，这个类有一个方法rules()（在登录页面中用作框架的模板）：
class LoginForm { public $email; public $rememberMe; public $password; /** * rules()方法返回一个字段是否需要的数组 * 登录表格使用email和password来登录 */ public function rules() { return [ //email和password是必须的 [[&#39;email&#39;, &#39;password&#39;], &#39;required&#39;], //email必须是email格式的 [&#39;email&#39;, &#39;email&#39;], //rememberMe必须是布尔值 [&#39;rememberMe&#39;, &#39;boolean&#39;], //password必须匹配正则 必须只包含字母和数字 [&#39;password&#39;, &#39;match&#39;, &#39;pattern&#39; =&amp;gt; &#39;/^[a-z0-9]+$/&#39;], ]; } /** 验证规则正确性的方法 */ public function validate($rule) { $success = true; list($vars, $type) = $rule; foreach((array) $vars as $var) { switch($type) { case &#39;required&#39;: $success = $success &amp;amp;&amp;amp; $var !</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十五）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-95.html</link>
      <pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-95.html</guid>
      <description>调试 1. 输出变量 var_dump方法允许你输出变量的内容(类型和值)，来进行调试：
例子：
$array = [3.7, &amp;quot;string&amp;quot;, 10, [&amp;quot;hello&amp;quot; =&amp;gt; &amp;quot;world&amp;quot;], false, new DateTime()]; var_dump($array);  输出
array(6) { [0]=&amp;gt; float(3.7) [1]=&amp;gt; string(6) &amp;quot;string&amp;quot; [2]=&amp;gt; int(10) [3]=&amp;gt; array(1) { [&amp;quot;hello&amp;quot;]=&amp;gt; string(5) &amp;quot;world&amp;quot; } [4]=&amp;gt; bool(false) [5]=&amp;gt; object(DateTime)#1 (3) { [&amp;quot;date&amp;quot;]=&amp;gt; string(26) &amp;quot;2016-07-24 13:51:07.000000&amp;quot; [&amp;quot;timezone_type&amp;quot;]=&amp;gt; int(3) [&amp;quot;timezone&amp;quot;]=&amp;gt; string(13) &amp;quot;Europe/Berlin&amp;quot; } }  2. 显示错误 如果你想要PHP在页面中输出运行时错误，你必须启用display_errors，或者是在php.ini文件中或者是使用ini_set方法。
你可以选择显示什么错误，使用error_reporting方法(或者ini文件)，这接收E_*常量，二进制位运算符的组合。
PHP可以显示text或HTML格式的错误，依赖于html_errors的配置。
例子：
ini_set(&amp;quot;display_errors&amp;quot;, true); ini_set(&amp;quot;html_errors&amp;quot;, false); // Display errors in plain text error_reporting(E_ALL &amp;amp; ~E_USER_NOTICE); // Display everything except E_USER_NOTICE trigger_error(&amp;quot;Pointless error&amp;quot;); // E_USER_NOTICE echo $nonexistentVariable; // E_NOTICE nonexistentFunction(); // E_ERROR  文本输出:（HTML的格式不同）</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十四）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-94.html</link>
      <pubDate>Wed, 03 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-94.html</guid>
      <description>异常处理和错误报告 1. 设置错误报告和在哪里显示 如果没有在php.ini中设置，错误报告可以动态设置，应该允许显示大多数的错误。
语法
int error_reporting([int $level])  例子：
//在5.4之前使用 error_reporting(E_ALL); //-1 将会显示任何可能的错误，即使在之后的PHP版本添加新的等级和常量 E_ALL和5.4之前一样 error_reporting(-1); //处理注意 error_reporting(E_ALL &amp;amp; ~E_NOTICE); //只有警告和注意 //这只是展示，不应该只显示这些 error_reporting(E_WARNING | E_NOTIICE);  错误默认会被PHP记录日志，通常是记录在和运行脚本同级别的error.log文件中。
在开发环境中，也可以把错误输出到显示中：
ini_set(&#39;display_errors&#39;, 1);  在生产环境：
ini_set(&#39;display_errors&#39;, 0);  并且使用异常或错误产生一个友好的错误信息。
2. 记录致命错误日志 在PHP中，致命错误是一种不可以被捕获的错误，也就是，在遇到致命错误后，程序无法恢复执行。但是要记录这个错误或以某种方式崩溃，可以使用register_shutdown_function来注册shutdown函数。
function fatalErrorHandler() { //获取最后的致命错误 $error = error_get_last(); //这只是一个展示的错误处理器，没有错误意味着没有错误或崩溃发生。也确保只处理致命错误 if (null === $error || E_ERROR != $error[&#39;type&#39;]) { return ; } //把最后的错误记录到日志 //我们假设日志在app的目录 $logFile = fopen(&amp;quot;./app/logs/error.log&amp;quot;, &amp;quot;a+&amp;quot;); //获取有用的错误信息 $type = $error[&amp;quot;type&amp;quot;]; $file = $error[&amp;quot;file&amp;quot;]; $line = $error[&amp;quot;line&amp;quot;]; $message = $error[&amp;quot;message&amp;quot;]; fprintf( $logFile, &amp;quot;[%s] %s: %s in %s:%d\n&amp;quot;, date(&amp;quot;Y-m-d H:i:s&amp;quot;), $type, $message, $file, $line); fclose($logFile); } register_shutdown_function(&amp;quot;fatalErrorHandler&amp;quot;);  引用：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十三）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-93.html</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-93.html</guid>
      <description>编译错误和警告 1. Parse error: 语法错误，意外的T_PAAMAYIM_NEKUDOTAYIM 出现
&amp;ldquo;Paamayim Nekudotayim&amp;rdquo;在Hebrew中意味着&amp;rdquo;双引号&amp;rdquo;；因此，这个错误是指不正确的使用了双冒号运算符(::)。这个错误通常是视图静态调用一个不是静态的方法造成的。
可能的解决办法
$classname::$doMethod();  如果上面的代码产生了这个错误，你大多数去情况下简单的修改调用方法：
$classname-&amp;gt;doMethod();  下面的例子假设$classname是一个类的实例，并且doMethod()是这个类的非静态方法。
2. Notice: 未定义的引用 出现：
试着访问一个数组中不存在的键。
可能的解决方法
在访问键之前检查键是否存在：
 isset() array_key_exists()  3. Warning: 不能修改header信息 - header已经发送了 出现：
在你向客户端发送HTTP头信息之前你的脚本已经输出了，这将会导致已经将头信息发送给客户端。
可能的原因
 print, echo: print和echo语句的输出将终止发送HTTP头的机会。必须重新构造应用程序的执行流程，避免这样的情况。
 原生HTML区域：.php文件中未解析的HTML部分也是直接输出的。触发header()方法的脚本部分必须在HTML内容前面。
  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;?php //太晚了发送header信息   在&amp;lt;?php之前的空白，导致script.php line 1：然后经过引用第一行的输出，很可能是空白，文本或HTML在&amp;lt;?php之前了  &amp;lt;?php //&amp;lt;?php之前有单行或空白  引用Mario的回答。
参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十二）</title>
      <link>http://blog.huaifufeng.com/2019/07/post/php-section-92.html</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/07/post/php-section-92.html</guid>
      <description>常见错误 1. call fetch_assoc on boolean 如果你获得一个类似下面的错误：
Fatal error: Call to a member function fetch_assoc() on boolean in C:\xampp\htdocs\stack\index.php on line 7  其他类似的错误包括：
mysql_fetch_assoc() expects parameter 1 to be resource, boolean given...  这些错误意味着要么你的查询有错误(这是一个PHP/Mysql错误)或引用错误。下面的代码就可以产生上面的错误：
$mysqli = new mysqli(&amp;quot;localhost&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;&amp;quot;); $query = &amp;quot;SELCT * FROM db&amp;quot;; //注意这里的错误 $result = $mysqli-&amp;gt;query($query); $row = $result-&amp;gt;fetch_assoc();  为了&amp;rdquo;修正&amp;rdquo;这个错误，推荐设置mysql抛出异常：
//在脚本的开头添加下面的内容 mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);  这将会抛出一个带有更加详细的异常信息：
You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;SELCT * FROM db&#39; at line 1  另一个会产生相似错误的是你只是简单的将错误信息提供给mysql_fetch_assoc方法或相似的：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十一）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-91.html</link>
      <pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-91.html</guid>
      <description>编译PHP扩展 1. Linux编译 想要在典型的Linux环境编译PHP，有一些前置条件：
 基本的Unix能力(可以执行&amp;rdquo;make&amp;rdquo;和一个C的编译器) ANSI编译器 你想要编译的PHP扩展源码  通常有两种方式来编译PHP的扩展。你可以静态地将扩展编译为PHP的二进制文件，或者将其编译为由PHP二进制文件启动时加载的共享模块。共享模块是更加合适的，因为这允许你添加或移除扩展而不用重新编译PHP。这个例子主要是共享模块的。
如果你使用包管理器安装你的PHP(像apt-get install, yum install)。你需要安装PHP的-dev包，这里面包含着必须的PHP头文件和用来让构造环境正常工作的phpize脚本。这个包可能名字是php5-dev或php7-dev，但是需要使用包管理器来搜索你发行版中的适当名称。他们可能是不同的。
如果你是从源码编译PHP，那些头文件大多数情况下已经存在你的系统上面（通常在/usr/include，或/usr/local/include）。
编译步骤
在你已经检查后确定已经安装所有依赖之后，为了编译，你可以查看http://pecl.php.net/ 来寻找想要编译的扩展，然后下载tar包。
 解压tar包(例如tar xfvz yaml-2.0.0RC8.tgz) 进入到压缩包解压的目录，然后执行phpize 如果一切正常的话，你可以看到新创建的configure脚本，然后执行./configure 现在你需要运行make，这会编译扩展 最后，使用make install命令将编译好的扩展移动到扩展目录  make install这步会为你提供复制扩展的安装路径。这通常是/usr/lib，例如可能是/usr/lib/php5/20131226/yaml.so，但是这依赖于你的PHP配置(例如--with-prefix)和指定的API版本。路径中的API数字用来把扩展创建到不同的API版本的目录中。
加载PHP扩展
要做PHP中加载扩展，需要为相应的SAPI查找已经加载的php.ini文件，然后在其中添加extension=yaml.so。然后重新启动PHP。当然，将yaml.so修改为你实际安装的扩展名。
对于Zend扩展，你需要提供共享对象文件的完整路径。但是对于普通的PHP扩展，这个路径从extension_dir中获取，或者在初始化期间从$PATH获取。
参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九十）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-90.html</link>
      <pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-90.html</guid>
      <description>设计模式 这个主题经典设计模式的PHP实现的例子。
1. PHP中方法链 方法链是Martin Fowler&amp;rsquo;s book Domain Specific Languages介绍的技术。方法链总结为：
 Makes modifier methods return the host object, so that multiple modifiers can be invoked in a single expression。
 考虑下这段非连接/常规代码（从前面书中移植到PHP）。
$hardDrive = new HardDrive; $hardDrive-&amp;gt;setCapacity(150); $hardDrive-&amp;gt;external(); $hardDrive-&amp;gt;setSpeed(7200);  方法链允许你以更加紧凑的方式编写上面的代码：
$hardDrive = (new HardDrive) -&amp;gt;setCapacity(150) -&amp;gt;external() -&amp;gt;setSpeed(7200);  为了这个，你需要做的事情就是在所有想要链接的方法后面添加一个return $this。
class HardDrive { protected $isExternal = false; protected $capacity = 0; protected $speed = 0; public function external($isExternal = true) { $this-&amp;gt;isExternal = $isExternal; return $this; // returns the current class instance to allow method chaining } public function setCapacity($capacity) { $this-&amp;gt;capacity = $capacity; return $this; // returns the current class instance to allow method chaining } public function setSpeed($speed) { $this-&amp;gt;speed = $speed; return $this; // returns the current class instance to allow method chaining } }  什么时候使用</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十九）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-89.html</link>
      <pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-89.html</guid>
      <description>PHPDoc 1. 描述变量 @var关键字用来描述一个类型和用法：
 类属性 本地或全局变量 类或者全局常量  class Example { /** @var string 常量*/ const UNCHANGING = &#39;Untouchable&#39;; /** @var string $some_str 字符串 */ public $some_str; /** * @var array $stuff stuff集合 * @var array $nonsense 是nonsense集合 */ private $stuff, $nonsense; ... }  类型这里可以是PHP内建的类型，也可以是包含命名空间的用户定义的类
变量名应该包含，但是如果只有一个元素的话可以省略。
2. 添加方法的元信息 函数级注释有助于IDE识别返回值或潜在的危险代码。
/** * 两个元素加在一起 * * @param Int $a 第一个求和的元素 * @param Int $b 第二个求和的元素 * @return Int */ function sum($a, $b) { return (int) $a + $b; } /** * 不用运行这个方法，会抛出异常 * * @throws Exception 一直 */ function dangerousCode() { throw new Exception(&#39;注意，这里有风险&#39;); } /** * 老结构不使用了，这里的代码不使用 * * @deprecated */ function oldCode() { mysql_connect(/* .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十八）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-88.html</link>
      <pubDate>Thu, 27 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-88.html</guid>
      <description>PSR PSR（PHP标准建议）是有FIG（框架互操作组）组合在一起的一系列建议。
&amp;ldquo;该小组的想法是让项目代表讨论我们的项目之间的共性，并找到我们可以合作的方法。&amp;rdquo; - FIG FAQ
PSRs有下面的状态：Accepted, Review, Draft or Deprecated.
1. PSR-4：Autoloader PSR-4是一个已接受的建议。它描述了通过文件名自动加载类的标准。这个建议是作为早起(已经废弃)PSR-0的替代方案。
完全限定的类名需要符合下面的要求：
 \&amp;lt;NamespaceName&amp;gt;(\&amp;lt;SubNamespaceNames&amp;gt;)*\&amp;lt;ClassName&amp;gt;   它必须包含一个定义的第三方命名空间(例如Alphabet) 它可能包含一个或多个子命名空间(例如Google\AdWord) 它必须包含一个结尾的类名(例如KeywordPlanner)  最后的类名就是Alphabet\Google\AdWord\KeywordPlanner。完全先定的类名应该也是有意义的文件路径，因此Alphabet\Google\AdWord\KeywordPlanner应该保存在Alphabet\Google\AdWord\KeywordPlanner.php中。
从PHP5.3开始，自定义加载器方法可以用来定义基于你定义的路径和文件名格式来来加载文件的方法。
spl_autoload_register(function ($class) { include &#39;classes/&#39; . $class . &#39;.class.php&#39;;});  替换其中路径classes/和文件扩展.class.php为你自己的结构。
Composer包管理器支持PSR-4，这意味着，如果你遵循这个标准的话，使用Composer的第三方加载器自动加载你的项目的类。
//修改composer.json文件 { &amp;quot;autoload&amp;quot;: { &amp;quot;psr-4&amp;quot;: { &amp;quot;Alphabet\\&amp;quot;: &amp;quot;[path_to_source]&amp;quot; } } }  重新生成加载器文件：
$ composer dump-autoload  现在你的代码你可以像下面这样：
&amp;lt;?php require __DIR__ . &#39;/vendor/autoload.php&#39;; $KeywordPlanner = new Alphabet\Google\AdWord\KeywordPlanner();  2. PSR-1 基本代码标准 PSR-1是已经接受的建议，介绍代码应该怎么编写的基本建议标准。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十七）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-87.html</link>
      <pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-87.html</guid>
      <description>PHP内建服务器    列 描述     -S 告诉PHP我们想要一个服务器   &amp;lt;hostname&amp;gt;:&amp;lt;port&amp;gt; 使用的主机名和端口号   -t 公共目录   &amp;lt;filename&amp;gt; 路由脚本    学习怎么使用内建的服务器来开发和测试你的应用，而不需要安装像xamp，wamp等工具。
1. 运行内建服务器 php -S localhost:80   PHP 7.1.7 Development Server started at Fri Jul 14 15:11:05 2017 Listening on http://localhost:80 Document root is C:\projetos\repgeral Press Ctrl-C to quit.
 这是最简单的启动PHP服务器的方法，所有的请求都定位为到localhost的80端口。
-S说明我们想要启动一个服务器。
localhost:80说明我们使用的主机和端口。你可以使用另外的组合：
 mymachine:80 将会监听自己机器的地址和80端口 127.0.0.1:8080 将会监听127.0.0.1和端口8080  2. 使用指定的目录和路由脚本 php -S localhost:80 -t project/public router.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十六）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-86.html</link>
      <pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-86.html</guid>
      <description>APCu APCu是PHP的共享内存键值对存储。这个内存是被相同池子中的PHP-FPM进程共享的。存储的数据在不同的请求之间保持不变。
1. 迭代条目 APCUIterator允许迭代缓存中的条目：
foreach (new APCUIterator() as $entry) { print_r($entry); }  这个迭代器可以使用可选的正则表达式来初始化，这样可以选择匹配某些条目：
foreach (new APCUIterator($regex) as $entry) { print_r($entry); }  关于单个缓存条目可以使用下面的方法获取：
$key = &#39;...&#39;; $regex = &#39;(^&#39;. preg_quote($key) . &#39;$)&#39;; print_r((new APCUIterator($regex))-&amp;gt;current());  2. 简单的存储和获取 apcu_store可以用来存储，apcu_fetch可以用来获取数据：
$key = &amp;quot;Hello&amp;quot;; $value = &#39;World&#39;; apcu_store($key, $value); print_r($apcu_fetch(&#39;Hello&#39;)); //&#39;World&#39;  3. 存储的信息 apcu_cache_info可以用来获取存储的信息和它的条目：
print_r(apcu_cache_info());   注意不限制的调用apcu_cache_info()或返货当前存储的所有数据。值获取元信息的话，使用apcu_cache_info(true)。获取整个缓存的信息条目比APCUIterator更好。
 参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十五）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-85.html</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-85.html</guid>
      <description>Docker部署 Docker是非常出名的容器解决方案，被广泛用来在生产环境部署代码。这让管理和扩展web应用和微服务变得很简单。
1. 获取PHP的docker镜像 为了在docker上部署应用，首先我们需要充注册获取镜像。
docket pull php  这会从官方的php仓库中获取到最新版本的镜像。一般说来，PHP通常用来部署web服务器，所以需要一个包含HTTP服务器的镜像。php:7.0-apache镜像预装了Apache，这让部署变得更加简单。
2. 编写dockerfile dockerfile用来配置我们构建web应用代码的自定义镜像。在你的项目根目录创建一个新的Dockerfile文件，然后把下面的代码放到文件里面：
FROM php:7.0-apache COPY /etc/php/php.ini /usr/local/etc/php/ COPY . /var/www/html/ EXPOSE 80  第一行非常明显，用来描述从哪个镜像来创建一个新的镜像。这里可以修改为其他注册中的指定PHP版本。
第二行只是把php.ini文件上传到我们的镜像中。你也可以把这个文件放到其他的自定义的地址。
第三行将当前目录的代码复制到/var/www/html中，这就是我们的项目根目录。记住/var/www/html是在镜像里面的。
最后一行将docker容器的80端口打开。
忽略文件
在一些情况下，你不想在你的服务器上面保存某些文件，就像环境配置文件等等。假设我们有一个环境配置文件.env。为了忽略这个文件，我们在代码根目录的.dockerignore中把这个文件添加进来。
3. 创建镜像 创建镜像对于PHP并没有什么特别的，但是为了构建上面描述的镜像，我们简单的使用：
docker build -t &amp;lt;Image name&amp;gt; .  一旦镜像构建了，你可以验证：
docker images  这将会列出你系统安装的所有的镜像。
4. 启动一个应用容器 一旦我们有了一个精选，我们可以启动并运行这个镜像。为了从镜像创建一个容器，使用：
docker run -p 80:80 -d &amp;lt;Image name&amp;gt;  在上面的命令中，-p 80:80将会把你服务器的80端口指向到容器的80端口。标识-d说明容器作为后台工作运行。最后指明了哪个镜像用来创建容器。
检查容器
为了检查运行的容器，简单的运行：
docker ps  这将会列出所有在docker守护进程上运行的容器。
应用日志
日志对于测试应用是非常重要的。为了检查日志：
docker logs &amp;lt;Container id&amp;gt;  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十四）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-84.html</link>
      <pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-84.html</guid>
      <description>BC Math(二进制计算)    bcadd 添加两个任意精度的数字     left_operand 左操作数，是一个字符串   right_operand 右操作数，是一个字符串   scale 可选参数，设置结果中小数点后面的位数       bccomp 比较两个任意精度的数字     left_operand 左操作数，是一个字符串   right_operand 右操作数，是一个字符串   scale 可选的参数，用来设置用来比较的小数点后面的位数       bcdiv 两个任意精度数字的除法     left_operand 左操作数，是一个字符串   right_operand 右操作数，是一个字符串   scale 可选参数，用来设置结果中小数点后面的 位数       bcmod 对任意精度数字取模     left_operand 左操作数，是一个字符串   modulus 字符串类型的系数       bcmul 2个任意精度数字的乘法     left_operand 字符串类型的左操作数   right_operand 字符串类型的右操作数   scale 可选参数，设置结果中小数点后面的位数       bcpow 任意精度的乘方     left_operand 字符串类型的左操作数   right_operand 字符串类型的右操作数   scale 可选参数，结果中小数点后面的位数       bcpowmod 对任意精度数字乘方，然后取模     left_operand 整形字符串类型的操作数，scale必须是0   right_operand 指数，非负的整形字符串，scale必须是0   modulus 整形字符串，scale必须是0   scale 可选，设置结果中的小数点后位数       bcscale 为所有的bc方法设置默认的scale值     scale scale值       bcsqrt 任意精度数字的二次方根     operand 字符串类型   scale 可选参数，结果中小数点后面的位数       bcsub      left_operand 字符串类型参数   right_operand 字符串类型参数   scale 可选参数，设置结果中小数点后面的位数    对于任意精度的数学，PHP提供了支持用字符串表示的任意大小和精度的数字的二进制计算，最多为2147483647-1（或0x7FFFFFFF-1）。二进制计算是比PHP的浮点计算更加精确的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十三）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-83.html</link>
      <pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-83.html</guid>
      <description>WebSocket socket扩展实现了基于流行BSD socket的套接字通信功能的低级接口，提供了充当套接字服务器和客户端的可能性。
1. 建的TCP/IP服务器 PHP手册中最小的例子：https://www.php.net/manual/zh/sockets.examples.php
创建监听5000端口的websocket脚本，使用putty。在终端中执行 telnet 127.0.0.1 5000（localhost）。这个脚本使用你发生的消息(作为ping返回)进行答复：
&amp;lt;?php set_time_limit(0); //禁用超时 ob_implicit_flush(); //禁止刷新缓存 //设置 $address = &#39;127.0.0.1&#39;; $port = 5000; /* 函数 socket_create (int $domain, int $type, int $protocol) $domain 可以是AF_INET，AF_INET6对于IPV6 AF_UNIX对本地 $protocol 可以是SOL_TCP，SOL_UDP @return 成功时返回 套接字 */ if (($socket = socket_create(AF_INET, SOCKET_STREAM, SOL_TCP)) === false) { echo &amp;quot;无法创建socket&amp;quot; . socket_strerror(socket_last_error()) . &amp;quot;\n&amp;quot;; } /* socket_bind(resource $socket, string $address, [, int $port = 0]) 绑定socket到地址和端口 */ if (socket_bind($socket, $address, $port) === false) { echo &amp;quot;绑定失败 &amp;quot; .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十二）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-82.html</link>
      <pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-82.html</guid>
      <description>HTTP认证 在这个主题中我们做一个简单的HTTP认证脚本。
1. HTTP认证 注意：只把这个代码放到页面的header部分，否则代码将不会有效果。
&amp;lt;?php if (!isset($_SERVER[&#39;PHP_AUTH_USER&#39;])) { header(&#39;WWW-Authenticate: Basic realm=&amp;quot;My Realm&amp;quot;&#39;); header(&#39;HTTP/1.0 401 Unauthorized&#39;); echo &#39;Text to send if user hits Cancel button&#39;; exit; } echo &amp;quot;&amp;lt;p&amp;gt;Hello {$_SERVER[&#39;PHP_AUTH_USER&#39;]}.&amp;lt;/p&amp;gt;&amp;quot;; $user = $_SERVER[&#39;PHP_AUTH_USER&#39;]; //Lets save the information echo &amp;quot;&amp;lt;p&amp;gt;You entered {$_SERVER[&#39;PHP_AUTH_PW&#39;]} as your password.&amp;lt;/p&amp;gt;&amp;quot;; $pass = $_SERVER[&#39;PHP_AUTH_PW&#39;]; //Save the password(optionally add encryption)! ?&amp;gt; //You html page  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十一）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-81.html</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-81.html</guid>
      <description>IMAP 1. 连接到mailbox 在使用一个IMAP账号做任何事情之前你第一件需要做的就是连接到它。要做到这个你需要指定下面的参数：
 mail服务器的服务器名称或IP地址 你想要连接的端口号  IMAP是143或993(安全) POP是110或995(安全) SMTP是25或465(安全) NNTP是119或563(安全)  下面的连接标志     Flag 描述 选项 默认值     /service=service 使用什么服务 imap,pop3,nntp,smtp imap   /user=user 用来登录服务器的远端用户名     /authuser=user 远端认证用户；如果指定了这个，将会使用这个的密码     /anonymous 作为匿名用户访问     /debug 在应用程序的调试日志中记录协议遥测  disabled   /secure 不在网络中传输文本密码     /norsh 不要使用rsh或ssh建立预验证的IMAP会话     /ssl 使用SSL来加密会话     /validate-cert 来自TLS/SSL服务器的证书  enabled   novalidate-cert 如果服务器使用自签名证书，不验证来自TLS/SSL服务器的证书，谨慎使用  disabled   /tls 强制使用start-TLS加密会话，并拒绝不支持该会话的服务器连接     /notls 不使用start-TLS加密会话，即使服务器支持     /readonly 请求打开只读邮箱(仅限IMAP；在NNTP上面忽略，并且SMTP和POP3出错)      你的连接字符串像下面这样：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八十）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-80.html</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-80.html</guid>
      <description>SPL数据结构 1. SplFixedArray 和PHP数组的不同
PHP默认的数组类型实际是排序的hash数组，这允许我们创建包含键值对的数组，这个数组中值可以是任何类型，键可以是数字或字符串。然而，这不是传统数组的创建方式。
就像你看到的，普通的PHP数组可以看起来像是键值对的有序集合，这里每个key指向一个值。注意，这个数组我们的key是数组和字符串，以及不同类型的值，并且键和元素的顺序没有关系。
$arr = [ 9 =&amp;gt; &amp;quot;foo&amp;quot;, 1 =&amp;gt; &amp;quot;4.2&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; null, ]; foreach ($arr as $key =&amp;gt; $value) { echo &amp;quot;$key =&amp;gt; $value&amp;quot;; }  上面的例子会给我们希望的结果：
9 =&amp;gt; foo 1 =&amp;gt; 4.2 bar =&amp;gt;
常规的PHP数组也为我们动态调整大小。当我们像数组推送或取出值时，它们会自动的增长和收缩。
然而，在传统的数组中，数组的大小是固定的并且里面保存相同类型的值。并且，每个值都是通过索引访问的，而不是通过键。索引可以通过数组的偏移量来推导。
因为我们知道给定类型的大小，所以一个固定大小数组的偏移量可以通过type size * n来计算，其中n是这个值在数组中的位置。在这个例子中$arr[0]结果是1，数组的第一个元素$arr[1]的结果是2，等等。
但是SplFixedArray没有严格限制值的类型。它只限制键的类型是数字。这也是一个固定的大小。
这让SplFixedArray在某些场景下比PHP的普通数组性能更好。因为它们需要的内容更少，所以它们更加紧凑。
实例数组
SplFixedArray是作为一个对象实现的，但是因为它实现了ArrayAccess接口，所以你可以像访问普通PHP数组一样访问它的元素。它同样实现了Countable和Iterator接口，所以可以像PHP数组的行为一样。（使用count($arr）和foreach($arr as $k =&amp;gt; $v))这时SplFixedArray和PHP普通数组一样。
SplFixedArray要求一个参数，这个参数表示数组的大小：
$arr = new SplFixedArray(4); $arr[0] = &amp;quot;foo&amp;quot;; $arr[1] = &amp;quot;bar&amp;quot;; $arr[2] = &amp;quot;baz&amp;quot;; foreach($arr as $key =&amp;gt; $value) { echo &amp;quot;$key =&amp;gt; $value\n&amp;quot;; }  这将会获得下面的内容：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十九）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-79.html</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-79.html</guid>
      <description>自动加载初探 1. 作为框架解决方案的一部分自动加载 // autoload.php spl_autoload_register(function ($class) { require_once &amp;quot;$class.php&amp;quot;; }); // Animal.php class Animal { public function eats($food) { echo &amp;quot;Yum, $food!&amp;quot;; } } // Ruminant.php class Ruminant extends Animal { public function eats($food) { if (&#39;grass&#39; === $food) { parent::eats($food); } else { echo &amp;quot;Yuck, $food!&amp;quot;; } } } // Cow.php class Cow extends Ruminant { } // pasture.php require &#39;autoload.php&#39;; $animal = new Cow; $animal-&amp;gt;eats(&#39;grass&#39;);  因为我们的自动加载器，我们可以访问任何符合我们自动加载器规则的类。在这个例子中，规则很简单，所需的类必须在为该类命名并以“.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十八）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-78.html</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-78.html</guid>
      <description>缓存 1. 使用memcache Memcache是一个分布式对象缓存系统，使用key-value来存储小数据。在你开始在PHP代码中调用Memcache之前，你需要确定它已经安装了。可以在PHP中使用class_exists来测试。如果模块已经安装了，你可以建立一个到memcache服务器实例的连接：
if (class_exists(&amp;quot;Memcahce&amp;quot;)) { $cache = new Memcache(); $chace-&amp;gt;connect(&amp;quot;localhost&amp;quot;, 11211); } else { print &amp;quot;没有连接缓存服务器&amp;quot;; }  这会确保Memcache的PHP驱动已经安装了，并且连接到运行在localhost的memcache服务器实例。
 Memcache是守护模式运行的，并且叫做Memcached
 上面我们只连接了一个服务器实例，但是我们也可以连接到多个实例：
if (class_exists(&amp;quot;Memcache&amp;quot;)) { $cache = new Memcache(); $cache-&amp;gt;addServer(&#39;192.168.0.100&#39;, 11211); $cache-&amp;gt;addServer(&#39;192.168.0.101&#39;, 11211); }  注意这个不像connect，这个连接并不是活跃的连接，直到你试着存储或获取数据的时候。
在缓存中有三个重要的操作需要实现：
 存储数据：添加新的数据到Memcache服务器 获取数据：从Memcache服务器获取数据 删除数据：删除Memcache服务器上面已经存在的数据  存储数据
$cache或者Memcache类的对象有一个set方法，这需要一个key，值和时间来存储一个过期时间(ttl)的值。
$cache-&amp;gt;set($key, $value, 0, $ttl);  这里$ttl或存活时间(单位是秒)是在服务器上面存储键值对的时间。
获取数据
$cache或Memcache类对象有一个get方法，需要一个key来返回指定的值：
$value = $cache-&amp;gt;get($key);   如果这个key没有值得话，返回null。
 删除数据
有时候你必须删除一些缓存值。$cache或Memcache类对象有一个delete方法来删除指定key的值。
$cache-&amp;gt;delete($key);  缓存的小例子
我们假设有一个小blog。它有多个页面，每次加载的时候从数据库里面读取。为了减少SQL查询，我们可以使用Memcache来缓存页面。这是一个很小的实现：
if (class_exists(&#39;Memcache&#39;)) { $cache = new Memcache(); $cache-&amp;gt;connect(&#39;localhost&#39;,11211); if(($data = $cache-&amp;gt;get(&#39;posts&#39;)) !</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十七）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-77.html</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-77.html</guid>
      <description>机器学习 1. PHP-ML分类 机器学习中的分类是确定新观察数据属于哪个类别的问题。分类属于监督机器学习的范畴。
 任何实现分类的算法叫做分类器。
 PHP-ML支持的分类器是：
 SVC(支持向量分类) k-最近的邻居 朴素的贝叶斯  对所有的分类器来说，train和predict是相同的。唯一的区别是使用的底层算法。
SVC(支持向量分类)
在我们开始测试新的观察之前，我们需要训练分类器。考虑下面的代码：
// Import library use Phpml\Classification\SVC; use Phpml\SupportVectorMachine\Kernel; // Data for training classifier $samples = [[1, 3], [1, 4], [2, 4], [3, 1], [4, 1], [4, 2]]; // Training samples $labels = [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;]; // Initialize the classifier $classifier = new SVC(Kernel::LINEAR, $cost = 1000); // Train the classifier $classifier-&amp;gt;train($samples, $labels);  这个代码非常直接。上面说的$cost是一个衡量我们如何避免错误分类的每个培训示例的指标。设置更小的$cost值，你可以获得错误分类的示例。默认设置为1.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十六）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-76.html</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-76.html</guid>
      <description>SOAP服务器 1. 基础SOAP服务器 function test($x) { return $x; } $server = new SoapServer(null, array(&#39;uri&#39; =&amp;gt; &amp;quot;http://test-uri/&amp;quot;)); $server-&amp;gt;addFunction(&amp;quot;test&amp;quot;); $server-&amp;gt;handle();  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十五）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-75.html</link>
      <pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-75.html</guid>
      <description>Imagick 1. 第一步 安装
基于Debian的系统使用apt
sudo apt-get install php5-imagick  OSX/macOS上使用Homebrew
brew install imagemagick  想要查看brew安装的依赖，查看https://brewformulas.org/Imagemagick
使用二进制版本
Imagemagick网站的说明。
用例
&amp;lt;?php $imagen = new Imagick(&#39;imagen.jpg&#39;); $imagen-&amp;gt;thumbnailImage(100, 0); //if you put 0 in the parameter aspect ratio is maintained echo $imagen; ?&amp;gt;  2. 转换图片到base64字符串 下面的例子展示了怎么把图片转换为base64字符串(你可以在img表的src属性中使用的字符串)。这个例子使用Imagick扩展(其他的也是有效的，像GD扩展)。
&amp;lt;?php /** * 这加载了图片image.jpg进行操作。 * 这个图片的路径是包含代码的php文件的相对地址, 所以在这个例子中，图片需要和代码在一个目录中 */ $img = new Imagick(&#39;image.jpg&#39;); /** * 这缩放图片，提供目标的长宽。如果你想要改变图片的分辨率，使用$img-&amp;gt;resampleimage(320, 240) * * 注意第二个参数可以为0，保持原图片的长宽比 */ $img-&amp;gt;resizeImage(320, 240); /** * 这返回图片未编码的字符串内容 */ $imgBuff = $img-&amp;gt;getimageblob(); /** * 浙江清理image.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十四）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-74.html</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-74.html</guid>
      <description>GD处理图片 1. 图片输出 可以使用image*函数创建图片，这里*是指文件的格式。
它们具有相同的语法：
bool image___(resource $im [, mixed $to [ other parameters]] )  保存到一个文件
如果你想把一个图片保存为一个文件，可以在$to中传入一个图片的地址或者打开的流。如果传入了一个流，你不需要自己关闭，因为GD会自动的关闭它。
imagepng($image, &amp;quot;/path/to/target/file.png&amp;quot;); $stream = fopen(&amp;quot;phar://path/to/target.phar/file.png&amp;quot;, &amp;quot;wb&amp;quot;); imagepng($image2, $stream); // Don&#39;t fclose($stream)  当使用fopen的时候，这里使用b而不是t，因为文件是二进制输出的。
不要试着传入fopen(&amp;quot;php://temp&amp;quot;, $f)或fopen(&amp;quot;php://memory&amp;quot;, $f)。因为这个流会在执行完毕后关闭，你就不能继续使用这个流了，比如获取流的内容。
输出HTTP响应
如果你想要图片作为图片的响应(例如创建一个动态的证章)，不需要在第二个参数传入任何信息(或者传入null)。然后在HTTP响应中需要制定内容类型：
header(&amp;quot;Content-Type: $mimeType&amp;quot;);  $mimeType是你返回的MIME格式化类型。例子中包含image/png，image/gif，image/jpeg。
写入变量
有两种方式写入一个变量中：
使用OB(输出缓存)
ob_start(); imagepng($image, null, $quality); // pass null to supposedly write to stdout $binary = ob_get_clean();  使用流封装
你可能有很多理由不适用输出缓存。例如：你可能已经开启了OB。因此，另外的选项就可以使用了。
使用stream_wrapper_register方法，可以注册一个新的流封装。因此你可以把这个流传入一个图片输出函数，之后就可以获取这个流。
&amp;lt;?php class GlobalStream { private $var; public function stream_open(string $path) { $this-&amp;gt;var = &amp;amp;GLOBALs[parse_url($path)][&#39;host&#39;]; return true; } public function stream_write(string $data) { $this-&amp;gt;var .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十三）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-73.html</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-73.html</guid>
      <description>PHP中使用YAML 1. 安装YAML扩展 YAML不能使用PHP标准方式安装，需要使用PECL扩展进行安装。在Linux/Unix可以像下面这样安装：
pecl install yaml  注意，系统上必须安装libyaml-dev包，PECL扩展只是libYAML的简单封装。
在Windows上安装就更简单了，只需要下载编译好的dll文件或者从源码中进行编译就好了。
2. 使用YAML存储应用配置 YAML提供了一种存储结构化数据的方式。这个数据可以是简单的键值对数据，也可以是复杂的层次数据，其中值甚至是数组。
查看下面的YAML文件：
database: driver: mysql host: database.mydomain.com port: 3306 db_name: sample_db user: myuser password: Passw0rd debug: true country: us  我们把这个文件保存到config.yaml。然后使用下面的代码在PHP中读取文件的内容：
$config = yaml_parse_file(&#39;config.yaml&#39;); print_r($config);  print_r将会输出下面的内容：
Array ( [database] =&amp;gt; Array ( [driver] =&amp;gt; mysql [host] =&amp;gt; database.mydomain.com [port] =&amp;gt; 3306 [db_name] =&amp;gt; sample_db [user] =&amp;gt; myuser [password] =&amp;gt; Passw0rd ) [debug] =&amp;gt; 1 [country] =&amp;gt; us )  现在就可以使用数组的元素访问访问配置：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十二）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-72.html</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-72.html</guid>
      <description>PHP创建PDF文件 1. PDFlib初探 下面代码的实现依赖于PDFlib扩展。
&amp;lt;?php //初始化一个新对象 $pdf = pdf_new(); //创建一个新的空白pdf pdf_begin_document($pdf); pdf_set_info($pdf, &amp;quot;Author&amp;quot;, &amp;quot;王子&amp;quot;); //设置pdf信息 pdf_set_info($pdf, &#39;Title&#39;, &amp;quot;HelloWorld&amp;quot;); pdf_begin_page($pdf, (72 * 8.5), (72 * 11)); //指定页面的长宽 $font = pdf_findfont($pdf, &amp;quot;Times-Roman&amp;quot;, &amp;quot;host&amp;quot;, 0); //加载字体 pdf_set_font($pdf, $font, 48); //设置字体 pdf_set_text_pos($pdf, 50, 700); //设置文本位置 pdf_show($pdf, &amp;quot;Hello World!&amp;quot;); pdf_end_page($pdf); pdf_end_document($pdf); $document = pdf_get_buffer($pdf); //获取缓存内容 $length = strlen($document); $filename = &amp;quot;HelloWorld.pdf&amp;quot;; //Finds PDF length and assigns file name header(&amp;quot;Content-Type:application/pdf&amp;quot;); header(&amp;quot;Content-Length:&amp;quot; . $length); header(&amp;quot;Content-Disposition:inline; filename=&amp;quot; .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十一）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-71.html</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-71.html</guid>
      <description>如何获取客户端IP 1. 正确的使用HTTP_X_FORWARDED_FOR 鉴于最近的httpproxy漏洞，还有另一个变量被广泛使用。
HTTP_X_FORWARDED_FOR经常被用来获客户端IP，如果不做额外的检查，这会导致安全问题，特别是之后将这个IP用作身份认证或者不进行处理的SQL查询中。
大多数可用的代码示例中忽略了这样一个事实，HTTP_X_FORWARDED_FOR实际是客户端自己提供的信息，因此不是作为获取客户端IP有效来源。一些例子确实添加了对可能误用的警告，但任然缺少对这些代码本身的额外检查。
下面这个是PHP实现的例子，用来获取客户端的IP地址。如果你知道客户端可能使用代理，并且这个代理是可以信任的话。如果你不信任这个代理，你只能使用REMOTE_ADDR。
function get_client_ip() { //如果没有有效信息，什么都不做 if (!isset($_SERVER[&#39;REMOTE_ADDR&#39;])) { return NULL; } //如果信任代理，从代理获取IP $proxy_header = &#39;HTTP_X_FORWARDED_FOR&#39;; //所有信任的代理，用来处理&#39;proxy_header&#39; $trusted_proxies = [&amp;quot;2001:db8::1&amp;quot;, &amp;quot;192.168.50.1&amp;quot;]; if (in_array($SERVER[&#39;REMOTE_ADDR&#39;], $trusted_proxies)) { //从代理中获取客户端ip if (array_key_exists($proxy_header, $_SERVER)) { //header里面可能包含多个代理传过来的ip，只有最后一个是可以信任的 $client_ip = trim(end(expolod(&amp;quot;,&amp;quot;, $_SERVER[$proxy_header]))); if (filter_var($client_ip, FILTER_VALIDATE_IP)) { return $client_ip; } else { //验证失败的处理 } } } //其他情况下，REMOTE_ADDR是唯一信任的ip return $_SERVER[&#39;REMOTE_ADDR&#39;]; } print get_client_ip();  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七十）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-70.html</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-70.html</guid>
      <description>异步编程 1. 生成器的优点 PHP5.5提供了生成器和yield关键字，这允许我们想同步代码一样编写异步代码。
yield表达式负责将控制结构交还给调用代码，并在这个位置提供恢复点。可以通过yield表达式发送一个值。这个表达式的返回值要么是null，要么是Generator::send()的值。
function reverse_range($i) { // 仅仅在这个函数中存在yield关键字就使得它成为一个生成器。 do { //$i 在恢复点之间保留着 print yield $i; } while (--$i &amp;gt; 0); } $gen = reverse_range(5); print $gen-&amp;gt;current(); $gen-&amp;gt;send(&amp;quot;injected!&amp;quot;); // send 也会唤起这个生成器 foreach ($gen as $val) { //循环处理迭代器，在每个每个迭代中唤起	echo $val; } // Output: 5injected!4321  协程可以使用这种机制来等待生成器生成Awaitable的yield（通过将自身注册于用于解析的回调）在Awaitables的yield解析的时候执行生成器。
2. 使用Icicle时间循环 Icicle使用Awaitable和生成器来创建协程。
require __DIR__ . &#39;/vendor/autoload.php&#39;; use Icicle\Awaitable; use Icicle\Coroutine\Coroutine; use Icicle\Loop; $generator = function (float $time) { try { //设置$start的值为microtime()返回之后大约$time秒 $start = yield Awaitable\resolve(microtime(true))-&amp;gt;delay($time); echo &amp;quot;Sleep time: &amp;quot;, microtime(true) - $start, &amp;quot;\n&amp;quot;; // 在rejected awaitable进入协程之后跑出异常 return yield Awaitable\reject(new Exception(&#39;Rejected awaitable&#39;)); } catch (Throwable $e) { // 获取 awaitable 拒绝的原因 echo &amp;quot;Caught exception: &amp;quot;, $e-&amp;gt;getMessage(), &amp;quot;\n&amp;quot;; } return yield Awaitable\resolve(&#39;Coroutine completed&#39;); }; // 协程休眠1.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十九）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-69.html</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-69.html</guid>
      <description>编码约定 1. PHP标签 你应该使用&amp;lt;?php ?&amp;gt;或&amp;lt;?= ?&amp;gt;这两种标签。其他的方式（特别是 &amp;lt;? ?&amp;gt;）不应该使用，因为它们通常会被系统管理员禁用。
当文件不会产生输出（整个文件都是PHP代码），需要使用?&amp;gt;来避免无意义的输出，这将会导致客户端的解析出现问题。特别是一些客户端无法识别&amp;lt;!DOCTYPE标签或开启了quirks模式。
下面是一个简单的PHP例子：
&amp;lt;?php print &amp;quot;Hello World&amp;quot;;  定义类的例子：
&amp;lt;?php class Foo { ... }  PHP内嵌到HTML中的例子：
&amp;lt;ul id=&amp;quot;nav&amp;quot;&amp;gt; &amp;lt;?php foreach ($navItems as $navItem): ?&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&amp;lt;?= htmlspecialchars($navItem-&amp;gt;url) ?&amp;gt;&amp;quot;&amp;gt; &amp;lt;?= htmlspecialchars($navItem-&amp;gt;label) ?&amp;gt; &amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;?php endforeach; ?&amp;gt; &amp;lt;/ul&amp;gt;  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十八）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-68.html</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-68.html</guid>
      <description>header操作 1. 设置header 下面是一个设置header的基本操作，用来在点击按钮的时候跳转到新的页面：
if(isset($_REQUEST[&#39;action&#39;])) { switch($_REQUEST[&#39;action&#39;]){ //Setting the Header based on which button is clicked case &#39;getState&#39;: header(&amp;quot;Location: http://NewPageForState.com/getState.php?search=&amp;quot; . $_POST[&#39;search&#39;]); break; case &#39;getProject&#39;: header(&amp;quot;Location: http://NewPageForProject.com/getProject.php?search=&amp;quot; . $_POST[&#39;search&#39;]); break; } } else { GetSearchTerm(!NULL); } //Forms to enter a State or Project and click search function GetSearchTerm($success) { if (is_null($success)) { echo &amp;quot;&amp;lt;h4&amp;gt;You must enter a state or project number&amp;lt;/h4&amp;gt;&amp;quot;; } echo &amp;quot;&amp;lt;center&amp;gt;&amp;lt;strong&amp;gt;Enter the State to search for&amp;lt;/strong&amp;gt;&amp;lt;/center&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;; //Using the $_SERVER[&#39;PHP_SELF&#39;] keeps us on this page till the switch above determines where to go echo &amp;quot;&amp;lt;form action=&#39;&amp;quot; .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十七）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-67.html</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-67.html</guid>
      <description>本地化 1. gettext()获取本地字符串 GNUgettext是一个必须包含在PHP的php.ini文件中扩展。
extension=php_gettext.dll #Windows extension=gettext.so #Linux  gettext实现一个NLS（非语言支持）APi，这被用来国际化你的PHP应用。在PHP中你可以通过设置语言环境，设置翻译表，和在想要翻译的字符串上调用gettext()方法来获取字符串的翻译。
&amp;lt;?php // Set language to French putenv(&#39;LC_ALL= fr_FR&#39;); setlocale(LC_ALL, &#39;fr_FR&#39;); // Specify location of translation tables for &#39;myPHPApp&#39; domain bindtextdomain(&amp;quot;myPHPApp&amp;quot;, &amp;quot;./locale&amp;quot;); // Select &#39;myPHPApp&#39; domain textdomain(&amp;quot;myPHPApp&amp;quot;);  myPHPApp.po
#: /Hello_world.php:56 msgid &amp;quot;Hello&amp;quot; msgstr &amp;quot;Bonjour&amp;quot; #: /Hello_world.php:242 msgid &amp;quot;How are you?&amp;quot; msgstr &amp;quot;Comment allez-vous?&amp;quot;  gettext()加载一个给定的post-componed.po，一个.mo文件，它将您的要翻译的字符串映射为如上所述。
在这一小段设置代码之后，将在以下文件中查找翻译：
 ./locale/fr_FR/LC_MESSAGES/myPHPApp.mo  每当你调用gettext(&#39;some string&#39;)，如果翻译文件.mo中已经翻译了some string，那么翻译将会被返回。否则，没有翻译的some string将会被返回。
// Print the translated version of &#39;Welcome to My PHP Application&#39; echo gettext(&amp;quot;Welcome to My PHP Application&amp;quot;); // Or use the alias _() for gettext() echo _(&amp;quot;Have a nice day&amp;quot;);  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十六）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-66.html</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-66.html</guid>
      <description>命令行接口CLI 1. 处理程序选项 程序选项可以使用getopt()方法处理。执行和POSIX的getopt命令有相似的语法，并且提供GNU类型长选项支持。
#!/usr/bin/php // a single colon indicates the option takes a value // a double colon indicates the value may be omitted $shortopts = &amp;quot;hf:v::d&amp;quot;; // GNU-style long options are not required $longopts = [&amp;quot;help&amp;quot;, &amp;quot;version&amp;quot;]; $opts = getopt($shortopts, $longopts); // options without values are assigned a value of boolean false // you must check their existence, not their truthiness if (isset($opts[&amp;quot;h&amp;quot;]) || isset($opts[&amp;quot;help&amp;quot;])) { fprintf(STDERR, &amp;quot;Here is some help!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十五）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-65.html</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-65.html</guid>
      <description>SQLSRV 1. 获取错误信息 当一个查询出错的时候，获取驱动指出的造成错误原因的错误信息是非常重要的。语法是:
sqlsrv_errors([int $errorsOrWarnings]);  这将会返回一个数组：
   key 描述     SQLSTATE SQL服务器/OBDC驱动的状态   code SQL服务器的错误码   message 错误的描述信息    上面语句的常见用法是：
$brokenQuery = &amp;quot;SELECT BadColumnName FROM Table_1&amp;quot;; $stmt = sqlsrv_query($conn, $brokenQuery); if ($stmt === false) { if (($errors = sqlsrv_errors()) != null) { foreach ($errors as $error) { echo &amp;quot;SQLSTATE: &amp;quot;.$error[&#39;SQLSTATE&#39;].&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; echo &amp;quot;code: &amp;quot;.$error[&#39;code&#39;].&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; echo &amp;quot;message: &amp;quot;.$error[&#39;message&#39;].&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; } } }  2.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十四）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-64.html</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-64.html</guid>
      <description>使用PHP发送邮件    参数 想去     string $to 收件人地址   string $subject 邮件主题行   string $message 邮件主题   string $additional_headers 可选：邮件头信息   string $adaitional_parameters 可选：在命令行中传递给配置的邮件发送应用程序的参数    1. 发送邮件 - 基础，更详细和完整的例子 一个典型的邮件包含下面3个主要部分：
 一个收件人（是一个邮件地址） 一个主题 一个信息主题  在PHP中发送邮件很简单，只需要调用mail()方法。mail()接受5个参数，但是只有前3个是发送一个邮件所需要的（尽管像下面显示的这四个参数是常用的）。前开始的3个参数：
 收件人的地址(字符串) 邮件的主题(字符串) 邮件的主题(字符串)（邮件的内容）  最简单的例子像下面一样：
mail(&#39;recipient@example.com&#39;, &#39;Email Subject&#39;, &#39;This is the email message body&#39;);  上面的简单例子在有限的环境下（如内部硬编码的报警邮件）是正常工作的。但是通常将放入mail()的内容放到一个变量中，这样让代码更加清晰，便于管理（例如，从表单提交中动态创建邮件内容）。
例如，mail()接受第四个参数，允许在邮件中发送更多的邮件头。你可以设置下面的头信息：
 From名称和邮件地址，用户将会看到的 用户回复将会发送到的Rely-To邮件地址 额外的非标准头信息：X-Mailer向收件人说明邮件是通过PHP发送的  $to = &#39;recipient@example.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十三）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-63.html</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-63.html</guid>
      <description>PHP中使用Redis 1. 连接redis实例 假设一个redis服务运行在localhost的默认端口，下面的命令可以连接到这个Redis服务器：
$redis = new Redis(); $redis-&amp;gt;connect(&#39;127.0.0.1&#39;, 6379);  2. Ubuntu上安装Redis 在Ubuntu上面安装PHP，首先安装Redis服务器：
sudo apt install redis-server  然后安装PHP的Redis模块：
sudo apt install php-redis  然后重启Apache服务器
sudo service apache2 restart  3. 在PHP中执行Redis命令 PHP的Redis模块有和Redis CLI客户端一样的命令，所以可以直接使用。
语法像下面一样：
//创建两个新key $redis-&amp;gt;set(&#39;mykey-1&#39;, 123); $redis-&amp;gt;set(&#39;mykey-2&#39;, &#39;abcd&#39;); //获取一个key (prints &#39;123&#39;) var_dump($redis-&amp;gt;get(&#39;mykey-1&#39;)); // 获取所有以&#39;my-key-&#39;开头的key // (prints &#39;123&#39;, &#39;abcd&#39;) var_dump($redis-&amp;gt;keys(&#39;mykey-*&#39;));  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十二）</title>
      <link>http://blog.huaifufeng.com/2019/06/post/php-section-62.html</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/06/post/php-section-62.html</guid>
      <description>mongo-php 1. MongoDB和PHP之间的信息 要求
 MongoDB服务器运行的端口通常是27017。（在命令终端中输入mongod来运行mongodb 服务器） PHP已经安装了，不管是cgi还是fpm，同时安装了MongoDB的扩展（PHP默认没有安装MongoDB扩展） Composer仓库(mongodb/mongodb)(在项目的根目录运行`php composer.phar require &amp;ldquo;mongodb/mongodb=^1.0.0&amp;rdquo;来安装MongoDB库)。  如果上面的要求都正常了，你就可以开始了：
 检查PHP安装
 如果不确定PHP是否安装，可以在命令终端中运行&amp;rdquo;php -v&amp;rdquo;，将会返回类似下面的内容：
PHP 7.1.23 (cli) (built: Nov 7 2018 18:20:35) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies   检查MongoDB安装
 检查MongoDB安装通过运行mongo —version，这将会返回MongoDB shell version: 3.2.6
 检查Composer安装
 检查Composer安装通过运行php composer.phar —version将会返回Composer version 1.2-dev (3d09c17b489cd29a0c0b3b11e731987e7097797d) 2016-08-30 16:12:39
使用php连接MongoDB
&amp;lt;?php //Composer的自动加载类 require &amp;quot;vendor/autoload.php&amp;quot;; //建立连接 try { $mongo = new MongoDB\Client(&amp;quot;mongodb://username:password@localhost:27017&amp;quot;); print_r($mongo-&amp;gt;lisDatabases()); } catch (\Exception $e) { echo $e-&amp;gt;getMessage(); } //使用默认配置 try { $mongo = new MongoDB\Client(&amp;quot;mongodb://localhost:27017&amp;quot;); print_r($mongo-&amp;gt;listDatabases()); } catch (\Exception $e) { echo $e-&amp;gt;getMessage(); }  上面的代码使用包含在/vendor/autoload.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-61.html</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-61.html</guid>
      <description>使用MongoDB 1. 连接MongoDB 创建一个MongoDB连接，之后你可以在这个连接查询数据：
$manager = new \MongoDB\Driver\Manager(&#39;mongodb://localhost:27017&#39;);  在下面的例子中，你可以知道怎么在连接对象上面怎么进行查询。
这个扩展将会自动的关闭连接，所有不是必须手动关闭的。
2. 获取多个文档 - find() 搜索多个名称为Mike的用户的例子：
$filter = [&#39;name&#39; =&amp;gt; &#39;Mike&#39;]; $query = new \MongoDB\Driver\Query($filter); $cursor = $manger-&amp;gt;executeQuery(&#39;database_name.collection_name&#39;, $query); foreach ($cursor as $doc) { var_dump($doc); }  3. 获取一个文档 - findOne() 获取指定id对应的一个用户的信息的例子，你可以使用：
$options = [&#39;limit&#39; =&amp;gt; 1]; $filter = [&#39;_id&#39; =&amp;gt; new \MongoDB\BSON\ObjectID(&#39;578ff7c3648c940e008b457a&#39;)]; $query = new \MongoDB\Driver\Query($filter, $options); $cursor = $manager-&amp;gt;executeQuery(&#39;database_name.collection_name&#39;, $query); $cursorArray = $cursor-&amp;gt;toArray(); if(isset($cursorArray[0])) { var_dump($cursorArray[0]); }  4.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六十）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-60.html</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-60.html</guid>
      <description>SQLite3 1. SQLite3快速开始指导 这是一个使用SQLite3相关API的一个完整例子。目的是帮助你可以很快的开始并运行真实的例子。你也可以获取一个指导的可执行PHP文件。
创建/打开数据库
首先让我们创建一个新的数据库。只有在文件不存在的情况下创建，然后打开准备读取/写入。文件的扩展名由你自己觉得，但是.sqlite是非常常见的，并且不需要解释说明的。
$db = new SQLite3(&#39;analytics.sqlite&#39;, SQLITE3_OPEN_CREATE | SQLITE3_OPEN_READWRITE);  创建表
$db-&amp;gt;query(&#39;CREATE TABLE IF NOT EXISTS &amp;quot;visits&amp;quot; ( &amp;quot;id&amp;quot; INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, &amp;quot;user_id&amp;quot; INTEGER, &amp;quot;url&amp;quot; VARCHAR, &amp;quot;time&amp;quot; DATETIME )&#39;);  插入示例
建议将相关的查询放入到一个事务中（包含在关键字BEGIN和COMMIT中），即使你不关心原子性。如果你没有这么做的话，SQLite会把每个查询都放到一个事务中，这将会极大降低每个事情的执行。如果你是刚开始使用SQLite，你会很奇怪为什么INSERT语句这么慢。
$db-&amp;gt;exec(&#39;BEGIN&#39;); $db-&amp;gt;query(&#39;INSERT INTO &amp;quot;visits&amp;quot; (&amp;quot;user_id&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;time&amp;quot;) VALUES (42, &amp;quot;/test&amp;quot;, &amp;quot;2017-01-14 10:11:23&amp;quot;)&#39;); $db-&amp;gt;query(&#39;INSERT INTO &amp;quot;visits&amp;quot; (&amp;quot;user_id&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;time&amp;quot;) VALUES (42, &amp;quot;/test2&amp;quot;, &amp;quot;2017-01-14 10:11:44&amp;quot;)&#39;); $db-&amp;gt;exec(&#39;COMMIT&#39;);  使用preapre语句插入潜在风险的数据。你可以使用命名参数完成这个功能：
$statement = $db-&amp;gt;prepare(&#39;INSERT INTO &amp;quot;visits&amp;quot; (&amp;quot;user_id&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;time&amp;quot;) VALUES (:uid, :url, :time)&#39;); $statement-&amp;gt;bindValue(&#39;:uid&#39;, 1337); $statement-&amp;gt;bindValue(&#39;:url&#39;, &#39;/test&#39;); $statement-&amp;gt;bindValue(&#39;:time&#39;, date(&#39;Y-m-d H:i:s&#39;)); $statement-&amp;gt;execute(); //you can reuse the statement with different values  获取数据</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十九）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-59.html</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-59.html</guid>
      <description>PHP MySQLi mysqli接口是mysql的一种改进方案（含义是&amp;rdquo;MySQL Improvement 扩展&amp;rdquo;），而mysql接口在PHP5.5标记为不推荐使用，在PHP7.0中移除。mysqli扩展（也被称为MySQL优化扩展）为MySQL4.1.3之后的新特性开发的。mysqli扩展在PHP5之后开始支持。
1. 关闭连接 当我们在数据库上面的查询结束之后，强烈建议关闭连接来释放资源。
面向对象方式
$conn-&amp;gt;close();  面向过程方式：
mysqli_close($conn);  注意：服务器的连接在脚本执行结束之后就会立即关闭，除非在结束之前使用close方法进行关闭。
用例：如果我们的脚本在获取全部结果之后还有很多的处理要进行，那我们肯定应该关闭连接。如果不这么做，当Web服务器大量使用的时候，MySQL服务器可能达到连接限制。
2. Mysqli 连接 面向对象：
连接服务器：
$conn = new mysqli(&amp;quot;localhost&amp;quot;, &amp;quot;my_user&amp;quot;, &amp;quot;my_password&amp;quot;);  设置默认的数据库：$conn-&amp;gt;select_db(&amp;quot;my_db&amp;quot;);
连接一个数据库：
$conn = new mysqli(&#39;localhost&#39;, &#39;my_user&#39;, &#39;my_password&#39;, &#39;my_db&#39;);  面向过程：
连接服务器
$conn = mysqli_connect(&#39;localhost&#39;, &#39;mysql_user&#39;, &#39;my_password&#39;);  设置默认的数据库：mysqli_select_db($conn, &#39;my_db&#39;);
连接数据库：
$conn = mysqli_connect(&#39;localhost&#39;, &#39;my_user&#39;, &#39;my_password&#39;, &#39;my_db&#39;);  验证数据库连接
面向对象方式
if ($conn-&amp;gt;connect_errno &amp;gt; 0) { trigger_error($db-&amp;gt;connect_error); } //else 正确的逻辑  面向过程方式</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十八）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-58.html</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-58.html</guid>
      <description>PDO PDO(PHP数据对象)扩展允许开发人员连接到不同类型的数据库，并以统一的、面向对象的方式对他们进行查询。
1. 使用参数化查询避免SQL注入 SQL注入是一种攻击方式：允许任意用户修改SQL查询，在其中添加不希望的命令。例如，下面的代码是很脆弱的：
$sql = &amp;quot;SELECT name, email, user_level FROM users WHERE userID=&amp;quot; . $_GET[&#39;user&#39;]; $conn-&amp;gt;query($sql);  这允许脚本的任何用户随意的修改我们的数据库。例如，下面的查询字符串：
page.php?user=0;%20TRUNCATE%20TABLE%20users;  这就会把我们的查询修改为：
SELECT name, email, user_level FROM users WHERE userID = 0; TRUNCATE TABLE users;  虽然这是一个极端的例子（大多数SQL注入的攻击不是为了删除数据，也不是大多数的PHP查询支持多查询），这是一个说明通过不小心组装查询来实现SQL注入攻击的例子。不幸的是，这样的攻击非常常见，而且由于编码人员未能采取适当的预防措施来包含他们的数据，这种攻击非常有效。
要避免SQL注入的发送，prepare语句是推荐的解决办法。不是将用户的数据直接拼接到查询语句中，在查询中使用占位符。然后单独发送数据，这意味着SQL引擎不会混淆命令和用户数据。
 虽然这里介绍的事PDO，但是要注意PHP的MySQLi扩展也是支持prepare语句的。
 PDO支持两种类型的占位符（占位符不能用于列名或表名，只适用于值）
 命名的占位符。一个冒号(:)，后面跟上一个唯一的名称(例如：:user)  $sql = &amp;quot;SELECT name,email,user_level FROM users WHERE userID=:user&amp;quot;; $prep = $conn-&amp;gt;prepare($sql); $prep-&amp;gt;execute([&#39;:user&#39; =&amp;gt; $_GET[&#39;user&#39;]]); $result = $prep-&amp;gt;fetchAll();   传统的SQL位置占位符，就是?:  $sql = &#39;SELECT name, user_level FROM users WHERE userID = ?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十七）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-57.html</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-57.html</guid>
      <description>Sockets 1. TCP客户端scoket 创建一个使用TCP的socket：
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);  一定要确保socket创建成功了。onSocketFailure函数是这个主题中用来处理socket错误的例子。
if (!is_resource($sokcet)) { onSocketFailure(&amp;quot;Failed to create socket&amp;quot;); }  连接指定地址的socket
连接失败的话，第二行可以处理失败情况：
socket_connect($socket, &#39;chat.stackoverflow.com&#39;, 6667) or onSocketFailure(&amp;quot;Failed to connect to chat.stackoverflow.com:6667&amp;quot;, $socket);  向服务端发送数据
socket_write函数通过一个socket发送字节数据。在PHP中，一个字节数组是由字符串表示的，通常不区分编码。
socket_write($socket, &amp;quot;NICK Alice\r\nUSER alice 0 * :Alice\r\n&amp;quot;);  从服务器接收数据
下面的代码片段使用socket_read从服务器接收一些数据。
当给函数传入PHP_NORMAL_READ这第三个参数的时候，当遇到\r或\n的时候会中断读取，直接返回读取的值，这个值包括这两个字符。
当第三个参数传入PHP_BINARY_READ时，将会从数据流中读取到需要的字节数量。
当在方法之前调用了socket_set_nonblock方法，那么将会使用PHP_BINARY_READ，socket_read将会立即返回false。否则，方法将会阻塞直到获取到足够的数据（达到第二个参数设置的长度，或者遇到一个行结束符）或者socket被关闭了。
下面的例子是从一个假设的IRC服务器读取数据：
while(true) { //读取数据 $line = socket_read($socket, 1025, PHP_NORMAL_READ); if (substr($line, -1) === &#39;\r&#39;) { //判断是不是换行，是就在读取\n socket_read($socket, 1, PHP_BINARY_READ); } $message = parseLine($line); if ($message-&amp;gt;type === &#39;QUIT&#39;) { break; } }  关闭socket</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-56.html</link>
      <pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-56.html</guid>
      <description>类型转换和非严格比较问题 1. 什么是类型转换？ PHP是一种弱类型语音。这意味着，默认情况下表达式中的操作数不需要具有相同(或兼容)的类型。例如，你可以在字符串后面追加一个数字，并且希望它正常工作。
var_dump(&amp;quot;This is example number &amp;quot; . 1);  这个输出将会是：
 string(24) &amp;ldquo;This is example number 1&amp;rdquo;
 PHP通过将不兼容的变量类型自动转换为允许执行请求的操作的类型来实现这点。在上面的例子中，将会把整数1转换为字符串，这意味着可以和前面的字符串字面量拼接起来。这被叫做类型转换。这是PHP一个非常强大的特性，但如果你不知道的话，可能会导致很多麻烦，甚至导致安全问题。
假设下面的代码：
if (1 == $variable) { //处理一些问题 }  这里目的似乎是让程序员检查变量的值是不是1。但是如果变量$variable的值是&amp;rdquo;1 and a half&amp;rdquo;，会发生什么？答案可能让你吃惊：
$variable = &amp;quot;1 and a half&amp;quot;; var_dump (1 == $variable);  这个结果是：
 bool(true)
 为什么会是这个结果？这是因为PHP意思到&amp;rdquo;1 and a half&amp;rdquo;是一个字符串，但是它需要和一个整数1进行比较。为了避免失败，PHP进行了类型转换，试着将这个字符串转换为整数。PHP通过将字符串开头的可以转换为整数的部分转换为整数。一遇到一个不能转换为整数的字符串就立刻停止。因此&amp;rdquo;1 and a half&amp;rdquo;转换为整数1。
当然，这是认为设计的一个例子，但这足以说明一些问题。接下来的例子将会涵盖这些情况，我在实际软件开发中因为类型转换造成的问题。
2. 从文件读取 当我们读取一个文件的内容时，我们想要知道什么时候我们到文件的末尾了。fgets()方法在到达文件末尾的时候，会返回一个false，所以我们可以在循环中用这个作为判断条件。然而，如果数据返回的是一个可转换为false的内容，这个循环就会提前中断执行。
$handle = fopen(&amp;quot;/path/to/my/file&amp;quot;, &#39;r&#39;); if ($handle === false) { throw new Exception(&amp;quot;Failed to open file for reading&amp;quot;); } while($data = fgets($handle)) { echo(&amp;quot;Current file line is $data\n&amp;quot;); } fclose($handle);  如果文件的内容包含一个空行，while循环在遇到这个空行的时候会中断执行，因为空字符串会被识别为 false。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-55.html</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-55.html</guid>
      <description>读取请求的数据 1. 读取原始POST数据 使用POST请求发送的数据通常是MIME类型为application/x-www-form-urlencoded的键/值的数据格式。然而很多应用像web服务要求原始的数据格式，像XML或JSON格式。这个数据可以使用两个方法中的一个进行获取。
php://input提供访问原始请求数据体的数据流。
$rawdata = file_get_contents(&amp;quot;php://input&amp;quot;); //假如是json数据 $decoded = json_decode($rawdata);  在PHP5.6之前，$HTTP_RAW_POST_DATA是一个包含元素POST数据的全局变量。只有在php.ini中的always_populate_raw_post_data选项开启的时候有效。
$rawdata = $HTTP_RAW_POST_DATA; //假设是xml数据 $decoded = simplexml_load_string($rawdata);  从PHP5.6开始不推荐使用了，在PHP7.0的时候移除。
当数据的类型是multipart/form-data的时候，上面的方法都没有效果，因为我们这些数据是用来上传文件的。
2. 读取POST数据 一个POST请求中的数据是存储在超全局变量$_POST中的关联数组中。
注意访问数组中不存在的元素将会产生一个notice错误，所以在访问数组元素之前需要使用isset()或empty()函数或null船运算符进行元素存在性的检查。
例如：
$from = isset($_POST[&#39;name&#39;]) ? $_POST[&#39;name&#39;] : &#39;NO NAME&#39;; $message = isset($_POST[&#39;message&#39;]) ? $_POST[&#39;message&#39;] : &#39;NO MESSAGE&#39;; echo &amp;quot;Message from $from: $message&amp;quot;; //在PHP7.0之后 $from = $_POST[&#39;name&#39;] ?? &#39;NO NAME&#39;; $message = $_POST[&#39;message&#39;] ?? &#39;NO MESSAGE&#39;; echo &amp;quot;Message from $from: $message&amp;quot;;  3.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-54.html</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-54.html</guid>
      <description>Closure 1. 闭包的基本用法 一个closure等价于PHP中的匿名函数，例如一个没有名称的方法。即使这在技术上不正确，闭包的行为仍然与函数的行为相同，只有一些额外的特性。
一个闭包就是一个Closure类的对象，通过创建一个没有名称的方法实现。例如：
&amp;lt;?php $myClosure = function() { echo &#39;Hello world!&#39;; }; $myClosure(); // Shows &amp;quot;Hello world!&amp;quot;  注意$myClosure就是Closure的一个实例，让你知道你做了什么。(https://www.php.net/manual/zh/class.closure.php)
Closure的经典用法就是在你必须使用一个callable的方法，例如usort。
下面是一个示例，其中数组按每个人的兄弟姐妹数排序：
&amp;lt;?php $data = [ [ &#39;name&#39; =&amp;gt; &#39;John&#39;, &#39;nbrOfSiblings&#39; =&amp;gt; 2, ], [ &#39;name&#39; =&amp;gt; &#39;Stan&#39;, &#39;nbrOfSiblings&#39; =&amp;gt; 1, ], [ &#39;name&#39; =&amp;gt; &#39;Tom&#39;, &#39;nbrOfSiblings&#39; =&amp;gt; 3, ] ]; usort($data, function($e1, $e2) { if ($e1[&#39;nbrOfSiblings&#39;] == $e2[&#39;nbrOfSiblings&#39;]) { return 0; } return $e1[&#39;nbrOfSiblings&#39;] &amp;lt; $e2[&#39;nbrOfSiblings&#39;] ? -1 : 1; }); var_dump($data); // Will show Stan first, then John and finally Tom  2.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-53.html</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-53.html</guid>
      <description>序列化    参数 详情     value 要序列化的值，serialize()接受所有的类型，除了资源类型。你甚至可以序列化包含自身引用的数组。包含循环引用的数组和对象也是可以处理的。任何其他的引用都会丢失。当序列化的时候，PHP会在序列化之前首先调用__sleep()方法。这允许对象在序列化的最后一分钟进行数据的清理工作。同样，在调用unserialize()方法的时候，会首先调用__wakeup()方法。对象的私有属性前添加类型；受保护的属性前面会有&amp;rdquo;*&amp;ldquo;。这些预先准备好的值两边都有空字节。    1. 序列化不同的类型 生成一个值的可存储格式。
这在存储或传输PHP值而不丢失值的类型和结构的时候很有用。
想要把序列化的结果返回PHP的值，可以使用unserialize()方法。
序列化string
$string = &amp;quot;Hello world&amp;quot;; echo serialize($string); // 输出: // s:11:&amp;quot;Hello world&amp;quot;;  序列化double
$double = 1.5; echo serialize($double); // 输出: // d:1.5;  序列化float
float和double的序列化效果相同。
序列化integer
$integer = 65; echo serialize($integer); // 输出: // i:65;  序列化boolean
$boolean = true; echo serialize($boolean); // Output: // b:1; $boolean = false; echo serialize($boolean); // Output: // b:0;  序列化NULL</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-52.html</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-52.html</guid>
      <description>对象序列化 1. serialize / unserialize serialize()返回一个包含PHP中存储的任何值的字节流格式的字符串。unserialize()将会把这个变量转换为初始的值。
序列化对象
serialize($object);  反序列化对象
unserialize($object)  例子
$array = array(); $array[&amp;quot;a&amp;quot;] = &amp;quot;Foo&amp;quot;; $array[&amp;quot;b&amp;quot;] = &amp;quot;Bar&amp;quot;; $array[&amp;quot;c&amp;quot;] = &amp;quot;Baz&amp;quot;; $array[&amp;quot;d&amp;quot;] = &amp;quot;Wom&amp;quot;; $serializedArray = serialize($array); echo $serializedArray; //output: a:4:{s:1:&amp;quot;a&amp;quot;;s:3:&amp;quot;Foo&amp;quot;;s:1:&amp;quot;b&amp;quot;;s:3:&amp;quot;Bar&amp;quot;;s:1:&amp;quot;c&amp;quot;;s:3:&amp;quot;Baz&amp;quot;;s:1:&amp;quot;d&amp;quot;;s:3:&amp;quot;Wom&amp;quot;;}  2. Serializable接口 简介
 实现这个接口的类不在支持__sleep()和wakeup()魔术方法。当实例序列化的时候，serialize方法将会调用。除非在方法内部编程，否则这将不会调用__destruct()和其他有副作用的方法。当类的数据要反序列化的时候unserialize()方法将会作为构造函数调用，而不是__construct()。如果你想要执行标准的构造方法，就在这个方法里面调用。
 基本用法
class obj implents Serializable { private $data; public function __construct() { $this-&amp;gt;data = &amp;quot;My private data&amp;quot;; } public function serialize() { return serialize($this-&amp;gt;data); } public function unserialize($data) { $this-&amp;gt;data = unserialize($data); } public function getData() { return $this-&amp;gt;data; } } $obj = new Obj(); $user = serialize($obj); var_dump($user); //string(38) &amp;quot;C:3:&amp;quot;obj&amp;quot;:23:{s:15:&amp;quot;My private data&amp;quot;;}&amp;quot; $newObj = unserialize($user); var_dump($newobj-&amp;gt;getData()); // string(15) &amp;quot;My private data&amp;quot;  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-51.html</link>
      <pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-51.html</guid>
      <description>怎么分解URL 在编写PHP代码的时候，你可能需要将URL地址分解为多个部分。根据你的需要显然有不止一种方式实现这个功能。这个主题就是介绍这些方法，从中你可以选择自己最合适的方法。
1. parse_url()  parse_url()：这个函数解析URL并且放回URL任何部分的一个关联数组。
 $url = parse_url(&#39;http://example.com/project/controller/action/param1/param2&#39;); Array ( [scheme] =&amp;gt; http [host] =&amp;gt; example.com [path] =&amp;gt; /project/controller/action/param1/param2 )  如果你需要获取将path进行分隔，你可以使用explode方法：
$url = parse_url(&#39;http://example.com/project/controller/action/param1/param2&#39;); $url[&#39;sections&#39;] = explode(&#39;/&#39;, $url[&#39;path&#39;]); Array ( [scheme] =&amp;gt; http [host] =&amp;gt; example.com [path] =&amp;gt; /project/controller/action/param1/param2 [sections] =&amp;gt; Array ( [0] =&amp;gt; [1] =&amp;gt; project [2] =&amp;gt; controller [3] =&amp;gt; action [4] =&amp;gt; param1 [5] =&amp;gt; param2 ) )  如果你想要获取section最后的部分，你可以使用下面的方法：
$last = end($url[&#39;sections&#39;]);  如果URL中有GET的变量，你可以获取这些值：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五十）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-50.html</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-50.html</guid>
      <description>URL 1. 解析URL 想要把一个URL解析到各自单独的部分，使用parse_url()函数：
$url = &amp;quot;http://blog.huaifufeng.com/page?foo=1&amp;amp;bar=baz#anchor&amp;quot;; $parts = parse_url($url);  在上面执行之后，$parts里面的内容就像下面这样：
Array ( [scheme] =&amp;gt; http [host] =&amp;gt; www.example.com [path] =&amp;gt; /page [query] =&amp;gt; foo=1&amp;amp;bar=baz [fragment] =&amp;gt; anchor )  你也可以选择一个部分而不是整个部分，可以使用下面的方法：
$url = &#39;http://www.example.com/page?foo=1&amp;amp;bar=baz#anchor&#39;; $queryString = parse_url($url, PHP_URL_QUERY); //输出：foo=1&amp;amp;bar=baz  支持下面的常量: PHP_URL_SCHEME, PHP_URL_HOST, PHP_URL_PORT, PHP_URL_USER, PHP_URL_PASS, PHP_URL_PATH, PHP_URL_QUERY and PHP_URL_FRAGMENT.
像要把query字符串解析进入一个键值对，可以使用parse_str()：
Array ( [foo] =&amp;gt; 1 [bar] =&amp;gt; baz )  2. 将数组生成一个URL加密的参数字符串 http_build_query()可以将数组或对象生成一个参数字符串。这些参数可以被追加到网址后面生成一个GET请求，或者用在一个POST请求，例如cURL：
$parameters = [ &#39;parameter1&#39; =&amp;gt; &#39;foo&#39;, &#39;parameter2&#39; =&amp;gt; &#39;bar&#39;, ]; $queryString = http_build_query($parameters);  $queryString将会有下面的内容：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十九）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-49.html</link>
      <pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-49.html</guid>
      <description>Unicode支持 1. 使用PHP转换Unicode字符为&amp;rsquo;\uxxxx&amp;rsquo; 你可以使用下面的方法进行字符类型转换：
if (!function_exists(&#39;codepoint_encode&#39;)) { function codepoint_encode($str) { return substr(json_encode($str), 1, -1); } } if (!function_exists(&#39;codepoint_decode&#39;)) { function codepoint_decode($str) { return json_decode(sprintf(&#39;&amp;quot;%s&amp;quot;&#39;, $str)); } }  怎么使用：
echo &amp;quot;\\nUse JSON encoding / decoding\\n&amp;quot;; var_dump(codepoint_encode(&#39;我好&#39;)); var_dump(codepoint_decode(&#39;\\u6211\\u597d&#39;));  输出：
Use JSON encoding / decoding string(12) &amp;quot;\\u6211\u597d&amp;quot; string(6) &amp;quot;我好&amp;quot;  2. 使用PHP转换Unicode字符为他们的数字值和/或HTML实体 可以使用下面的代码进行转换操作：
if (!function_exists(&#39;mb_internal_encoding&#39;)) { function mb_internal_encoding($encoding = NULL) { return ($encoding === NULL) ? iconv_get_encoding() : iconv_set_encoding(encoding); } } if (!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十八）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-48.html</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-48.html</guid>
      <description>UTF-8 1. 输入  你需要在任何地方存储和使用接收到的UTF-8格式的数据。PHP的mb_check_encoding可以完成这个功能，但是你要始终如一的使用。确实没有办法解决这个问题，因为恶意客户机可以用他们想要的任何编码提交数据。  $string = $_REQUEST[&#39;user_comment&#39;]; if (!mb_check_encoding($string, &#39;UTF-8&#39;)) { $actualEncoding = mb_detect_encoding($string); $string = mb_convert_encoding($string, &#39;UTF-8&#39;, $actualEncoding); }   如果你使用的事HTML5，你可以忽略这一点。你希望浏览器发送给你的所有数据都是UTF-8的。唯一有效的方式是在你的&amp;lt;form&amp;gt;标签中添加accept-charset属性。  &amp;lt;form action=&amp;quot;somepage.php&amp;quot; accept-charset=&amp;quot;UTF-8&amp;quot;&amp;gt;  2. 输出  如果你的系统传输文本到另外的系统，需要通知他们编码方式。在PHP中，你可以在php.ini中设置default_charset选项，或者手动设置Content-Type这个MIME头。这是针对现代浏览器的首选项：  header(&#39;Content-Type: text/html; charset=utf-8&#39;);   如果你不能设置响应头的话，你需要在HTML文件中修改HTML的源信息。
 HTML5  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;   老版本的HTML
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;   3. 数据存储和访问  这个主题主要讨论UTF-8以及在数据库中使用的注意点。如果你想要了解更多的PHP中使用数据库的信息，查看更多的信息。
 存储数据到数据库
 指定你数据库中所有的表和文本列为utf8mb4，这使得MySQL可以物理地存储和检索以UTF-8编码的值。   如果指定了utf8mb4_*排序集（没有显示指定字符集），MySQL将会隐式的使用utf8mb4编码
  老版本的MySQL(早于5.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十七）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-47.html</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-47.html</guid>
      <description>生成器 Yield关键字 一个yield和一个return语句很像，除了终止函数的执行并返回，yield语句返回一个Generator对象并且终止generator函数的执行。
下面是一个使用yield实现的range函数的例子：
function gen_one_to_three() { for ($i = 0; $i &amp;lt; 3; $i++) { yield $i; } }  通过var_dump函数可以看到这个方法返回一个Generator对象。
var_dump(gen_one_to_three()); 输出： class Generator (0) { }  Yield值
之后Generator像数组一样被迭代处理：
foreach (gen_one_to_three() as $value) { echo &amp;quot;$value\n&amp;quot;; }  上面的例子会输出：
1 2 3  带有key的Yield值
处理Yield值之后，你可以使用Yield的键/值对：
function gen_one_to_three() { $keys = [&amp;quot;first&amp;quot;, &amp;quot;second&amp;quot;, &amp;quot;third&amp;quot;]; for ($i = 1; $i &amp;lt;= 3; $i++) { // Note that $i is preserved between yields.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-46.html</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-46.html</guid>
      <description>过滤和过滤函数    参数 详情     variable 要进行筛选的值。注意标量的值在进行筛选之前，在筛选之前内部会将标量值转换为字符串。   filter 将要应用的筛选的ID。手册中列出了有效的变量筛选类型。如果忽略的话，默认会使用FILTER_DEFAULT，这等价于FILTER_UNSAFE_RAW。这将导致默认情况下不进行过滤。   options 选项的关联数组或者标志位的二进制表示。如果筛选器接受选项，标志位可以在数组的&amp;rdquo;flags&amp;rdquo;字段中添加。对于&amp;rdquo;回调&amp;rdquo;筛选器，应该传入可调用类型。这个回调方法必须接受一个参数，就是要筛选的值，并在筛选/清理后返回这个值。    这个扩展通过验证或清理数据来筛选数据。当数据源中包含未知(或外部)的数据(如用户输入的数据)时，是非常有用的。例如，这些数据来自HTML的表格。
1. 验证布尔值 var_dump(filter_var(true, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); //true var_dump(filter_var(false, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); //false var_dump(filter_var(1, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(0, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;1&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(&#39;0&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39; &#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var(&#39;true&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // true var_dump(filter_var(&#39;false&#39;, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false var_dump(filter_var([], FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // NULL var_dump(filter_var(null, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE)); // false  2.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-45.html</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-45.html</guid>
      <description>类型提示 1. 类和接口提示 在PHP5的时候，增加了类和接口的提示。
类提示
&amp;lt;?php class Student { public $name = &#39;Chris&#39;; } class School { public $name = &#39;University of Edinburgh&#39;; } function enroll(Student $student, School $school) { echo $student-&amp;gt;name . &#39; is being enrolled at &#39; . $school-&amp;gt;name; } $student = new Student(); $school = new School(); enroll($student, $school);  上面的例子将会输出：
 Chris is being enrolled at University of Edinburgh
 接口提示
&amp;lt;?php interface Enrollable {}; interface Attendable {}; class Chris implements Enrollable { public $name = &#39;Chris&#39;; } class UniversityOfEdinburgh implements Attendable { public $name = &#39;University of Edinburgh&#39;; } function enroll(Enrollable $enrollee, Attendable $premises) { echo $enrollee-&amp;gt;name .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-44.html</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-44.html</guid>
      <description>流    参数名字 描述     流资源 由&amp;lt;schema&amp;gt;://&amp;lt;target&amp;gt;语法组成的数据提供程序    1. 注册流包装器 流包装器可以为一个或多个特定方案提供处理程序。
下面的例子显示了一个简单的流包装器，当流关闭的的时候发送一个PATCH的HTTP请求。
//注册FooWrapper类作为 foo://URL stream_wrapper_register(&amp;quot;foo&amp;quot;, FooWrapper::class, STREAM_IS_URL) or die(&amp;quot;Duplicate stream wrwapper registered&amp;quot;); class FooWrapper { public $context; private $url; public function stream_open(string $path, string $mode, int $options, string &amp;amp;$openedPath) : bool { $url = parse_url($path); if ($url === false) { return false; } $this-&amp;gt;url = $url[&#39;host&#39;] . &#39;/&#39; . $url[&#39;path&#39;]; return true; } public function stream_write(string $data) : int { $this-&amp;gt;buffer .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-43.html</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-43.html</guid>
      <description>文件处理    参数 描述     filename 要读取的文件名称   use_include_path 如果你想要在include_path中搜索这个文件，可以选择可选的第二个参数，并且把这个参数设置为TRUE。   context 一个环境流资源    1. 便捷方法 1.1 原始直接IO file_get_contents和file_put_contents提供了在一次请求中便捷的从一个文件读取内容到字符串或者将字符串写入一个文件中。
file_put_contents也可以使用FILE_APPEND位标识符来像文件中追加内容，而不是截断或覆盖文件的内容。也可以使用LOCK_EX位标识符来为写文件操作增加一个额外的锁。位标识符可以使用|二进制或来添加。
$path = &#39;file.txt&#39;; //从文件中读取内容 $contents = file_get_contents($file); //做一些修改，比如讲CRLF替换为LF $contents = str_replace(&amp;quot;\r\n&amp;quot;, &amp;quot;\n&amp;quot;, $contents); //将修改后的内容写入文件 file_put_contents($path, $contents);  FILE_APPEND用来像日志文件追加内容，LOCK_FILE用来解决多个进程同时写内容的竞争冲突。例如，将当期session的内容写入文件中：
file_put_contents(&#39;logins.log&#39;, &amp;quot;{$_SESSION[&amp;quot;username&amp;quot;]} logged in&amp;quot;, FILE_APPEND | LOCK_EX);  1.2 CSV IO fgetcsv($file, $length, $separator)  fgetcsv解析读入的行并找出 CSV 格式的字段，成功返回一个包含这些字段的数组，失败的时候返回FALSE。
默认情况下，将只会读取CSV文件中的一行：
$file = fopen(&#39;contacts.csv&#39;, &amp;quot;r&amp;quot;); print_r(fgetcsv($file)); print_r(fgetcsv($file, 5, &amp;quot; &amp;quot;)); fclose($file);  contacts.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-42.html</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-42.html</guid>
      <description>魔术方法 __call()和__callStatic() __call()和__callStatic()将会在某些人调用不存在的对象方法或者静态方法的时候调用。
class Foo { /** * 这个方法将会在某些人调用对象不存在的方法时调用，像 * $foo-&amp;gt;method($arg, $arg1); * * 第一个参数是方法名称 就像上面的method * 第二个参数是由$arg和$arg1组成的数组 */ public function __call($method, $arguments) { $snakeName = CaseHelper::camelToSnake($method); $subMethod = substr($snakeName, 0, 3); $propertyName = substr($snakeName, 4); switch($subMethod) { case &#39;get&#39;: return $this-&amp;gt;data[$propertyName]; case &#39;set&#39;: $this-&amp;gt;data[$propertyName] = $arguments[0]; break; case &#39;has&#39;: return isset($this-&amp;gt;data[$propertyName]); default: throw new BadMethodCallException(&amp;quot;Undefined method $method&amp;quot;); } } public static function __callStatic($method, $arguments) { print_r(func_get_args()); } }  例子</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-41.html</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-41.html</guid>
      <description>Composer依赖关联    参数 详情     license 定义项目想要使用什么类型的证书   authors 定义项目的作者，包括作者的详细信息   support 定义支持邮寄，irc通道，其他的任何连接   require 定义实际依赖的包和包的版本信息   require-dev 定义开发这个项目必须的包   sugget 定义包的建议信息，包括这个包可以有什么作用   autoload 定义项目的自动加载逻辑   autoload-dev 定义开发这个项目的自动加载逻辑    Composer是PHP最常用的依赖管理工具。它就像是Node的npm，Python的pip，.NET的NuGet。
Composer是什么？ Composer是PHP的依赖/包管理工具。这可以用于安装，追踪，更新你的项目依赖。Composer也负责自动加载应用程序所依赖的依赖项，让你可以轻松的在项目中使用依赖项，而不必担心将他们包含在任何文件的顶部。
你项目的依赖信息都放在项目更目录中的composer.json文件中。这个文件包含生产环境和开发环境依赖的包的版本信息。
可以在Composer网站上看到一个composer.json的完整格式信息。
这个文件可以通过编辑器手动编辑，也可以通过composer require &amp;lt;package&amp;gt;或者composer require-dev &amp;lt;package&amp;gt;自动的进行添加。
想要在你的项目中使用composer，你需要在项目中创建composer.json文件。你可以手动创建这个文件，或者通过composer init这个命令创建。在你在终端中运行composer init之后，这将会让你提供项目的一些信息：项目名(vendor/package 例如 laravel/laravel)，描述(可选的)，作者和其他的一些信息，像最低稳定版本，许可证和依赖的包信息等等。
composer.json中的require关键字指明你项目依赖的包名。require关键字使用一个对象来存储包名(monolog/monolog)和相应的版本号。
{ &amp;quot;require&amp;quot;: { &amp;quot;composer/composer&amp;quot;: &amp;quot;1.2.*&amp;quot; } }  想要按照这里定义的依赖包的话，你需要使用composer install命令，这将会下载定义的指定版本的包，并把这个包下载到vendor目录。这非常方便的把第三方的代码放到vendor目录中。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四十）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-40.html</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-40.html</guid>
      <description>Trait 什么是Trait PHP只允许单继承。换句话说，一个类只可以继承一个类。但是当你想要包含不在父类中的功能怎么办？在PHP5.4之前你必须要有创造性，但是在PHP5.4中，引入了Trait。Trait允许你&amp;rdquo;复制并粘贴&amp;rdquo;一个类的一部分到你的类中。
trait Talk { /** @var string */ public $phrase = &#39;Well Wilbur...&#39;; public function speak() { echo $this-&amp;gt;phrase; } } class MrEd extends Horse { use Talk; public function __construct() { $this-&amp;gt;speak(); } public function setPhrase($phrase) { $this-&amp;gt;phrase = $phrase; } }  现在我们有一个继承了Horse的MrEd类。但是不是所有的Horse类都具备Talk的功能，所以我们使用了Trait。注意这里我们是怎么做的。
首先，我们定义了我们的Trait。我们可以使用自动加载和命名空间。然后我们在MrEd中使用use关键字引入。
你注意到MrEd使用Talk的方法和变量但是没有定义他们。还记得我们之前说的&amp;rdquo;复制和粘贴&amp;rdquo;吗？这些方法和变量在类中定义了，就像这个类已经定义了这写方法和变量。
Trait和抽象类很像，定义了变量和方法。你不可以直接实现一个Trait(new Trait())。Trait不能像抽象类和接口那样，让一个类隐式定义一个方法。Trait只用于显示定义(因为你可以实现任意多个接口)。
什么时候应该使用Trait？
讨论Trait时，首先需要考虑的问题就是这个问题。
 我可以通过重构我的代码来避免使用Trait吗？
 答案往往是肯定的。Trait是有单一继承引起的边缘情况。滥用或过度使用Trait的可能性很高。但是考虑到Trait为代码引入了另外的源，这意味着还有另一层复杂性。在这个例子中，我们处理了3个类。但是Trait意味着你不止处理这些。对于每一个特性，您的类都变得更加难以处理，因为您现在必须参考每个特性来找出它定义了什么（并且可能在发生冲突的地方，请参见冲突解决）。理想情况下，代码中的特征应该尽可能少。
促进水平代码重用 假设我们有一个Log的接口：
interface Logger { function log($message); }  现在我们有两个Logger接口的实现类：FileLogger和ConsoleLogger：
class FileLogger implements Logger { public function log($message) { //添加代码实现 } } class ConsoleLogger implements Logger { public function log($message) { //添加实现 } }  现在如果你定义了一个Foo类，你想要实现一些日志任务，你可以像下面一样：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十九）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-39.html</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-39.html</guid>
      <description>正则表达式    参数 详情     $pattern 一个正则表达式的字符串(PCRE)    全局正则表达式匹配 一个全局正则表达式匹配可以使用preg_match_all。preg_match_all返回目标字符串中所有匹配的结果(与只返回第一个匹配结果的preg_match不同)。
preg_match_all返回匹配的数量。$matches包含所有匹配到的结果，并且有第四个参数控制格式。
如果提供一个数组，$matches包含和preg_match返回相同的格式，除了preg_match在第一个匹配之后就终止，但是preg_match_all会迭代整个字符串，直到字符串处理完毕，返回一个包含匹配结果的多维数组，这个数组的格式有第四个参数控制。
第四个参数$flag控制$matches的格式。默认的值是PREG_PATTERN_ORDER，可能的其他值PREG_SET_ORDER和PREG_PATTERN_ORDER。
下面的代码展示栏preg_match_all的用法：
$subject = &#39;a1b c2d3e f4g&#39;; $pattern = &#39;/[a-z]([0-9])[a-z]/&#39;; var_dump(preg_match_all($pattern, $subject, $matches, PREG_SET_ORDER)); //int(3) var_dump($matches); preg_match_all($pattern, $subject, $matches); //默认使用PREG_PATTERN_ORDER var_dump($matches); preg_match($pattern, $subject, $matches); var_dump($matches);  第一个var_dump将会使用PREG_SET_ORDER作为第四个参数：
array(3) { [0]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;a1b&amp;quot; [1]=&amp;gt; string(1) &amp;quot;1&amp;quot; } [1]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;c2d&amp;quot; [1]=&amp;gt; string(1) &amp;quot;2&amp;quot; } [2]=&amp;gt; array(2) { [0]=&amp;gt; string(3) &amp;quot;f4g&amp;quot; [1]=&amp;gt; string(1) &amp;quot;4&amp;quot; } }  $matchs有3个子数组，每个数组代表一个匹配结果，有着和preg_match相同的格式。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十八）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-38.html</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-38.html</guid>
      <description>解析HTML 从字符串解析HTML PHP实现了一个DOM Level 2的解析器，允许你使用getElementById()和appendChild()这样的方法来处理HTMl。
$html = &#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;span id=&amp;quot;text&amp;quot;&amp;gt;Hello World!&amp;lt;/span&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;; $doc = new DOMDocument(); libxm_use_internal_errors(true); $doc-&amp;gt;loadHTML($html); echo $doc-&amp;gt;getElementById(&#39;text&#39;)-&amp;gt;textContent;  输出：
Hello World!  注意对应HTML的问题，PHP都会发出警告，特别是在导入文档片段的时候。为了避免这些警告，通过libxml_use_internal_errors()来通知DOM库(libxml)处理自己的错误。如果需要的话，可以使用libxml_get_errors()来处理错误。
XPath $html = &#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;span class=&amp;quot;text&amp;quot;&amp;gt;Hello, World!&amp;lt;/span&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;; $doc = new DOMDocument(); $doc-&amp;gt;loadHTML($html); $xpath = new DOMXPath($doc); $span = $xpath-&amp;gt;query(&amp;quot;//span[@class=&#39;text&#39;]&amp;quot;)-&amp;gt;item(0); echo $span-&amp;gt;textContent;  输出：
Hello, World!  SimpleXML 介绍
 SimpleXML是一个提供了便捷处理XML文档的PHP库(特别是读取和迭代XML数据) 唯一的限制就是XML文档必须是格式良好的。  过程方法
// Load an XML string $xmlstr = file_get_contents(&#39;library.xml&#39;); $library = simplexml_load_string($xmlstr); // Load an XML file $library = simplexml_load_file(&#39;library.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十七）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-37.html</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-37.html</guid>
      <description>SimpleXML SimpleXML读取数据 字符串 使用simplexml_load_string从字符串创建一个SimpleXMLElement。
$xmlString = &amp;quot;&amp;lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&amp;gt;&amp;quot;; $xml = simplexml_load_string($xmlString) or die(&amp;quot;Error: Cannot create object&amp;quot;);  注意这里使用or而不是||,因为or的优先级比=低。or后面的代码只有在$xml解析为false时才会执行。
文件 使用simplexml_load_file从一个文件地址加载数据：
$xml = simplexml_load_string(&amp;quot;filePath.xml&amp;quot;); $xml = simplexml_load_string(&amp;quot;https://example.com/doc.xml&amp;quot;);  这个URL可以是任何PHP支持的格式，或者自定义的流封装。
参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十六）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-36.html</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-36.html</guid>
      <description>XML 使用DomDocument创建XML 使用DomDocument创建XML，我们需要使用createElement()和createAttribute()来创建所有的标签和属性。然后会用appendChild()来创建XML的结构。
下面的例子包含标签，属性，CDATA部分和第二个标签的不同命名空间：
$dom = new DOMDocument(&#39;1.0&#39;, &#39;utf-8&#39;); $dom-&amp;gt;preserveWhiteSpace = false; $dom-&amp;gt;formatOutput = true; //创建没有值的主标签 $books = $dom-&amp;gt;createElement(&#39;books&#39;); $book_1 = $dom-&amp;gt;createElement(&#39;book&#39;); //创建带值的标签 $name_1 = $dom-&amp;gt;createElement(&#39;name&#39;, &#39;PHP - An Introduction&#39;); $price_1 = $dom-&amp;gt;createElement(&#39;price&#39;, &#39;$5.95&#39;); $id_1 = $dom-&amp;gt;createElement(&#39;id&#39;, &#39;1&#39;); //创建并添加属性 $attr_1 = $dom-&amp;gt;createAttribute(&#39;version&#39;); $attr_1 -&amp;gt; value = &#39;1.0&#39;; $id_1-&amp;gt;appendChild($attr_1); //创建第二个不同命名空间的标签 $namespace = &#39;www.example.com/libraryns/1.0&#39;; //在books标签前面添加命名空间 $books-&amp;gt;setAttributeNS(&#39;http://www.w3.org/2000/xmlns/&#39;, &#39;xmlns:ns&#39;, $namespace); $book_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:book&#39;); $name_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:name&#39;); //创建CDATA部分，并放入name标签 $name_cdata = $dom-&amp;gt;createCDATASection(&#39;PHP - Advanced&#39;); $name_2 -&amp;gt; appendChild($name_cdata); $price_2 = $dom-&amp;gt;createElementNS($namespace, &#39;ns:price&#39;, &#39;$25.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十五）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-35.html</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-35.html</guid>
      <description>依赖注入 依赖注入(DI)是&amp;rdquo;传入&amp;rdquo;的一种花哨说法。这实际含义就是对一个对象的依赖通过构造函数或set方法来传入，而不是在对象内部创建这些依赖对象。依赖注入也可能指的是自动构造和注入的依赖注入容器。
构造函数注入 对象通常依赖于另外的对象。相对于在构造函数中创建依赖对象，应该把依赖对象作为参数传入构造函数。这样可以确保对象之间没有紧密耦合，并且可以更改对类实例化的依赖性。这有许多好处，包括通过使依赖关系显式化使代码更容易阅读，以及使测试更简单，因为依赖关系可以更容易地被切换和模拟。
在下面的例子中，Component依赖一个Logger实例，但是它不创建这个实例。而是在构造函数中通过参数传入。
interface Logger { public function log(string $message); } class Component { private $logger; public function __construct(Logger $logger) { $this-&amp;gt;logger = $logger; } }  没有依赖注入的话，代码就像下面这样：
class Component { private $logger; public function __construct() { $this-&amp;gt;logger = new FooLogger(); } }  在构造函数中使用new来创建新对象表明没有使用依赖注入(或者使用不完全)，这里代码是高度绑定的。这也说明代码没有完全测试，或者可能有一些脆弱的测试，这些测试对程序状态做出错误的假设。
在上面的例子中，我们使用依赖注入，如果需要的话，我们可以很方便的修改使用不同的Logger对象。例如，我们可能需要使用不同的Logger实现来把日志存放到不同的位置，或者使用不同的日志格式，或者把日志存入数据库而不是文件。
Setter注入 依赖也可以使用setter方法进行注入：
interface Logger { public function log($message); } class Component { private $logger; private $databaseConnection; public function __construct(DatabaseConnection $databaseConnection) { $this-&amp;gt;databaseConnection = $databaseConnection; } public function setLogger(Logger $logger) { $this-&amp;gt;logger = $logger; } public function core() { $this-&amp;gt;logSave(); return $this-&amp;gt;databaseConnection-&amp;gt;save($this); } public function logSave() { if ($this-&amp;gt;logger) { $this-&amp;gt;logger-&amp;gt;log(&#39;saving&#39;); } } }  当类的core方法不依赖于依赖项的话，这是很有意思的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十四）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-34.html</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-34.html</guid>
      <description>反射 类或对象的特征 类的特征检查可以使用property_exists和method_exists来实现。
class MyClass { public $public_field; protected $protected_field; private $private_field; static $static_field; const CONSTANT = 0; public function public_function() {} protected function protected_function() {} } // check properties $check = property_exists(&#39;MyClass&#39;, &#39;public_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;protected_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;private_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;static_field&#39;); $check = property_exists(&#39;MyClass&#39;, &#39;other_field&#39;); // check methods $check = method_exists(&#39;MyClass&#39;, &#39;public_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;protected_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;private_function&#39;); $check = method_exists(&#39;MyClass&#39;, &#39;static_function&#39;); // however.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十三）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-33.html</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-33.html</guid>
      <description>cURL扩展 curl_init 初始化一个cURL
   参数 详情     url 应用cURL请求的url网址    curl_setopt 设置cURL传输的选项
   参数 详情     ch cURL处理的对象(curl_inti()返回的值)   option CURLOPT_XXX将用来设置选项，查看PHP手册查看选项和接受值的列表   value 设置cURL选项的值    curl_exec 执行以cURL请求
   参数 详情     ch cURL处理的对象(curl_init()返回的值)    curl_close 结束一个cURL请求
   参数 详情     ch cURL处理的对象(curl_init()返回的值)    基本用法(GET请求) cURL是一个使用URL语法传输数据的工具。支持HTTP，FTP，SCP和其他的类型(curl&amp;gt;=7.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十二）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-32.html</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-32.html</guid>
      <description>SOAP客户端    参数 详情     $wsdl WSDL的URI，如果不是 WSDL模式的化，是Null   options Soap客户端的选项数组，非WSDL模式要设置location和uri，其他的选项是可选的。查看下面的值    WSDL模式 首先，创建一个新的SoapClient对象，传入一个WSDL文件的URL和选项的数组。
$soap = new SoapClient(&#39;https://example.com/soap.wsdl&#39;, [ &#39;soap_version&#39; =&amp;gt; SOAP_1_2, &#39;compression&#39; =&amp;gt; SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_GIZP, &#39;cache_wsdl&#39; =&amp;gt; WSDL_CACHE_BOTH, &#39;trace&#39; =&amp;gt; TRUE, &#39;exceptions&#39; =&amp;gt; TRUE ]);  然后使用$soap对象调用SOAP的方法：
$result = $soap-&amp;gt;requestData([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);  非WSDL模式 这个和WSDL模式相似的，传入WSDL文件的地址为NULL，必须传下location和uri选项。
$soap = new SoapClient(NULL, [ &#39;location&#39; =&amp;gt; &#39;https://example.com/soap/endpoint&#39;, &#39;uri&#39; =&amp;gt; &#39;namespace&#39; ]);  类图 当在PHP中创建SOAP客户端的时候，你可以使用classmap键的配置数组。classmap定义了WSDL实际使用的类型，而不是默认的stdClass。使用这个的原因是因为你可以获取这些类自实现的字段和方法调用，而不是猜测stdClass有什么字段。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十一）</title>
      <link>http://blog.huaifufeng.com/2019/05/post/php-section-31.html</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/php-section-31.html</guid>
      <description>JSON json_encode
   参数 详情     value 进行编码的值。除了资源类型外其他都可以。所有字符串数据必须是UTF-8的格式。   options 二进制位标识符，包括JSON_HEX_QUOT,JSON_HET_TAG,JSON_HEX_AMP,JSON_HEX_APOS,JSON_NUMERIC_CHECK,JSON_PRETTY_PRINT,JSON_UNESCAPED_SLASHES,JSON_FORCE_OBJECT,JSON_PRESERVE_ZERO_FRACTION,JSON_UNESCAPED_UNICODE,JSON_PARTIAL_OUTPUT_ON_ERROR.这些常量的行为在jSON常量页有详细描述。   depth 设置最大的深度。必须是一个大于0的数    json_decode
   参数 详情     json 需要被解码的json字符串。这个函数只能处理UTF-8编码的字符串。   assoc 函数返回关联数组而不是对象   options JSON解码的二进制标识选项。当前只支持JSON_BIGINT_AS_STRING(默认会把大数字处理为浮点数)    JSON(JavaScript对象表示法)是一个平台和语言无关的将对象序列化到一个字符串的方法。因为这经常被用到web中，所以PHP中上线了一个JSON的基本扩展。
解码JSON字符串 json_decode()函数获取一个JSON编码的字符串作为第一个参数，将这个值解码到一个PHP变量中。
通常，json_decode()函数根据参数的不同会返回不同的结果，如果JSON对象的顶层元素是一个字典，将会返回一个\stdClass的对象；如果是一个数组，将会返回一个索引数组。对于某些标量值，像一些简单字符串&amp;rdquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;,&amp;ldquo;null&amp;rdquo;，将会返回标量值或NULL。在错误的时候将会返回Null。
$json_string = &#39;{&amp;quot;name&amp;quot;:&amp;quot;Jeff&amp;quot;, &amp;quot;age&amp;quot;:20, &amp;quot;active&amp;quot;:true, &amp;quot;colors&amp;quot;:[&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]}&#39;; $object = json_decode($json_string); //返回一个对象 printf(&amp;quot;Hello %s, You are %s years old.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-30.html</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-30.html</guid>
      <description>输出缓存    方法 详细说明     ob_start() 开启输出缓存，任何这个位置之后的输出（处理http头）都会被捕获不会直接显示   ob_get_contents() 返回ob_start()捕获的内容   ob_end_clean() 清空输出缓冲区并为当前嵌套级别关闭它   ob_get_clean() 执行ob_get_contents()和ob_end_clean()两个操作   ob_get_level() 返回输出缓冲区的当前嵌套级别   ob_flush() 在不结束缓存的情况下，输出缓存的内容并发送给浏览器   ob_implict_flush() 开启隐式刷新，在每次输出之后都会刷新   ob_end_flush() 刷新内容缓冲区并将其发送到浏览器，同时结束缓冲区    获取内容并清空 输出缓存允许你把一些文本内容(text，html)存储到一个变量中，然后在脚本结束之后一次性发送给浏览器。默认情况下，PHP解析内容之后会直接发送给浏览器：
&amp;lt;?php //开启缓存 ob_start(); //输出内容 print &amp;quot;Hello&amp;quot;; //可以跳出php ?&amp;gt; &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt; &amp;lt;?php //获取缓存内容并情况缓存 $content = ob_get_clean(); # $content = ob_get_contents(); # $did_clear_buffer = ob_end_clean(); print($content); //Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;  在ob_start()和ob_get_clean()之间的内容输出会被放到变量$content中。调用ob_get_clean()相当于同时调用了ob_get_contents()和ob_end_clean()。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-29.html</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-29.html</guid>
      <description>Cookie    参数 详细说明     name cookie的名称。这个也是你可以从$_COOKIE中获取值的名称。这个是唯一必须的参数   value cookie中存储的值。这个数据可以从浏览器中访问，所以不要在这放敏感信息·   expire 一个代表cookie过期时间的Unix的时间戳。如果过期时间设置为0，cookie将会在session失效时同时失效。如果设置一个比当前时间早的时间戳，cookie会立即失效。   path cookie的范围。如果设置为/这个cookie会在整个域名下有效。如果设置为/somePath/cookie将会只在这个路径和这个路径的子路径中有效。默认cookie会设置为当前问文件的路径   domain cookie有效的域名和子域名。如果设置为一级域名stackoverflow.com，这个cookie会在这个域名和子域名中有效。如果设置为sub.stackoverflow.com，这个cookie只会在这个子域名和子域名的子域名下面有效。   secure 如果设置为true，这个cookie只有当客户端和服务端为https时才会设置。   httponly 指明这个cookie只能通过http/s协议进行设置，不能使用JavaScript这样的客户端语音设置。只在PHP5.2之后有效    一个HTTP的cookie就是：当用户浏览器浏览的时候，一些从服务器发送到用户端，并存储在用户电脑浏览器下面的数据。
修改cookie 可以使用setcookie来修改cookie中存储的值：
setcookie(&#39;user&#39;, &#39;John&#39;, time()+86400, &#39;/&#39;);   cookie是HTTP头的一部分，所有setcookie()方法需要在发送数据到浏览器之前调用。当修改cookie的时候，需要保证path和domain的参数和原来cookie的值一致，否则将会创建一个新的cookie。当你发送cookie的时候，cookie的值部分会被自动的进行urlencode操作。当接收cookie的时候，会被自动的decode并且赋值给cookie名称相同的变量中。
 设置cookie 使用setcookie方法来设置一个cookie。因为cookie是HTTP头的一部分，所以你必须在发送数据到浏览器之前设置cookie。例如：
setcookie(&#39;user&#39;, &#39;Tom&#39;, time( + 86400), &#39;/&#39;);  参数说明：
 创建一个名称为user的cookie (可选)为这个cookie设置值Tom (可选)这个cookie将会在1天之后过期 (可选)这个cookie在整个站点/中都有效 (可选)cookie只能使用HTTPS传输 (可选)cookie不能被类似JavaScript的脚本语言访问   创建或修改一个cookie只能在(path和domain指定的)子请求生效，在$_COOKIE也不是立即生效的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-28.html</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-28.html</guid>
      <description>Session session_start() 开启PHP的session，我们可以给session_start函数传一个session的选项数组。例如：
&amp;lt;?php if(version_compare(PHP_VERSION, &#39;7.0.0&#39;) &amp;gt;= 0) { session_start([ &#39;cache_limiter&#39; =&amp;gt; &#39;private&#39;, &#39;read_and_close&#39; =&amp;gt; true, ]); } else { session_start(); }  这个功能在php.ini提供了新的配置项session.lazy_write，这个值默认是true，当session修改的时候session的数据将会被重写。
查看手册。
Session锁 正如我们知道的PHP会把session数据希尔服务器的一个文件中。当一个使用session_start启动session的脚本接收到一个请求的时候，PHP将会锁定这个session文件，从而阻止/等待同一session_id的其他请求。因此其他请求将会在session_start的位置阻塞，直到这个session文件释放锁定。
这个session文件将会被锁定，直到脚本执行完毕或者session手动关闭了。为了避免这种情况(避免多个请求被阻塞)。我们开启一个session并且当操作完毕之后关闭这个session，这样就会释放文件锁，其他的请求就可以继续进行。
// php &amp;lt; 7.0 // start session session_start(); // write data to session $_SESSION[&#39;id&#39;] = 123; // session file is locked, so other requests are blocked // close the session, release lock session_write_close();  现在有些人会想，如果session关闭，我们如何读取到session值。在session关闭后，session仍然是可用的。所以，我们仍然可以读取session数据。
echo $_SESSION[&#39;id&#39;]; //123  在PHP7.0之后，我们可以使用只读session，读写session，延迟写session，这样我们就没有必要使用session_write_close()。
操作session数据 $_SESSION就是一个数组，所以你可以像普通数组一样检索和操作它。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-27.html</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-27.html</guid>
      <description>命名空间 声明命名空间 一个命名空间可以像下面这样：
 namespace MyProject 声明一个命名空间MyProject namespace MyProject\Security\Cryptography 声明一个嵌套的命名空间 namespace MyProject {…} 声明一个花括号包围的命名空间  虽然你可以在一个文件中声明多个命名空间，但是强烈建议一个文件只声明一个命名空间：
namespace First { class A { ... }; // Define class A in the namespace First. } namespace Second { class B { ... }; // Define class B in the namespace Second. } namespace { class C { ... }; // Define class C in the root namespace. }  每当你声明了一个命名空间，你在之后定义的类都在这个命名空间里面：
namespace MyProject\Shapes; class Rectangle { .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-26.html</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-26.html</guid>
      <description>类和对象 类和对象通过将相同功能代码组合起来来提高代码的效率和减少代码的重复。
一个类用来定义一组生成对象的数据结构和行为。然后通过这个结构生成多个对象。
类常量 类常量提供了在程序中保存固定值的方式。也就是，他们提供了一种将名称(以及相关的编译时检查)赋予类似3.14和apple这样值的方法。类常量只能使用const关键字定义，不能使用define这个方法。
例如下面这个例子，定义了π在程序中的简短表示。在类中使用const来将这些值保存下来：
class MathValues { const PI = M_PI; const PHI = 1.61803; } $area = MathValues::PI * $radius * $radius;  类常量使用双冒号运算符(所谓的作用域解析运算符)来访问，很像静态变量。但是和静态变量不同的是，类常量是在编译时确定的，不能进行赋值操作(例如MathValues::PI = 7将会产生致命错误)。
类常量可以用来定义类内部的内容，这些内容稍后可能需要更改(但更改频率不足以保存到数据库)。我们可以在内部使用self域名解析器来处理它(在实例和静态实现中都有效)。
class Labor { const LABOR_UNITS = 0.26; // const LABOR_COST = 12.75; public function getLaborConst($number_units) { return (self::LABOR_UNITS * self::LABOR_COST) * $number_units; } }  在PHP5.6之前，类常量只需要包含标量值。
在PHP5.6我们可以在常量定义使用表达式，这包括：数学运算，字符串拼接。
class Labor { const LABOR_COSTS = 12.75 * 0.26; public function getLaborCost($number_units) { return self::LABOR_COSTS * $number_units; } }  在PHP7，我们可以使用define定义常量的值为数组。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-25.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-25.html</guid>
      <description>字符串解析 分割字符串 explode和strstr是用来是用分隔符获取字符串子串的方法。
一个字符串包含使用相同分隔符分割的几部分，可以使用explode将字符串分成几部分：
$fruits = &amp;quot;apple,pear,grapefruit,cherry&amp;quot;; print_r(explode(&#39;,&#39;, $fruits)); // [&#39;apple&#39;, &#39;pear&#39;, &#39;grapefruit&#39;, &#39;cherry&#39;]  这个方法支持一个参数，用来限制分割的子串数量：
$fruits = &#39;apple,pear,grapefruit,cherry&#39;; print_r(explode(&#39;,&#39;,$fruits,0)); // [&#39;apple,pear,grapefruit,cherry&#39;]  如果这个参数是0，将会按照1处理。
如果这个限制参数是大于0的值，将会返回最多包含这个值的子串，其中最后一个子串包含所有剩余的部分。
print_r(explode(&#39;,&#39;,$fruits,2)); // [&#39;apple&#39;, &#39;pear,grapefruit,cherry&#39;]  如果这个参数为负数，将会返回处理最后这几个子串之外的其他子串：
print_r(explode(&#39;,&#39;,$fruits,-1)); // [&#39;apple&#39;, &#39;pear&#39;, &#39;grapefruit&#39;]  explode可以使用list来把子串放入不同的变量中：
$email = &amp;quot;user@example.com&amp;quot;; list($name, $domain) = explode(&amp;quot;@&amp;quot;, $email);  但是要保证explode返回足够的值，否则将会参数index未定义的错误。
strstr将会把字符串分为两部分，然后根据第二个参数确定返回哪部分，默认返回后面的部分：
$string = &amp;quot;1:23:456&amp;quot;; echo json_encode(explode(&amp;quot;:&amp;quot;, $string)); // [&amp;quot;1&amp;quot;,&amp;quot;23&amp;quot;,&amp;quot;456&amp;quot;] var_dump(strstr($string, &amp;quot;:&amp;quot;)); // string(7) &amp;quot;:23:456&amp;quot; var_dump(strstr($string, &amp;quot;:&amp;quot;, true)); // string(1) &amp;quot;1&amp;quot;  子串 substr返回字符串指定开始位置和指定长度的子字符串。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-24.html</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-24.html</guid>
      <description>字符串格式 字符串插值 你可以使用字符串插值在字符串中插入一个变量。字符串插值只在双引号字符串和heredoc表达式中有效。
$name = &#39;Joel&#39;; //$name会解析为Joel echo &amp;quot;&amp;lt;p&amp;gt;Hello $name, Nice to see you.&amp;lt;/p&amp;gt;&amp;quot;; //将会输出&amp;lt;p&amp;gt;Hello Joel, Nice to see you.&amp;lt;/p&amp;gt; //单引号，变量不会解析 echo &#39;Hello $name, Nice to see you.&#39;; //输出：Hello $name, Nice to see you.  复杂（花括号）语法提供了另一种在字符串中插入变量的语法，就是在变量的周围加上{}。这在变量和文本在一起时是很有用的，避免可能存在的变量和文本引起的歧义。
$name = &#39;Joel&#39;; // Example using the curly brace syntax for the variable $name echo &amp;quot;&amp;lt;p&amp;gt;We need more {$name}s to help us!&amp;lt;/p&amp;gt;&amp;quot;; #&amp;gt; &amp;quot;&amp;lt;p&amp;gt;We need more Joels to help us!&amp;lt;/p&amp;gt;&amp;quot; // This line will throw an error (as `$names` is not defined) echo &amp;quot;&amp;lt;p&amp;gt;We need more $names to help us!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-23.html</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-23.html</guid>
      <description>控制结构备用语法 if/else语句 &amp;lt;?php if ($condition): do_something(); elseif ($another_condition): do_something_else(); else: do_something_different(); endif; ?&amp;gt; &amp;lt;?php if ($condition): ?&amp;gt; &amp;lt;p&amp;gt;Do something in HTML &amp;lt;/p&amp;gt; &amp;lt;?php elseif ($another_condition): ?&amp;gt; &amp;lt;p&amp;gt;Do something else in HTML&amp;lt;/p&amp;gt; &amp;lt;?php else: ?&amp;gt; &amp;lt;p&amp;gt;Do something different in HTML &amp;lt;/p&amp;gt; &amp;lt;?php endif; ?&amp;gt;  for &amp;lt;?php for ($i = 0; $i &amp;lt; 10; $i++): do_something($i); endfor; ?&amp;gt; &amp;lt;?php for ($i=0; $i &amp;lt; 10; $i++): ?&amp;gt; &amp;lt;p&amp;gt;Do something in HTML with &amp;lt;?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-22.html</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-22.html</guid>
      <description>函数式编程 PHP的函数式编程依赖于函数。PHP中的函数提供了组织和重用代码段的功能。函数简化了编码过程，防止冗余的代码，并使代码编译维护。这个主题描述了PHP中函数、形参，实参，返回语句和作用域的声明和使用。
闭包 闭包就是一个不能外部访问的匿名函数。
当声明一个匿名函数，你也就创建了这个函数的&amp;rdquo;命名空间&amp;rdquo;。它现在只有在这个命名空间可以访问。
$externalVariable = &amp;quot;Hello&amp;quot;; $secondExternalVariable = &amp;quot;Foo&amp;quot;; $myFunction = function() { var_dump($externalVariable, $secondExternalVariable); //返回错误，因为变量没有定义 };  这个函数没有访问外部变量的权限。想要使用外部的变量，你可以使用use()来将外部变量放入闭包函数内部：
$myFunction = function() use($externalVariable, $secondExternalVariable) { var_dump($externalVariable, $secondExternalVariable); };  这主要由于PHP严格变量范围：如果一个变量没有在命名空间中定义，并且没有使用global引入进来，这个变量就没有定义。
也要注意：
 从父命名空间继承变量和使用全局变量是不一样的。全局变量在全局命名空间中，不论函数在哪里执行。闭包函数的父命名空间是闭包定义的地方(而不是函数实际调用的地方)。
 查看PHP手册。
在PHP中，闭包使用早期绑定方法。这意味着使用use关键字传递给闭包命名空间的变量的值是闭包定义时的值。
想要修改这种行为的话，可以使用引用传值：
$rate = .05; $calculateTax = function($value) use ($rate) { return $value * $rate; } $rate = .1; print $calculateTax(100); //5 $rate = .05; $calculateTax = function($value) use (&amp;amp;$rate) { return $value * $rate; } $rate = .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-21.html</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-21.html</guid>
      <description>函数 可变长度参数 Version&amp;gt;=5.6
PHP5.6提供了可变长度的参数列表。在变量名前添加…运算符表示这个变量是可变参数。这个变量将会包含这个位置之后所有参数的一个数组。
function variadic_func($nonVariadic, ...$variadic) { echo json_encode($variadic); } variadic_func(1, 2, 3, 4); // prints [2,3,4]  可以在...符号前面添加类型名称：
function foo(Bar ...$bars) {}  &amp;amp;可以添加在…之前，变量名称之后，就像下面这个例子：
class Foo{} function a(Foo &amp;amp;...$foos){ $i = 0; foreach($foos as &amp;amp;$foo){ // note the &amp;amp; $foo = $i++; } } $a = new Foo; $c = new Foo; $b =&amp;amp; $c; a($a, $b); var_dump($a, $b, $c);  这将会输出：
int(0) int(1) int(1)  另一方面，可以解压缩数组（或Traversable）以便以参数列表的形式传递给函数：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-20.html</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-20.html</guid>
      <description>循环 循环是编程语言非常重要的部分。这允许程序员创作循环执行几次的代码片段或者迭代处理。循环的次数可以是显示的(例如6次)，或者循环直到遇到了某个条件。
这个主题包括不同类型的循环结构，他们关联的控制结构，他们潜在的应用。
continue  continue中断一个循环中当前的迭代，但是不会中断这个循环。
 就像break语句一样，continu语句是在循环体内部的。当执行了continu语句，将会立即跳到循环条件判断语句。
在下面的例子中，循环根据数组的值输出指定的信息，但是跳过指定的值。
$list = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]; foreach ($list as $value) { if ($value == &#39;banana&#39;) { continue; } echo &amp;quot;I love to eat {$value} pie.&amp;quot; . PHP_EOL; }  这将会输出：
I love to eat apple pie. I love to eat cherry pie;  continue也可以用来中断外部循环通过为continue提供中断循环的级数。例如，data的数据向下面一样，为了找到花费小于5的水果派：
$data = [ [&#39;Fruit&#39; =&amp;gt; &#39;Apple&#39;, &#39;Color&#39; =&amp;gt; &#39;Red&#39;, &#39;Cost&#39; =&amp;gt; 1], [&#39;Fruit&#39; =&amp;gt; &#39;Banana&#39;, &#39;Color&#39; =&amp;gt; &#39;Yellow&#39;, &#39;Cost&#39; =&amp;gt; 7], [&#39;Fruit&#39; =&amp;gt; &#39;Cherry&#39;, &#39;Color&#39; =&amp;gt; &#39;Red&#39;, &#39;Cost&#39; =&amp;gt; 2], [&#39;Fruit&#39; =&amp;gt; &#39;Grape&#39;, &#39;Color&#39; =&amp;gt; &#39;Green&#39;, &#39;Cost&#39; =&amp;gt; 4] ]; foreach($data as $fruit) { foreach($fruit as $key =&amp;gt; $value) { if ($key == &#39;Cost&#39; &amp;amp;&amp;amp; $value &amp;gt;= 5) { continue 2; } } var_dump($fruit); }  当continue 2;执行的时候，程序立即跳转到$data as $fruit，然后开始执行下一个外部循环，调过了其他的代码(包括内部循环的条件语句)。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</guid>
      <description>控制结构 if else if语句允许当满足条件时，执行一段代码。当你想条件不满足时执行另外的代码可以使用if else。
if ($a &amp;gt; $b) { echo &amp;quot;a is greater than b&amp;quot;; } else { echo &amp;quot;a is not greater than b&amp;quot;; }  查看PHP手册。
三元运算符是if-else的短语法 三元预算符根据条件是true还是false来执行一些条件。这是一个比较预算符，通常用来将if-else语句变成简单的格式。这允许快速测试一个条件，然后通常用来替换多行的if语句，让你的代码更加紧凑。
下面就是一个三元运算符的例子，这里$a=1,$b=2:
echo ($a &amp;gt; $b) ? &amp;quot;a is greated than b&amp;quot; : &amp;quot;a is not greater than b&amp;quot;;  输出：a is not greater than b
控制结构备用语法 PHP提供了控制结构备用的语法：if while for foreach switch。
和普通的语法相比，不同的地方在于：这里使用:来代替开始花括号，使用endif; endwhile; endfor; endforeach; endswitch;来代替结束花括号。有关各个示例，请参阅有关控制结构的备用语法的主题。
if ($a == 42): echo &amp;quot;The answer to life, the universe and everything is 42.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</guid>
      <description>操作日期和时间 获取两个时间的差 最可行的方法是使用DateTime类。例如：
&amp;lt;?php //创建一个指定时间的对象 2年前 $twoYearAgo = new DateTime(&#39;2017-04-29 22:00:00&#39;); //创建一个当前时间的对象 $now = new DateTime(&#39;2019-04-29 22:00:00&#39;) //计算差 $diff = $now-&amp;gt;diff($twoYearAgo); //获取diff结果中的数据 $yearsDiff = $diff-&amp;gt;y; $monthsDiff = $diff-&amp;gt;m; $daysDiff = $diff-&amp;gt;d; $hoursDiff = $diff-&amp;gt;h; $minsDiff = $diff-&amp;gt;i; $secondsDiff = $diff-&amp;gt;s; //差别的天数 $totalDaysDiff = $diff-&amp;gt;days; var_dump($diff);  另外比较两个日期也是很简单的，直接使用比较运算符：
&amp;lt;?php // Create a date time object, which has the value of ~ two years ago $twoYearsAgo = new DateTime(&amp;quot;2014-01-18 20:05:56&amp;quot;); // Create a date time object, which has the value of ~ now $now = new DateTime(&amp;quot;2016-07-21 02:55:07&amp;quot;); var_dump($now &amp;gt; $twoYearsAgo); // prints bool(true) var_dump($twoYearsAgo &amp;gt; $now); // prints bool(false) var_dump($twoYearsAgo &amp;lt;= $twoYearsAgo); // prints bool(true) var_dump($now == $now); // prints bool(true)  转换日期格式 基本 最简单的转换日期的格式是联合使用strtotime和date。strtotime函数会把一个字符串时间转换为一个Unix时间戳。这个Unix的时间戳可以使用函数date转换为一个新的格式：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</guid>
      <description>Datetime类 可变到不可变 从PHP5.6之前的可变版本到现在的不可变版本。
在PHP5.6之后创建一个\DateTimeImmutable类：
\DateTimeImmutable::createFromMutable($concrete);  在PHP5.6之前：
\DateTimeImmutable::createFromFormat(\DateTime::ISO8601, $mutable-&amp;gt;format(\DateTime::ISO8601), $mutable-&amp;gt;getTimezone());  加减日期间隔 我们可以使用DateInterval在DateTime对象上增加或减少一定时间间隔。
下面的例子，我们在对象上增加7天，然后打印输出到屏幕上面：
$now = new DateTime();// empty argument returns the current date $interval = new DateInterval(&#39;P7D&#39;);//this objet represents a 7 days interval $lastDay = $now-&amp;gt;add($interval); //this will return a DateTime object $formatedLastDay = $lastDay-&amp;gt;format(&#39;Y-m-d&#39;);//this method format the DateTime object and returns a String echo &amp;quot;Samara says: Seven Days. You&#39;ll be happy on $formatedLastDay.&amp;quot;;  这将会输出(在2019-04-29时运行)：
  Samara says: Seven Days.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</guid>
      <description>一次处理多个数组 数组交集 array_intersect将会将所有数组中共有的值放入一个数组中。
$array_one = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]; $array_two = [&#39;two&#39;, &#39;three&#39;, &#39;four&#39;]; $array_three = [&#39;two&#39;, &#39;three&#39;]; $intersect = array_intersect($array_one, $array_two, $array_three); // $intersect contains [&#39;two&#39;, &#39;three&#39;]  第一个数组的key将会被保留，数字索引不会。
array_intersect只会检查数组的值，array_intersect_assoc将会对key也进行比较：
$array_one = [1 =&amp;gt; &#39;one&#39;,2 =&amp;gt; &#39;two&#39;,3 =&amp;gt; &#39;three&#39;]; $array_two = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;, 3 =&amp;gt; &#39;two&#39;, 4 =&amp;gt; &#39;three&#39;]; $array_three = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;]; $intersect = array_intersect_assoc($array_one, $array_two, $array_three); // $intersect contains [1 =&amp;gt;&#39;one&#39;,2 =&amp;gt; &#39;two&#39;]  array_intersect_key将会检查数组的key，将会返回数组中都存在的key：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</guid>
      <description>操作数组 筛选数组 从数组中筛选值，并且把按照筛选条件找出的值放入一个新数组中，可以使用array_filter函数。
筛选非空数组 一个简单例子来筛选非空的值：
$myArray = [1, 0, 2, null, 3, &#39;&#39;, 4, [], 5, 6, 7, 8]; $nonEmpties = array_filter($myArray); //[1, 2, 3, 4, 5, 6, 7, 8];  使用回调筛选 我们可以定义我们自己的筛选规则。这里假设我们想要偶数值：
$myArray = [1, 2, 3, 4, 5, 6, 7, 8]; $evenNumbers = array_filter($myArray, function($number) { return $number % 2 === 0; })  array_filter的第一个参数是等待筛选的数组，第二个参数是定义筛选规则的回调函数。
按索引筛选 Version &amp;gt;= 5.6
array_filter的第三个参数是用来决定哪个值传递给回调函数。这个参数有两个选项：ARRAY_FILTER_USE_KEY 或 ARRAY_FILTER_USE_BOTH。这决定回调函数的参数是数组的key还是key和值都有。例如，你想要使用索引而不是值：
$numbers = [16,3,5,8,1,4,6]; $even_indexed_numbers = array_filter($numbers, function($index) { return $index % 2 === 0; }, ARRAY_FILTER_USE_KEY);  筛选结果数组的索引 注意：array_filter函数会保留原本数组的key。一个常见的错误是使用for循环处理筛选后的数组：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</link>
      <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</guid>
      <description>对数组操作 对数组每个元素进行函数处理 对数组每一个元素进行函数的处理，使用array_map函数。这将会返回一个新的数组。
$array = array(1,2,3,4,5); //each array item is iterated over and gets stored in the function parameter. $newArray = array_map(function($item) { return $item + 1; }, $array);  返回的新数组$newArray的值是array(2,3,4,5,6)。
除了使用匿名函数外，还可以使用一个命名的函数。上面的例子也可以写成下面这样：
function addOne($item) { return $item + 1; } $array = array(1, 2, 3, 4, 5); $newArray = array_map(&#39;addOne&#39;, $array);  如果这个命名函数是一个类的方法，在使用的时候需要保护类的一个对象：
class Example { public function addOne($item) { return $item + 1; } public function doCalculation() { $array = array(1, 2, 3, 4, 5); $newArray = array_map(array($this, &#39;addOne&#39;), $array); } }  另外的对数组每个元素使用方法的函数是array_walk()和array_walk_recursive()。在这些函数中使用的调用函数解释数组每个元素的键/值作为参数。这两个函数不返回一个新的数组，而是函数执行成功与否的布尔值。例如：打印一个简单数组的每个元素：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</guid>
      <description>数组迭代 一次迭代多个数组 有时候两个数组由相同的长度，需要一起迭代处理：
$people = [&#39;Tim&#39;, &#39;Tony&#39;, &#39;Turanga&#39;]; $foods = [&#39;chicken&#39;, &#39;beef&#39;, &#39;slurm&#39;];  array_map可以简单的实现这个要求：
array_map(function($person, $food) { retrun &amp;quot;$person likes $food\n&amp;quot;; }, $people, $foods);  这将会输出：
Tim likes chicken Tony likes beef Turanga likes slurm  这可以通过索引来实现：
assert(count($people) === count($foods)); for ($i = 0; $i &amp;lt; count($people); $i++) { echo &amp;quot;$people[$i] likes $foods[$i]\n&amp;quot;; }  如果没有递增的索引值，需要使用array_values($array)[$i]来代替$array[$i]。
如果两个数组拥有相同的索引，可以使用foreach来处理其中的一个数组：
foreach ($people as $index =&amp;gt; $person) { $food = $foods[$index]; echo &amp;quot;$person likes $food\n&amp;quot;; }  不同的数组只有当它们的长度一样，并且拥有一样的key时，才可以这么处理。这意味着要么多个数组是数字递增的，要么它们是相同的key按照相同的顺序排列的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</link>
      <pubDate>Fri, 12 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</guid>
      <description>数组    参数 详情     Key key是数组唯一的标识和索引。可以是string和integer。因此有效的key包括foo 5 10 a2b   Value 对于每个key都有一个值和其对应（否知就是null，在访问是会出问题）。这个值没有严格限制的类型    一个数组就是存储任意个元素到单独一个值中的数据结构。PHP中的数组实际是一个有序的映射，其中映射是一种键值关联的结构。
数组初始化 一个数组可以是空的。
//空数组 $foo = array(); //从PHP5.4的简短格式 $foo = [];  一个数组可以初始化，并且有值：
//创建3个值的简单数组 $fruit = array(&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;); //5.4之后的简短格式 $fruit = [&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;];  一个数组可以带有自定义索引的值（这时数组叫关联数组）：
//简单关联数组 $fruit = array( &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ); //也可以在之后赋值 $fruit[&#39;first&#39;] = &#39;apples&#39;; //短格式 $fruit = [ &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ];  如果一个变量之前没有用过，PHP将自动创建。虽然方便了，但也让代码更加难读了：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</guid>
      <description>引用 引用赋值 这是引用使用的第一个阶段。实际你在引用赋值的时候，这里允许你两个变量拥有相同的值。
$foo = &amp;amp;$bar;  $foo和$bar是相等的。它们指向相同的地址，而不是不同的地址。
你也可以在array()语言结构中使用引用赋值。并不是严格的引用赋值：
$foo = &#39;hi&#39;; $bar = array(1, 2); $array = array(&amp;amp;$foo, &amp;amp;$bar[0]);   注意：数组里面的引用是非常危险的一种行为。使用右侧引用对左侧进行普通赋值不会将左边变为引用。但是数组中这样的赋值引用将会被保留。在函数中，数组作为值传递时也有这个问题。
 引用赋值不限制在变量和数组中。在函数和所有&amp;rdquo;引用传递的值&amp;rdquo;都可以。
function incrementArray(&amp;amp;$arr) { foreach ($arr as $$val) { $var++; } } function &amp;amp;getArray() { statice $arr = [1, 2, 3]; return $arr; } incremetnArray(getArray()); var_dump(getArray()); //[2,3,4]  赋值是上面函数定义的关键点。不能通过引用传递表达式，只能传递值/变量。
返回引用 偶尔会出现让你通过引用隐藏返回的情况。
 引用返回在函数定义的参数是引用变量的时候非常有用。不要用返回引用来提升性能。PHP引擎会自动处理这些问题。只有在您有有效的技术原因时才返回引用。
 查看返回引用的PHP文档。
有很多不同的方式可以返回引用，包括下面的例子：
function parent(&amp;amp;$var) { echo $var; $var = &amp;quot;updated&amp;quot;; } function &amp;amp;child() { static $a = &amp;quot;test&amp;quot;; return $a; } parent(child()); //返回test parent(child()); //返回updated  引用返回不仅限于函数引用。您还可以隐式调用函数：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</guid>
      <description>运算符 一个运算符就是处理一个或多个值(或表达式，编程术语)，然后产生一个新的值(把本身构造成表达式)的符号。
可以根据运算符操作的数量把它们进行分组。
空合并运算符?? 空合并运算符是PHP7新增加的运算符。如果第一个操作数设置了并不为null，就返回这个运算符。否则返回第二个运算符的值。
下面是一个例子：
$name = $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面这个例子是等价的：
if (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  也和下面等价：
$name = isset($_POST[&#39;name&#39;]) ? $_POST[&#39;name&#39;] : &#39;nobody&#39;;  这个操作符也可以连着使用，从左到右进行处理：
$name = $_GET[&#39;name&#39;] ?? $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面是等价的:
if (isset($_GET[&#39;name&#39;])) { $name = $_GET[&#39;name&#39;]; } elseif (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  注意在字符串中使用空合并运算符，不要忘了使用括号：
$firstName = &amp;quot;John&amp;quot;; $lastName = &amp;quot;Doe&amp;quot;; echo $firstName ?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</guid>
      <description>类型 类型比较符 两种类型的比较符：松散比较符==和严格比较符===。严格比较符要求比较符两端的变量的类型和值都要相同。
// Loose comparisons var_dump(1 == 1); // true var_dump(1 == &amp;quot;1&amp;quot;); // true var_dump(1 == true); // true var_dump(0 == false); // true // Strict comparisons var_dump(1 === 1); // true var_dump(1 === &amp;quot;1&amp;quot;); // false var_dump(1 === true); // false var_dump(0 === false); // false // Notable exception: NAN — it never is equal to anything var_dump(NAN == NAN); // false var_dump(NAN === NAN); // false  你也可以使用严格比较符的相对于的反比较符!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</guid>
      <description>代码注释 单行注释 单行注释使用//或#开头。当遇到的时候，所有符号右边的文本都被PHP解析器忽略。
// This is a comment # This is also a comment echo &amp;quot;Hello World!&amp;quot;; // This is also a comment, beginning where we see &amp;quot;//&amp;quot;  多行注释 多行注释可以用来注释大块的代码，使用/*做开始，*/做结尾。
/* This is a multi-line comment. It spans multiple lines. This is still part of the comment. */  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</guid>
      <description>魔术常量 __FUNCTION__和__METHOD__的不同 __FUNCTION__只返回函数的名称，__METHOD__返回带有类名的函数名称：
&amp;lt;?php class trick { public function doit() { echo __FUNCTION__; } public function doitagain() { echo __METHOD__; } } $obj = new trick(); $obj-&amp;gt;doit(); // Outputs: doit $obj-&amp;gt;doitagain(); // Outputs: trick::doitagain  __CLASS__、get_class和get_called_class的不同 __CLASS__和get_class没有参数情况下的结果一样，都是这两者定义所在的类的名称(调用这个常量或方法的地方)。
相反，get_class($this)和get_called_class()函数都会返回实际调用的类的名称。
&amp;lt;?php class Definition_Class { public function say(){ echo &#39;__CLASS__ value: &#39; . __CLASS__ . &amp;quot;\n&amp;quot;; echo &#39;get_called_class() value: &#39; . get_called_class() . &amp;quot;\n&amp;quot;; echo &#39;get_class($this) value: &#39; . get_class($this) . &amp;quot;\n&amp;quot;; echo &#39;get_class() value: &#39; .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</link>
      <pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</guid>
      <description>常量 定义常量 常量可以使用const语句或者define函数定义。惯例是使用全大写字母作为常量的名称。
明确值定义常量 const PI = 3.14; //float define(&amp;quot;EARTH_IS_FLAT&amp;quot;, false); //boolean const UNKNOWN = null; //null define(&amp;quot;APP_ENV&amp;quot;, &amp;quot;dev&amp;quot;); //string const MAX_SESSION_TIME = 60 * 60; //integer，标量表达式也是可以的 const APP_LANGUAGES = [&amp;quot;de&amp;quot;, &amp;quot;en&amp;quot;]; //数组 define(&amp;quot;BETTER_APP_LANGUAGES&amp;quot;, [&amp;quot;lu&amp;quot;, &amp;quot;de&amp;quot;]); //数组  用常量定义常量 如果你有一个常量，你可以用这个常量定义另外的常量。
cosnt TAU = PI * 2; define(&amp;quot;EARTH_IS_ROUND&amp;quot;, !EARTH_IS_FLAT); define(&amp;quot;MORE_UNKNOWN&amp;quot;, UNKNOWN); define(&amp;quot;APP_ENV_UPPERCASE&amp;quot;, strtoupper(APP_ENV)); //字符串操作也是可以的 //上面的示例(函数调用)不适合const语句 //cosnt TIME = time(); 出现致命错误，不是标量表达式 define(&amp;quot;MAX_SESSION_TIME_IN_MINUTES&amp;quot;, MAX_SESSION_TIME / 60); const APP_FUTURE_LANGUAGES = [-1 =&amp;gt; &#39;es&#39;] + APP_LANGUAGES; //数组操作 define(&amp;quot;APP_BETTER_FUTURE_LANGUAGES&amp;quot;, array_merge([&#39;fr&#39;], APP_BETTER_LANGUAGES));  保留常量 一些常量名称是被PHP保留的，不能被重新定义。下面的例子都是失败的：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</link>
      <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</guid>
      <description>输出变量的值 创建一个动态的、交互的PHP项目，输出变量和他们的值是有用的。PHP提供了多个变量值的输出方法。这里主要介绍标准的输出方法和这些方法的使用场景。
echo和print echo和print是语言结构，不是函数。这意味着它们不想函数那样需要括号在参数的周围(当然也可以在参数的周围添加括号，这样也没有什么问题)。这将会输出变量、常量和表达式的字符串格式。不能用来输出数组和对象。
 把字符串joel赋值给变量$name
$name = &#39;joel&#39;;  使用echo和print来输出$name的值
echo $name; #&amp;gt; Joel print $name; #&amp;gt; Joel  括号不是要求的，但是可以使用
echo($name); #&amp;gt; Joel print($name); #&amp;gt; Joel  使用多个参数(只有echo支持)
echo $name, &amp;quot;Smith&amp;quot;; #&amp;gt; JoelSmith echo($name, &amp;quot; &amp;quot;, &amp;quot;Smith&amp;quot;); #&amp;gt; Joel Smith  print不像echo，是一个返回值为1的表达式，可以被用在更多的地方
print(&amp;quot;hey&amp;quot;) &amp;amp;&amp;amp; print(&amp;quot; &amp;quot;) &amp;amp;&amp;amp; print(&amp;quot;you&amp;quot;); #&amp;gt; you11  下面和上面是相等的
print (&amp;quot;hey&amp;quot; &amp;amp;&amp;amp; (print (&amp;quot; &amp;quot; &amp;amp;&amp;amp; print &amp;quot;you&amp;quot;))); #&amp;gt; you11   echo的简短写法 在outside of PHP tags，echo的简短写法是有效的。使用&amp;lt;?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</guid>
      <description>超全局变量 超全局变量是内建的在任何地方都一直有效的变量。
一些预定义的PHP变量叫做&amp;rdquo;超全局变量&amp;rdquo;，这意味着这些变量在一个脚本的任何作用域都是有效的。不用在函数或方法内使用global $variable来访问这些变量。
超全局变量解释 简介 简单来说，这些变量就是在你的脚本中全部作用域有效的变量。
这意味着没有必要把它们作为参数传递给你的函数，或者为了让不同的作用域访问这些变量把他们存放在块作用域之外。
什么是超全局变量？ 如果你认为它们就像超级英雄一样-它们不是的。
在PHP 7.1.3之后，有9个超全局变量，下面是它们的列表：
 $GLOBALS：包含所有的全局变量 $_SERVER：服务器和执行环境的信息 $_GET：HTTP GET的变量 $_POST：HTTP POST的变量 $_FILES：HTTP文件上传变量 $_COOKIE：HTTP的Cookie $_SESSION：Session变量 $_REQUEST：HTTP的请求变量 $_ENV：环境变量  查看文档。
更多信息 这里是它的参考资料。
是时候解释这些超全局变量了。
$GLOBALS  一个定义了当前脚本定义的所有全局作用域的变量的关联数组。变量名就是这个数组的键。
 代码：
$myGlobal = &amp;quot;global&amp;quot;; function test() { $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&#39;myGlobal&#39;]); } test(); var_dump($myLocal); var_dump($myGlobal);  输出：
string &#39;local&#39; (length=5) string &#39;global&#39; (length=6) null string &#39;global&#39; (length=6)  在上面的例子中$myLocal第二次没有显示因为这个变量定义在函数test()内部，当函数关闭之后这个变量就销毁了。
变为全局 实现这个有两种方法。
第一种方法：global关键字
function test() { global $myLocal; $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&amp;quot;myGloabl&amp;quot;]); }  这个关键字global放到变量前面，强制这个变量变为全局作用域变量。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</guid>
      <description>变量作用域 变量作用域表示变量可以被访问到的代码范围。这也经常被称为可见性。PHP的块作用域是函数，类定义的。一个全局作用域变量在整个应用都是有效的。
超全局变量 超全局变量是PHP定义的，可以在任何地方使用而不需要使用global关键字。
&amp;lt;?php function getPostValue($key, $default = NULL) { // $_POST is a superglobal and can be used without // having to specify &#39;global $_POST;&#39; if (isset($_POST[$key])) { return $_POST[$key]; } return $default; } // retrieves $_POST[&#39;username&#39;] echo getPostValue(&#39;username&#39;); // retrieves $_POST[&#39;email&#39;] and defaults to empty string echo getPostValue(&#39;email&#39;, &#39;&#39;);  静态属性和变量 定义为public的静态类属性和全局变量的功能类似。在任何类定义的地方都可以访问他们。
class SomeClass { public static int $counter = 0; } // The static $counter variable can be read/written from anywhere // and doesn&#39;t require an instantiation of the class SomeClass::$counter += 1;  可以在函数内部定义静态变量。这些静态变量可以在多次调用之间保持存在，这个定义在函数中的普通变量不同。这可以非常简单的实现单例模式。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</guid>
      <description>变量 变量的变量 可以通过动态的变量名字访问变量。任务允许被动态访问的变量的名字都可以放到另一个变量内。这样的变量就叫做变量的变量。
想要把一个变量放到另一个变量里面，可以在变量的前面添加一个额外的$符。
$variableName = &#39;foo&#39;; $foo = &#39;bar&#39;; //下面这些都是等价的，都会输出bar echo $foo; echo ${$variableName}; echo $$variableName; //下面相似的 $variableName = &#39;foo&#39;; $$variableName = &#39;bar&#39;; //下面的语句也会输出bar echo $foo; echo ${$variableName}; echo $$variableName;  变量的变量对于映射函数/方法非常有用。
function add($a, $b) { return $a + $b; } $funcName = &#39;add&#39;; echo $funcName(1, 2); // outputs 3  这在PHP的类里面是特别有用的：
class myClass { public function __construct() { $functionName = &#39;doSomething&#39;; $this-&amp;gt;$functionName(&#39;Hello World&#39;); } private function doSomething($string) { echo $string; // Outputs &amp;quot;Hello World&amp;quot; } }  可以单并不要求把变量$variableName放到{}里面：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</guid>
      <description>开始使用PHP PHP 7.x
   版本 支持截止时间 发版时间     7.1 2019-12-01 2016-12-01   7.0 2018-12-03 2015-12-03    PHP 5.x
   版本 支持截止时间 发版时间     5.6 2018-12-31 2014-08-28   5.5 2016-07-21 2013-06-20   5.4 2015-09-03 2012-03-01   5.3 2014-08-14 2009-06-30   5.2 2011-01-06 2006-11-02   5.1 2006-08-24 2005-11-24   5.0 2005-09-05 2004-07-13    PHP 4.</description>
    </item>
    
  </channel>
</rss>