<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/tags/php/</link>
    <description>Recent content in Php on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 19 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/tags/php/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PHP专业笔记（十九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-19.html</guid>
      <description>控制结构 if else if语句允许当满足条件时，执行一段代码。当你想条件不满足时执行另外的代码可以使用if else。
if ($a &amp;gt; $b) { echo &amp;quot;a is greater than b&amp;quot;; } else { echo &amp;quot;a is not greater than b&amp;quot;; }  查看PHP手册。
三元运算符是if-else的短语法 三元预算符根据条件是true还是false来执行一些条件。这是一个比较预算符，通常用来将if-else语句变成简单的格式。这允许快速测试一个条件，然后通常用来替换多行的if语句，让你的代码更加紧凑。
下面就是一个三元运算符的例子，这里$a=1,$b=2:
echo ($a &amp;gt; $b) ? &amp;quot;a is greated than b&amp;quot; : &amp;quot;a is not greater than b&amp;quot;;  输出：a is not greater than b
控制结构备用语法 PHP提供了控制结构备用的语法：if while for foreach switch。
和普通的语法相比，不同的地方在于：这里使用:来代替开始花括号，使用endif; endwhile; endfor; endforeach; endswitch;来代替结束花括号。有关各个示例，请参阅有关控制结构的备用语法的主题。
if ($a == 42): echo &amp;quot;The answer to life, the universe and everything is 42.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-18.html</guid>
      <description>操作日期和时间 获取两个时间的差 最可行的方法是使用DateTime类。例如：
&amp;lt;?php //创建一个指定时间的对象 2年前 $twoYearAgo = new DateTime(&#39;2017-04-29 22:00:00&#39;); //创建一个当前时间的对象 $now = new DateTime(&#39;2019-04-29 22:00:00&#39;) //计算差 $diff = $now-&amp;gt;diff($twoYearAgo); //获取diff结果中的数据 $yearsDiff = $diff-&amp;gt;y; $monthsDiff = $diff-&amp;gt;m; $daysDiff = $diff-&amp;gt;d; $hoursDiff = $diff-&amp;gt;h; $minsDiff = $diff-&amp;gt;i; $secondsDiff = $diff-&amp;gt;s; //差别的天数 $totalDaysDiff = $diff-&amp;gt;days; var_dump($diff);  另外比较两个日期也是很简单的，直接使用比较运算符：
&amp;lt;?php // Create a date time object, which has the value of ~ two years ago $twoYearsAgo = new DateTime(&amp;quot;2014-01-18 20:05:56&amp;quot;); // Create a date time object, which has the value of ~ now $now = new DateTime(&amp;quot;2016-07-21 02:55:07&amp;quot;); var_dump($now &amp;gt; $twoYearsAgo); // prints bool(true) var_dump($twoYearsAgo &amp;gt; $now); // prints bool(false) var_dump($twoYearsAgo &amp;lt;= $twoYearsAgo); // prints bool(true) var_dump($now == $now); // prints bool(true)  转换日期格式 基本 最简单的转换日期的格式是联合使用strtotime和date。strtotime函数会把一个字符串时间转换为一个Unix时间戳。这个Unix的时间戳可以使用函数date转换为一个新的格式：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-17.html</guid>
      <description>Datetime类 可变到不可变 从PHP5.6之前的可变版本到现在的不可变版本。
在PHP5.6之后创建一个\DateTimeImmutable类：
\DateTimeImmutable::createFromMutable($concrete);  在PHP5.6之前：
\DateTimeImmutable::createFromFormat(\DateTime::ISO8601, $mutable-&amp;gt;format(\DateTime::ISO8601), $mutable-&amp;gt;getTimezone());  加减日期间隔 我们可以使用DateInterval在DateTime对象上增加或减少一定时间间隔。
下面的例子，我们在对象上增加7天，然后打印输出到屏幕上面：
$now = new DateTime();// empty argument returns the current date $interval = new DateInterval(&#39;P7D&#39;);//this objet represents a 7 days interval $lastDay = $now-&amp;gt;add($interval); //this will return a DateTime object $formatedLastDay = $lastDay-&amp;gt;format(&#39;Y-m-d&#39;);//this method format the DateTime object and returns a String echo &amp;quot;Samara says: Seven Days. You&#39;ll be happy on $formatedLastDay.&amp;quot;;  这将会输出(在2019-04-29时运行)：
  Samara says: Seven Days.</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-16.html</guid>
      <description>一次处理多个数组 数组交集 array_intersect将会将所有数组中共有的值放入一个数组中。
$array_one = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]; $array_two = [&#39;two&#39;, &#39;three&#39;, &#39;four&#39;]; $array_three = [&#39;two&#39;, &#39;three&#39;]; $intersect = array_intersect($array_one, $array_two, $array_three); // $intersect contains [&#39;two&#39;, &#39;three&#39;]  第一个数组的key将会被保留，数字索引不会。
array_intersect只会检查数组的值，array_intersect_assoc将会对key也进行比较：
$array_one = [1 =&amp;gt; &#39;one&#39;,2 =&amp;gt; &#39;two&#39;,3 =&amp;gt; &#39;three&#39;]; $array_two = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;, 3 =&amp;gt; &#39;two&#39;, 4 =&amp;gt; &#39;three&#39;]; $array_three = [1 =&amp;gt; &#39;one&#39;, 2 =&amp;gt; &#39;two&#39;]; $intersect = array_intersect_assoc($array_one, $array_two, $array_three); // $intersect contains [1 =&amp;gt;&#39;one&#39;,2 =&amp;gt; &#39;two&#39;]  array_intersect_key将会检查数组的key，将会返回数组中都存在的key：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-15.html</guid>
      <description>操作数组 筛选数组 从数组中筛选值，并且把按照筛选条件找出的值放入一个新数组中，可以使用array_filter函数。
筛选非空数组 一个简单例子来筛选非空的值：
$myArray = [1, 0, 2, null, 3, &#39;&#39;, 4, [], 5, 6, 7, 8]; $nonEmpties = array_filter($myArray); //[1, 2, 3, 4, 5, 6, 7, 8];  使用回调筛选 我们可以定义我们自己的筛选规则。这里假设我们想要偶数值：
$myArray = [1, 2, 3, 4, 5, 6, 7, 8]; $evenNumbers = array_filter($myArray, function($number) { return $number % 2 === 0; })  array_filter的第一个参数是等待筛选的数组，第二个参数是定义筛选规则的回调函数。
按索引筛选 Version &amp;gt;= 5.6
array_filter的第三个参数是用来决定哪个值传递给回调函数。这个参数有两个选项：ARRAY_FILTER_USE_KEY 或 ARRAY_FILTER_USE_BOTH。这决定回调函数的参数是数组的key还是key和值都有。例如，你想要使用索引而不是值：
$numbers = [16,3,5,8,1,4,6]; $even_indexed_numbers = array_filter($numbers, function($index) { return $index % 2 === 0; }, ARRAY_FILTER_USE_KEY);  筛选结果数组的索引 注意：array_filter函数会保留原本数组的key。一个常见的错误是使用for循环处理筛选后的数组：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</link>
      <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-14.html</guid>
      <description>对数组操作 对数组每个元素进行函数处理 对数组每一个元素进行函数的处理，使用array_map函数。这将会返回一个新的数组。
$array = array(1,2,3,4,5); //each array item is iterated over and gets stored in the function parameter. $newArray = array_map(function($item) { return $item + 1; }, $array);  返回的新数组$newArray的值是array(2,3,4,5,6)。
除了使用匿名函数外，还可以使用一个命名的函数。上面的例子也可以写成下面这样：
function addOne($item) { return $item + 1; } $array = array(1, 2, 3, 4, 5); $newArray = array_map(&#39;addOne&#39;, $array);  如果这个命名函数是一个类的方法，在使用的时候需要保护类的一个对象：
class Example { public function addOne($item) { return $item + 1; } public function doCalculation() { $array = array(1, 2, 3, 4, 5); $newArray = array_map(array($this, &#39;addOne&#39;), $array); } }  另外的对数组每个元素使用方法的函数是array_walk()和array_walk_recursive()。在这些函数中使用的调用函数解释数组每个元素的键/值作为参数。这两个函数不返回一个新的数组，而是函数执行成功与否的布尔值。例如：打印一个简单数组的每个元素：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-13.html</guid>
      <description>数组迭代 一次迭代多个数组 有时候两个数组由相同的长度，需要一起迭代处理：
$people = [&#39;Tim&#39;, &#39;Tony&#39;, &#39;Turanga&#39;]; $foods = [&#39;chicken&#39;, &#39;beef&#39;, &#39;slurm&#39;];  array_map可以简单的实现这个要求：
array_map(function($person, $food) { retrun &amp;quot;$person likes $food\n&amp;quot;; }, $people, $foods);  这将会输出：
Tim likes chicken Tony likes beef Turanga likes slurm  这可以通过索引来实现：
assert(count($people) === count($foods)); for ($i = 0; $i &amp;lt; count($people); $i++) { echo &amp;quot;$people[$i] likes $foods[$i]\n&amp;quot;; }  如果没有递增的索引值，需要使用array_values($array)[$i]来代替$array[$i]。
如果两个数组拥有相同的索引，可以使用foreach来处理其中的一个数组：
foreach ($people as $index =&amp;gt; $person) { $food = $foods[$index]; echo &amp;quot;$person likes $food\n&amp;quot;; }  不同的数组只有当它们的长度一样，并且拥有一样的key时，才可以这么处理。这意味着要么多个数组是数字递增的，要么它们是相同的key按照相同的顺序排列的。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</link>
      <pubDate>Fri, 12 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-12.html</guid>
      <description>数组    参数 详情     Key key是数组唯一的标识和索引。可以是string和integer。因此有效的key包括foo 5 10 a2b   Value 对于每个key都有一个值和其对应（否知就是null，在访问是会出问题）。这个值没有严格限制的类型    一个数组就是存储任意个元素到单独一个值中的数据结构。PHP中的数组实际是一个有序的映射，其中映射是一种键值关联的结构。
数组初始化 一个数组可以是空的。
//空数组 $foo = array(); //从PHP5.4的简短格式 $foo = [];  一个数组可以初始化，并且有值：
//创建3个值的简单数组 $fruit = array(&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;); //5.4之后的简短格式 $fruit = [&#39;apples&#39;, &#39;pears&#39;, &#39;oranges&#39;];  一个数组可以带有自定义索引的值（这时数组叫关联数组）：
//简单关联数组 $fruit = array( &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ); //也可以在之后赋值 $fruit[&#39;first&#39;] = &#39;apples&#39;; //短格式 $fruit = [ &#39;first&#39; =&amp;gt; &#39;apples&#39;, &#39;second&#39; =&amp;gt; &#39;pears&#39;, &#39;third&#39; =&amp;gt; &#39;oranges&#39; ];  如果一个变量之前没有用过，PHP将自动创建。虽然方便了，但也让代码更加难读了：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</link>
      <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-11.html</guid>
      <description>引用 引用赋值 这是引用使用的第一个阶段。实际你在引用赋值的时候，这里允许你两个变量拥有相同的值。
$foo = &amp;amp;$bar;  $foo和$bar是相等的。它们指向相同的地址，而不是不同的地址。
你也可以在array()语言结构中使用引用赋值。并不是严格的引用赋值：
$foo = &#39;hi&#39;; $bar = array(1, 2); $array = array(&amp;amp;$foo, &amp;amp;$bar[0]);   注意：数组里面的引用是非常危险的一种行为。使用右侧引用对左侧进行普通赋值不会将左边变为引用。但是数组中这样的赋值引用将会被保留。在函数中，数组作为值传递时也有这个问题。
 引用赋值不限制在变量和数组中。在函数和所有&amp;rdquo;引用传递的值&amp;rdquo;都可以。
function incrementArray(&amp;amp;$arr) { foreach ($arr as $$val) { $var++; } } function &amp;amp;getArray() { statice $arr = [1, 2, 3]; return $arr; } incremetnArray(getArray()); var_dump(getArray()); //[2,3,4]  赋值是上面函数定义的关键点。不能通过引用传递表达式，只能传递值/变量。
返回引用 偶尔会出现让你通过引用隐藏返回的情况。
 引用返回在函数定义的参数是引用变量的时候非常有用。不要用返回引用来提升性能。PHP引擎会自动处理这些问题。只有在您有有效的技术原因时才返回引用。
 查看返回引用的PHP文档。
有很多不同的方式可以返回引用，包括下面的例子：
function parent(&amp;amp;$var) { echo $var; $var = &amp;quot;updated&amp;quot;; } function &amp;amp;child() { static $a = &amp;quot;test&amp;quot;; return $a; } parent(child()); //返回test parent(child()); //返回updated  引用返回不仅限于函数引用。您还可以隐式调用函数：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（十）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-10.html</guid>
      <description>运算符 一个运算符就是处理一个或多个值(或表达式，编程术语)，然后产生一个新的值(把本身构造成表达式)的符号。
可以根据运算符操作的数量把它们进行分组。
空合并运算符?? 空合并运算符是PHP7新增加的运算符。如果第一个操作数设置了并不为null，就返回这个运算符。否则返回第二个运算符的值。
下面是一个例子：
$name = $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面这个例子是等价的：
if (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  也和下面等价：
$name = isset($_POST[&#39;name&#39;]) ? $_POST[&#39;name&#39;] : &#39;nobody&#39;;  这个操作符也可以连着使用，从左到右进行处理：
$name = $_GET[&#39;name&#39;] ?? $_POST[&#39;name&#39;] ?? &#39;nobody&#39;;  这和下面是等价的:
if (isset($_GET[&#39;name&#39;])) { $name = $_GET[&#39;name&#39;]; } elseif (isset($_POST[&#39;name&#39;])) { $name = $_POST[&#39;name&#39;]; } else { $name = &#39;nobody&#39;; }  注意在字符串中使用空合并运算符，不要忘了使用括号：
$firstName = &amp;quot;John&amp;quot;; $lastName = &amp;quot;Doe&amp;quot;; echo $firstName ?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（九）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-9.html</guid>
      <description>类型 类型比较符 两种类型的比较符：松散比较符==和严格比较符===。严格比较符要求比较符两端的变量的类型和值都要相同。
// Loose comparisons var_dump(1 == 1); // true var_dump(1 == &amp;quot;1&amp;quot;); // true var_dump(1 == true); // true var_dump(0 == false); // true // Strict comparisons var_dump(1 === 1); // true var_dump(1 === &amp;quot;1&amp;quot;); // false var_dump(1 === true); // false var_dump(0 === false); // false // Notable exception: NAN — it never is equal to anything var_dump(NAN == NAN); // false var_dump(NAN === NAN); // false  你也可以使用严格比较符的相对于的反比较符!</description>
    </item>
    
    <item>
      <title>PHP专业笔记（八）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-8.html</guid>
      <description>代码注释 单行注释 单行注释使用//或#开头。当遇到的时候，所有符号右边的文本都被PHP解析器忽略。
// This is a comment # This is also a comment echo &amp;quot;Hello World!&amp;quot;; // This is also a comment, beginning where we see &amp;quot;//&amp;quot;  多行注释 多行注释可以用来注释大块的代码，使用/*做开始，*/做结尾。
/* This is a multi-line comment. It spans multiple lines. This is still part of the comment. */  参考：PHP® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>PHP专业笔记（七）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-7.html</guid>
      <description>魔术常量 __FUNCTION__和__METHOD__的不同 __FUNCTION__只返回函数的名称，__METHOD__返回带有类名的函数名称：
&amp;lt;?php class trick { public function doit() { echo __FUNCTION__; } public function doitagain() { echo __METHOD__; } } $obj = new trick(); $obj-&amp;gt;doit(); // Outputs: doit $obj-&amp;gt;doitagain(); // Outputs: trick::doitagain  __CLASS__、get_class和get_called_class的不同 __CLASS__和get_class没有参数情况下的结果一样，都是这两者定义所在的类的名称(调用这个常量或方法的地方)。
相反，get_class($this)和get_called_class()函数都会返回实际调用的类的名称。
&amp;lt;?php class Definition_Class { public function say(){ echo &#39;__CLASS__ value: &#39; . __CLASS__ . &amp;quot;\n&amp;quot;; echo &#39;get_called_class() value: &#39; . get_called_class() . &amp;quot;\n&amp;quot;; echo &#39;get_class($this) value: &#39; . get_class($this) . &amp;quot;\n&amp;quot;; echo &#39;get_class() value: &#39; .</description>
    </item>
    
    <item>
      <title>PHP专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</link>
      <pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-6.html</guid>
      <description>常量 定义常量 常量可以使用const语句或者define函数定义。惯例是使用全大写字母作为常量的名称。
明确值定义常量 const PI = 3.14; //float define(&amp;quot;EARTH_IS_FLAT&amp;quot;, false); //boolean const UNKNOWN = null; //null define(&amp;quot;APP_ENV&amp;quot;, &amp;quot;dev&amp;quot;); //string const MAX_SESSION_TIME = 60 * 60; //integer，标量表达式也是可以的 const APP_LANGUAGES = [&amp;quot;de&amp;quot;, &amp;quot;en&amp;quot;]; //数组 define(&amp;quot;BETTER_APP_LANGUAGES&amp;quot;, [&amp;quot;lu&amp;quot;, &amp;quot;de&amp;quot;]); //数组  用常量定义常量 如果你有一个常量，你可以用这个常量定义另外的常量。
cosnt TAU = PI * 2; define(&amp;quot;EARTH_IS_ROUND&amp;quot;, !EARTH_IS_FLAT); define(&amp;quot;MORE_UNKNOWN&amp;quot;, UNKNOWN); define(&amp;quot;APP_ENV_UPPERCASE&amp;quot;, strtoupper(APP_ENV)); //字符串操作也是可以的 //上面的示例(函数调用)不适合const语句 //cosnt TIME = time(); 出现致命错误，不是标量表达式 define(&amp;quot;MAX_SESSION_TIME_IN_MINUTES&amp;quot;, MAX_SESSION_TIME / 60); const APP_FUTURE_LANGUAGES = [-1 =&amp;gt; &#39;es&#39;] + APP_LANGUAGES; //数组操作 define(&amp;quot;APP_BETTER_FUTURE_LANGUAGES&amp;quot;, array_merge([&#39;fr&#39;], APP_BETTER_LANGUAGES));  保留常量 一些常量名称是被PHP保留的，不能被重新定义。下面的例子都是失败的：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</link>
      <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-5.html</guid>
      <description>输出变量的值 创建一个动态的、交互的PHP项目，输出变量和他们的值是有用的。PHP提供了多个变量值的输出方法。这里主要介绍标准的输出方法和这些方法的使用场景。
echo和print echo和print是语言结构，不是函数。这意味着它们不想函数那样需要括号在参数的周围(当然也可以在参数的周围添加括号，这样也没有什么问题)。这将会输出变量、常量和表达式的字符串格式。不能用来输出数组和对象。
 把字符串joel赋值给变量$name   $name = &#39;joel&#39;;   使用echo和print来输出$name的值   echo $name; #&amp;gt; Joel print $name; #&amp;gt; Joel   括号不是要求的，但是可以使用   echo($name); #&amp;gt; Joel print($name); #&amp;gt; Joel   使用多个参数(只有echo支持)   echo $name, &amp;quot;Smith&amp;quot;; #&amp;gt; JoelSmith echo($name, &amp;quot; &amp;quot;, &amp;quot;Smith&amp;quot;); #&amp;gt; Joel Smith   print不像echo，是一个返回值为1的表达式，可以被用在更多的地方   print(&amp;quot;hey&amp;quot;) &amp;amp;&amp;amp; print(&amp;quot; &amp;quot;) &amp;amp;&amp;amp; print(&amp;quot;you&amp;quot;); #&amp;gt; you11   下面和上面是相等的   print (&amp;quot;hey&amp;quot; &amp;amp;&amp;amp; (print (&amp;quot; &amp;quot; &amp;amp;&amp;amp; print &amp;quot;you&amp;quot;))); #&amp;gt; you11  echo的简短写法 在outside of PHP tags，echo的简短写法是有效的。使用&amp;lt;?</description>
    </item>
    
    <item>
      <title>PHP专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-4.html</guid>
      <description>超全局变量 超全局变量是内建的在任何地方都一直有效的变量。
一些预定义的PHP变量叫做&amp;rdquo;超全局变量&amp;rdquo;，这意味着这些变量在一个脚本的任何作用域都是有效的。不用在函数或方法内使用global $variable来访问这些变量。
超全局变量解释 简介 简单来说，这些变量就是在你的脚本中全部作用域有效的变量。
这意味着没有必要把它们作为参数传递给你的函数，或者为了让不同的作用域访问这些变量把他们存放在块作用域之外。
什么是超全局变量？ 如果你认为它们就像超级英雄一样-它们不是的。
在PHP 7.1.3之后，有9个超全局变量，下面是它们的列表：
 $GLOBALS：包含所有的全局变量 $_SERVER：服务器和执行环境的信息 $_GET：HTTP GET的变量 $_POST：HTTP POST的变量 $_FILES：HTTP文件上传变量 $_COOKIE：HTTP的Cookie $_SESSION：Session变量 $_REQUEST：HTTP的请求变量 $_ENV：环境变量  查看文档。
更多信息 这里是它的参考资料。
是时候解释这些超全局变量了。
$GLOBALS  一个定义了当前脚本定义的所有全局作用域的变量的关联数组。变量名就是这个数组的键。
 代码：
$myGlobal = &amp;quot;global&amp;quot;; function test() { $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&#39;myGlobal&#39;]); } test(); var_dump($myLocal); var_dump($myGlobal);  输出：
string &#39;local&#39; (length=5) string &#39;global&#39; (length=6) null string &#39;global&#39; (length=6)  在上面的例子中$myLocal第二次没有显示因为这个变量定义在函数test()内部，当函数关闭之后这个变量就销毁了。
变为全局 实现这个有两种方法。
第一种方法：global关键字
function test() { global $myLocal; $myLocal = &amp;quot;local&amp;quot;; var_dump($myLocal); var_dump($GLOBALS[&amp;quot;myGloabl&amp;quot;]); }  这个关键字global放到变量前面，强制这个变量变为全局作用域变量。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-3.html</guid>
      <description>变量作用域 变量作用域表示变量可以被访问到的代码范围。这也经常被称为可见性。PHP的块作用域是函数，类定义的。一个全局作用域变量在整个应用都是有效的。
超全局变量 超全局变量是PHP定义的，可以在任何地方使用而不需要使用global关键字。
&amp;lt;?php function getPostValue($key, $default = NULL) { // $_POST is a superglobal and can be used without // having to specify &#39;global $_POST;&#39; if (isset($_POST[$key])) { return $_POST[$key]; } return $default; } // retrieves $_POST[&#39;username&#39;] echo getPostValue(&#39;username&#39;); // retrieves $_POST[&#39;email&#39;] and defaults to empty string echo getPostValue(&#39;email&#39;, &#39;&#39;);  静态属性和变量 定义为public的静态类属性和全局变量的功能类似。在任何类定义的地方都可以访问他们。
class SomeClass { public static int $counter = 0; } // The static $counter variable can be read/written from anywhere // and doesn&#39;t require an instantiation of the class SomeClass::$counter += 1;  可以在函数内部定义静态变量。这些静态变量可以在多次调用之间保持存在，这个定义在函数中的普通变量不同。这可以非常简单的实现单例模式。</description>
    </item>
    
    <item>
      <title>PHP专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-2.html</guid>
      <description>变量 变量的变量 可以通过动态的变量名字访问变量。任务允许被动态访问的变量的名字都可以放到另一个变量内。这样的变量就叫做变量的变量。
想要把一个变量放到另一个变量里面，可以在变量的前面添加一个额外的$符。
$variableName = &#39;foo&#39;; $foo = &#39;bar&#39;; //下面这些都是等价的，都会输出bar echo $foo; echo ${$variableName}; echo $$variableName; //下面相似的 $variableName = &#39;foo&#39;; $$variableName = &#39;bar&#39;; //下面的语句也会输出bar echo $foo; echo ${$variableName}; echo $$variableName;  变量的变量对于映射函数/方法非常有用。
function add($a, $b) { return $a + $b; } $funcName = &#39;add&#39;; echo $funcName(1, 2); // outputs 3  这在PHP的类里面是特别有用的：
class myClass { public function __construct() { $functionName = &#39;doSomething&#39;; $this-&amp;gt;$functionName(&#39;Hello World&#39;); } private function doSomething($string) { echo $string; // Outputs &amp;quot;Hello World&amp;quot; } }  可以单并不要求把变量$variableName放到{}里面：</description>
    </item>
    
    <item>
      <title>PHP专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/php-section-1.html</guid>
      <description>开始使用PHP PHP 7.x
   版本 支持截止时间 发版时间     7.1 2019-12-01 2016-12-01   7.0 2018-12-03 2015-12-03    PHP 5.x
   版本 支持截止时间 发版时间     5.6 2018-12-31 2014-08-28   5.5 2016-07-21 2013-06-20   5.4 2015-09-03 2012-03-01   5.3 2014-08-14 2009-06-30   5.2 2011-01-06 2006-11-02   5.1 2006-08-24 2005-11-24   5.0 2005-09-05 2004-07-13    PHP 4.</description>
    </item>
    
  </channel>
</rss>