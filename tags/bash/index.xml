<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/tags/bash/</link>
    <description>Recent content in Bash on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 03 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bash专业笔记(六十六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-66.html</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-66.html</guid>
      <description>陷阱 赋值时空格 赋值时出现空格：
foo = &#39;bar&#39; # incorrect foo= &#39;bar&#39; # incorrect foo=&#39;bar&#39; # correct  前两个会出现语法错误(或者执行一个错误的命令)。最后一个会正确的为变量foo设置值bar。
失败的命令不停止脚本执行 在大多数的脚本语言中，如果一个函数错了，将会抛出一个异常并且终止程序的执行。Bash没有异常，但是有退出码。一个非零的退出码代表出现了错误，但是这并不会终止程序的执行。
这可能会导致危险（尽管诚然是人为的）情况，如：
#!/bin/bash cd ~/non/existent/directory rm -rf *  如果cd命令失败了，Bash会忽略失败，并且继续执行下面的命令。将会清除你运行命令文件夹的所有文件。
最好的方法是使用set命令：
#!/bin/bash set -e cd ~/non/existent/directory rm -rf *  set -e告诉Bash如果遇到一个非零的返回值，直接终端执行。
缺少文件中的最后一行 C标准规定文件要以新行结束，所以如果EOF出现在行尾，那么某些命令可能不会遗漏这行。例如：
$ echo &#39;one\ntwo\nthree\c&#39; &amp;gt; file.txt $ cat file.txt one two three $ while read line ; do echo &amp;quot;line $line&amp;quot; ; done &amp;lt; file.txt one two  想要修复这个问题的话，就测试最后一行是否为空，不为空继续执行：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-65.html</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-65.html</guid>
      <description>设计模式 在bash中完成一些常见的设计模式。
发布订阅模式 当项目变为一个库时，添加新功能会变得很困难。函数名、变量和参数通常需要在使用它们的脚本中进行更改。在这样的场景中，分离代码并使用事件驱动的设计模式是很有帮助的。在所述模式中，外部脚本可以订阅事件。当触发（发布）该事件时，脚本可以执行它在该事件中注册的代码。
pubsub.sh #!/usr/bin/env bash # # Save the path to this script&#39;s directory in a global env variable # DIR=&amp;quot;$( cd &amp;quot;$( dirname &amp;quot;${BASH_SOURCE[0]}&amp;quot; )&amp;quot; &amp;amp;&amp;amp; pwd )&amp;quot; # # Array that will contain all registered events # EVENTS=() function action1() { echo &amp;quot;Action #1 was performed ${2}&amp;quot; } function action2() { echo &amp;quot;Action #2 was performed&amp;quot; } # # @desc :: Registers an event # @param :: string $1 - The name of the event.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-64.html</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-64.html</guid>
      <description>解码URL 简单例子 编码URL
 http%3A%2F%2Fwww.foo.com%2Findex.php%3Fid%3Dqwerty
 使用命令解码URL
echo &amp;quot;http%3A%2F%2Fwww.foo.com%2Findex.php%3Fid%3Dqwerty&amp;quot; | sed -e &amp;quot;s/%\([0-9A-F][0-9A- F]\)/\\\\\x\1/g&amp;quot; | xargs -0 echo -e  输出：
 http://www.foo.com/index.php?id=qwerty
 使用printf解码字符串 #!bin/bash $ string=&#39;Question%20- %20%22how%20do%20I%20decode%20a%20percent%20encoded%20string%3F%22%0AAnswer%20%20%20- %20Use%20printf%20%3A)&#39; $ printf &#39;%b\n&#39; &amp;quot;${string//%/\\x}&amp;quot; # the result Question - &amp;quot;how do I decode a percent encoded string?&amp;quot; Answer - Use printf :)  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-63.html</link>
      <pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-63.html</guid>
      <description>Parallel    选项 详情     -j n 同时运行n个任务   -k 保持相同的顺序   -X 上下文替换的多个参数   —colsep regexp 在regexp上拆分输入以进行位置替换   {} {.} {/} {/.} {#} 替换字符串   {3} {3.} {3/} {3/.} 位置替换字符串   -S sshlogin 例如 foo@server.example.com   —trc {} .bar —transfer —return {}.bar —cleanup的简短格式   &amp;ndash;onall 在所有sshlogins上运行带有参数的给定命令   &amp;ndash;nonall 在所有sshlogins上运行没有带参数的给定命令   &amp;ndash;pipe 将stdin（标准输入）拆分为多个任务   —recend str 记录&amp;ndash;pipe的结束分隔符。   —recstart str 记录—pipe的开始分隔符。    GUN Linux上面的任务可以使用GNU parallel并行执行。一个任务可以是一个命令或需要运行输入每行的小脚本。特别的输入就是一列文件，一列host，一列用户，一列URL，一列表等。一个任务也可以是从管道中读取的命令。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十二)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-62.html</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-62.html</guid>
      <description>bash网络操作 Bash通常用于服务器和集群的管理和维护工作。与网络操作使用的典型命令有关的信息，何时使用哪个命令用于哪个目的，以及应包括其独特和/或有趣应用程序的示例/示例。
网络命令 ifconfig  上面的命令会显示机器所有活动的接口，提供下面的信息：
 接口的IP地址 接口的MAC地址 广播地址 发送和接收字节  一些例子：
ifconfig -a  上面的例子也会显示无效的接口。
ifconfig eth0  上面的命令将会只显示eth0接口。
ifconfig etho0 192.168.1.100 netmask 255.255.255.0  上面的命令将会把静态ip地址赋值给eth0接口。
ifup ehth0  上面的命令会开启eth0
ifdown eth0  上面的命令会禁止eth0接口
ping  上面的命令(Packet Internet Grouper)用于测试两个节点之间的链接。
ping -c2 8.8.8.8  上面的命令将ping或测试与谷歌服务器的连接2秒
traceroute  以上命令用于故障排除，以找出到达目的地所花费的跳数。
netstat  上面的命令将会获取连接信息和他们的状态
dig www.baidu.com  上面的命令(域信息分组器)查询DNS相关信息
nslookup www.baidu.com  上面的命令查询DNS信息，并找出网站名称对应的IP地址。
route  上面的命令用来检测网络路由信息。只是显示你的路由表。
router add default gw 192.168.1.1 eth0  上面的命令会将eth0接口的默认网络路由添加到路由表192.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十一)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-61.html</link>
      <pubDate>Fri, 29 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-61.html</guid>
      <description>eval命令 首先最重要的是：知道你正在做什么。第二，虽然你应该避免使用eval，但是它的使用让代码更加干净，那就继续使用。
使用eval 例如，考虑将$@的内容设置为给定变量的内容：
a=(1 2 3) eval set -- &amp;quot;${a[@]}&amp;quot;  这个代码通常伴随着getopt或getopts将$@设置为上述选项分析器的输出。但是你也可以用这个创建一个简单的pop函数，这个函数可以简单的直接操作变量，而不用将变量存储在原始变量中：
isnum() { # is argument an integer? local re=&#39;^[0-9]+$&#39; if [[ -n $1 ]]; then [[ $1 =~ $re ]] &amp;amp;&amp;amp; return 0 return 1 else return 2 fi } isvar() { if isnum &amp;quot;$1&amp;quot;; then return 1 fi local arr=&amp;quot;$(eval eval -- echo -n &amp;quot;\$$1&amp;quot;)&amp;quot; if [[ -n ${arr[@]} ]]; then	return 0 fi return 1 } pop() { if [[ -z $@ ]]; then return 1 fi local var= local isvar=0 local arr=() if isvar &amp;quot;$1&amp;quot;; then # let&#39;s check to see if this is a variable or just a bare array var=&amp;quot;$1&amp;quot; isvar=1 arr=($(eval eval -- echo -n &amp;quot;\${$1[@]}&amp;quot;)) # if it is a var, get its contents else arr=($@) fi # we need to reverse the contents of $@ so that we can shift # the last element into nothingness arr=($(awk &amp;lt;&amp;lt;&amp;lt;&amp;quot;${arr[@]}&amp;quot; &#39;{ for (i=NF; i&amp;gt;1; --i) printf(&amp;quot;%s &amp;quot;,$i); print $1; }&#39; # set $@ to ${arr[@]} so that we can run shift against it.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六十)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-60.html</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-60.html</guid>
      <description>select关键字 select关键字可以用来在菜单格式中获取输入参数。
获取参数 假设你想要用户选择菜单的关键字，你可以创建下面类似的脚本：
#! /usr/bin/env bash select os in &amp;quot;linux&amp;quot; &amp;quot;windows&amp;quot; &amp;quot;mac&amp;quot; do echo &amp;quot;{$os}&amp;quot; break done  解析：这里select关键字循环元素列表，在命令行的提示中显示这些元素，以供用户选择。注意break关键字将会中断循环，一旦用户做了选择。否则循环将不会结束。
结果：一旦开始运行脚本，菜单的选项将会显示，用户将被提示进行一个选择，一旦选择了，这个值将会显示，并且返回命令提示。
&amp;gt;bash select_menu.sh 1) linux 2) windows 3) mac #? 3 mac &amp;gt;  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十九)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-59.html</link>
      <pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-59.html</guid>
      <description>CGI脚本 请求方法：GET 使用GET请求一个CGI脚本是非常方便的。
首先你需要脚本的encoded url。然后你在变量后面添加?。
 每个变量有=分割的两个部分。第一部分是对每个变量唯一的值，第二部分是变量的值
 变量使用&amp;amp;分隔
 字符串的总长度不要超过255个字符
 变量的名称和值需要是html编码的(替换&amp;lt;/ /?:@&amp;amp;=+$)
  注意：当使用html表格时，请求方法可以自己产生。使用Ajax你可以使用encodeURI和encodeURIComponent来编码信息
例子：
http://www.example.com/cgi-bin/script.sh?var1=Hello%20World!&amp;amp;var2=This%20is%20a%20Test.&amp;amp;  服务器只能通过跨源资源共享(CORS)来进行请求，这样请求更加安全。在这个例子中，我们使用CORS来确定使用的数据类型。
有多中数据类型我们可以选择，通常是：
 text/html text/plain application/json  当发生一个请求，服务器会创建很多环境变量。现在最重要的环境变量是$REQUEST_METHOD和$QUERY_STRING
这里REQUEST_METHOD必须是GET。这个QUERY_STRING`包含所有html编码的数据。
#!/bin/bash # CORS is the way to communicate, so lets response to the server first echo &amp;quot;Content-type: text/html&amp;quot; # set the data-type we want to use echo &amp;quot;&amp;quot; # we don&#39;t need more rules, the empty line initiate this. # CORS are set in stone and any communication from now on will be like reading a html-document.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十八)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-58.html</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-58.html</guid>
      <description>全局和本地变量 默认的，你在脚本中声明的自己的变量，在每个方法，脚本甚至shell外部都是全局的。
如果你想要变量是方法本地的，在方法内部使用local关键字，这些值将只能在方法中访问。
全局变量 var=&amp;quot;hello&amp;quot; function foo(){ echo $var } foo  将会输出&amp;rdquo;hello&amp;rdquo;。这在另一种方式也是可以的：
function foo() { var=&amp;quot;hello&amp;quot; } foo echo $var  将也会输出&amp;rdquo;hello&amp;rdquo;
本地变量 function foo(){ local var var = &amp;quot;hello&amp;quot; } foo echo var  将什么都不会输出，var是方法内部的变量，在方法外部是不可见的。
混合使用 var=&amp;quot;hello&amp;quot; function foo() { local var=&amp;quot;sup?&amp;quot; echo &amp;quot;inside function, var=$var&amp;quot; } foo echo &amp;quot;outside function, var=$var&amp;quot;  将会输出：
inside function, var=sup? outside function, var=hello  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十七)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-57.html</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-57.html</guid>
      <description>cut命令    选项 详情     -b LIST, —bytes=LIST 打印LIST参数中的字节列表   -c LIST, —characters=LIST 打印参数LIST中指定位置的字符   -f LIST, —fields=LIST 打印字段或者列   -d DELIMITER 用来分割字段或列    在Bash，cut命令用来把文件分割到小的部分。
显示文件第一列 假设你有像下面的文件
John Smith 31 Robert Jones 27 ...  这个文件有空格分割的3列。值选择第一列使用下面的命令：
cut -d &#39; &#39; -f1 filename  这里-d标识指定了分隔符，或者什么分割了结果。f标识指定获取的列或自动的数。这将会输出下面的结果：
John Robert ...  显示文件x-y的列表 有时候，需要显示一个文件的指定范围的列。假设你有
Apple California 2017 1.00 47 Mango Oregon 2015 2.30 33  选择前3列表：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十六)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-56.html</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-56.html</guid>
      <description>Windows 10的bash readme 最简单的在Windows上使用Bash的方式是按照Windows版本的Git。这带有Git Bash，这是一个真正的Bash。你可以使用下面的顺序打开
Start &amp;gt; All Programs &amp;gt; Git &amp;gt; Git Bash
命令像grep ls find sed vi等等都是可以使用的
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十五)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-55.html</link>
      <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-55.html</guid>
      <description>cut命令    转义符 含义     -f, —fields 基于字段的选择   -d, —delimiter 基于字段选择的分隔符   -c, —characters 基于字符选择，分隔符忽略或者错误   -s, —only-delimited 禁止使用不带分隔符的行（按其他方式打印）   —complemment 反向选择（提取除指定字段/字符之外的所有字段/字符   —output-delimiter 指定它必须与输入分隔符不同的时间    cut命令是快速提前文本文件行的部分的方法。这是最老的Unix命令之一。它最流行的实现是Linux上的GUN版本，MacOS的FreeBSD版本。但是Unix的每种风格都有自己的特色。查看下面的不同。输入的行或者从标准输入读取，或者从命令行的参数列出的文件的读取。
只有一个分隔符 你不能拥有大于一个的的分隔符。如果你指定了像-d &amp;quot;,;:&amp;quot;，一些实现中只会使用第一个字符作为分隔符(这里，是逗号)。其他的一些实现(像GNU cut)会出现错误信息。
$ cut -d &amp;quot;,;:&amp;quot; -f2 &amp;lt;&amp;lt;&amp;lt;&amp;quot;J.Smith,1 Main Road,cell:1234567890;land:4081234567&amp;quot; cut: the delimiter must be a single character Try `cut --help&#39; for more information.  重复分隔符任务是空字符 $ cut -d, -f1,3 &amp;lt;&amp;lt;&amp;lt;&amp;quot;a,,b,c,d,e&amp;quot; a,b	 是相当明显的，但是使用空格分隔符，对某些人来说可能不太明显。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十四)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-54.html</link>
      <pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-54.html</guid>
      <description>处理系统提示    转义符 含义     \a 响铃字符   \d 日期，&amp;rdquo;Weekday Month Date&amp;rdquo;这种格式的(像&amp;rdquo;Tue May 26&amp;rdquo;)   \D{FORMAT} 这个FORMAT是传给strftime(3)，并且结果插入提示字符串。一个空的FORMAT导致特定于区域设置的时间表示。花括号是必须的   \e 转义符。\ 033当然也可以。   \h 主机名，知道第一个.(就是没有域的部分)   \H 带有域部分的主机名称   \j 这个shell当前关联的任务数量   \l shell的终端设备名称的根目录   \n 新行   \r 回车符   \s shell的名称，基名是&amp;rdquo;$0&amp;rdquo;(最后一个斜杠后面的部分)   \t 24小时格式的时间，HH:MM:SS   \T 12小时格式的时间，HH:MM:SS   @ 12小时格式的时间， am/pm   \A 24小时的时间，HH:MM   \u 当前用户的用户名   \v Bash的版本(2.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-53.html</link>
      <pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-53.html</guid>
      <description>特定时间的任务 在特定时间执行一次任务 注意：at默认没有在大多数的发行版中安装。
想要只当前时间之外的某个时间执行一些任务，在例子中是下午5点，你可以向下面这样：
echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 5pm  如果你想要获取命令的输出，你可以像往常一样：
echo &amp;quot;somecommand &amp;gt; out.txt 2&amp;gt;err.txt &amp;amp;&amp;quot; | at 5pm  at理解非常多的时间格式，所以你也可以像下面这样：
echo &amp;quot;somecommand &amp;amp;&amp;quot; | at now + 2 minutes echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 17:00 echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 17:00 Jul 7 echo &amp;quot;somecommand &amp;amp;&amp;quot; | at 4pm 12.03.17  如果没有指定年月日的话，这将会在下次遇到这个时间的时候执行。所以如果你提供了一个之前的时间，将会在明天执行。如果你提供了之前的月份，那将会在下一年才会执行。
这也会和nohup联合使用，想你期望的一样：
echo &amp;quot;nohup somecommand &amp;gt; out.txt 2&amp;gt;err.txt &amp;amp;&amp;quot; | at 5pm  有更多的控制命令执行时间的命令:
 atq列出所有的时间任务 atrm移除一个时间任务 batch像at命令一样，但是只在系统的负载在0.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十二)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-52.html</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-52.html</guid>
      <description>变量类型 声明弱类型变量 declare是bash的内部变量。经常用来显示和定义变量或显示函数体。
语法：`declare [options] [name[=value]]&amp;hellip;
# options are used to define # an integer declare -i myInteger declare -i anotherInt=10 # an array with values declare -a anArray=( one two three) # an assoc Array declare -A assocArray=( [element1]=&amp;quot;something&amp;quot; [second]=anotherthing ) # note that bash recognizes the string context within [] # some modifiers exist # uppercase content declare -u big=&#39;this will be uppercase&#39; # same for lower case declare -l small=&#39;THIS WILL BE LOWERCASE&#39; # readonly array declare -ra constarray=( eternal true and unchangeable ) # export integer to environment declare -xi importantInt=42  也可以使用+来移除给定的属性。基本没有用处，只是为了完整性。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十一)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-51.html</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-51.html</guid>
      <description>协同进程 Hello World # create the co-process coproc bash # send a command to it (echo a) echo &#39;echo Hello World&#39; &amp;gt;&amp;amp;&amp;quot;${COPROC[1]}&amp;quot; # read a line from its output read line &amp;lt;&amp;amp;&amp;quot;${COPROC[0]}&amp;quot; # show the line echo &amp;quot;$line&amp;quot;  输出&amp;rdquo;Hello World&amp;rdquo;
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五十)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-50.html</link>
      <pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-50.html</guid>
      <description>脚本输出修改格式 color-output.sh 在bash脚本的开头部分，可以定义一些变量，这些变量在脚本运行期间充电帮助器来对终端的输出进行着色或格式化。
不同的平台使用不同的字符序列来表示颜色。然而有一个叫做tput的工具：在任何类Unix的系统上面，返回指定系统的终端颜色字符串通过一个跨平台的API。
例如，获取终端文本红色或绿色的字符串序列到变量中：
 red=$(tput setaf 1) green=$(tput setaf 2)  或者，要存储将文本重置为默认外观的字符序列：
reset=$(tput sgr0)  然后，当BASH脚本想要显示不同的颜色和输出是，可以像下面这样：
echo &amp;quot;${green}Success!${reset}&amp;quot; echo &amp;quot;${red}Failure.${reset}&amp;quot;  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十九)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-49.html</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-49.html</guid>
      <description>shell类型 开启一个交互shell bash  检查shell类型 shopt -q login_shell &amp;amp;&amp;amp; echo &#39;login&#39; || echo &#39;not-login&#39;  点文件 在Unix中，以.开头的文件或目录包含了指定程序或一系列程序的配置选项。点文件通常对用户是隐藏的，所以你需要使用ls -a来查看这些文件。
一个点文件的例子是.bash_history，假设用户使用Bash，包含了最近执行的命令。
当你在Bash中时，有各种文件是被source的。下面的图片来自这个站点，显示了在启动时选择要源文件的决策过程。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十八)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-48.html</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-48.html</guid>
      <description>命令和操作链 有多种方法比命令连接在一起使用。简单的就像;，复杂的像逻辑链(根据条件使用不同的命令)。第三种就是管道命令：在链条中，下一个命令处理上一个命令的输出结果。
统计字符串出现次数 使用管道把上一个命令的输出结果作为下个命令的输入值：
ls -l | grep -c &amp;quot;.conf&amp;quot;  这个例子中，ls命令的输出结果作为grep命令的输入。结果是文件名中包含.conf的文件的数量。
这个可以用组织尽量长的命令队列：
ls -1 | grep &amp;quot;.conf&amp;quot; | grep -c .  传输root命令输出到用户文件 有时候想要把root命令的执行结果给其他的用户。tee命令很简单的以用户的权限把root命令的输出结果放入一个文件中。
su -c ifconfig | tee ~/results-of-ifconfig.txt  只有ifconfig是以root的身份运行的。
逻辑命令链 &amp;amp;&amp;amp; || &amp;amp;&amp;amp;连接两个命令，第二个命令只有在第一个命令执行成功的情况下才会执行。||的两个命令只有第一个命令失败的情况下第二个命令才会执行。
[ a = b ] &amp;amp;&amp;amp; echo &amp;quot;yes&amp;quot; || echo &amp;quot;no&amp;quot; # if you want to run more commands within a logical chain, use curly braces # which designate a block of commands # They do need a ; before closing bracket so bash can diffentiate from other uses # of curly braces [ a = b ] &amp;amp;&amp;amp; { echo &amp;quot;let me see.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十七)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-47.html</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-47.html</guid>
      <description>使用trap响应信号和系统事件    参数 详情     -p 列出当前按照的traps   -l 列出信号的名称和相应编号    清理临时文件 你可以使用trap命令来&amp;rdquo;trap&amp;rdquo;信号：这是shell中等同于C中调用signal()或sigaction()，或者其他的编程语言中捕捉信号的方法。
trap的一个常用的地方是清理希望或不希望存在的临时文件。
不幸的是没有足够的脚本实现这个功能：
#!/bin/sh #定义清理函数 cleanup() { rm --force -- &amp;quot;${tmp}&amp;quot; } # 捕捉特殊的EXIT组， shell存在时会一直运行 trap cleanup EXIT #创建临时文件 tmp=&amp;quot;$(mktemp -p /tmp tmpfileXXXXX)&amp;quot; echo &amp;quot;Hello World!&amp;quot; &amp;gt;&amp;gt; &amp;quot;${tmp}&amp;quot; # No rm -f &amp;quot;$tmp&amp;quot; needed. The advantage of using EXIT is that it still works # even if there was an error or if you used exit.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十六)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-46.html</link>
      <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-46.html</guid>
      <description>printf输出日期 在Bash4.2，提供了printf内建的时间规则：%(datefmt)T可以让printf输出datefmt指定格式的时间字符串。其中datefmt需要是strftime识别的格式。
获取当前时间 $ printf &#39;%(%F)T\n&#39; 2019-03-14  设置当前时间变量 $ printf -v now &#39;%(%T)T&#39; $ echo &amp;quot;$now&amp;quot; 21:00:04  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十五)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-45.html</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-45.html</guid>
      <description>单词拆分    参数 详情     IFS 内部的字段分隔符   -x 打印执行的命令和他们的参数    what，when和why 当shell执行参数扩展，命令替换，变量或算术扩展时，它会扫描结果中的字边界。如果找到了字符边界，就会在这个位置把结果分成多个单词。这个单词的边界是被IFS定义的。如果没有显示指明的话，IFS的默认值是空白，tab和新行。当遇到这三个字符的时候，会进行单词的拆分。
set -x var=&#39;I am a multiline string&#39; fun() { echo &amp;quot;-$1-&amp;quot; echo &amp;quot;*$2*&amp;quot; echo &amp;quot;.$3.&amp;quot; } fun $var  在上面的例子中线上了fun是怎么执行的
fun I am a multiline string   $var被分成5个单词，但是只有I，am，a被输出。
 单词拆分的坏处 $ a=&#39;I am a string with spaces&#39; $ [ $a = $a ] || echo &amp;quot;didn&#39;t match&amp;quot; bash: [: too many arguments didn&#39;t match   [ $a = $a ]被解析为[ I am a string with spaces = I am a string with spaces ]。[是一个test命令，然而I am a string with spaces是6个参数不是一个参数。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十四)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-44.html</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-44.html</guid>
      <description>管理PATH环境变量 添加一个path到PATH环境变量 PATH环境变量通常定义在.bashrc或者.bash_profile或者/etc/profile或者.profile或者/etc/bash.bashrc(不同的bash配置文件)。
$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin: /usr/lib/jvm/jdk1.8.0_92/bin:/usr/lib/jvm/jdk1.8.0_92/db/bin:/usr/lib/jvm/jdk1.8.0_92/jre/bin  现在，如果我们想在PATH中添加一个路径(例如~/bin):
PATH=~/bin:$PATH # or PATH=$PATH:~/bin  但是这只会在当前的shell(或它的子shell中生效)。一旦你退出了这个shell，这个修改就会失效。
想要让修改永久话的话，我们需要在~/.bashrc中添加这些代码，并重新加载这个文件。
如果你在终端中运行下面的命令，将会把~/bin添加到PATH中：
echo &#39;PATH=~/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.bashrc &amp;amp;&amp;amp; source ~/.bashrc  命令解释：
 echo &#39;PATH=~/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.bashrc在文件~/.bashrc的末尾添加PATH=~/bin:$PATH这行代码，你也可以在编辑器中添加 source ~/.bashrc重新加载~/.bashrc文件  下面这个代码将会检查路径是否存在，只有在不存在的时候才会添加：
path=~/bin # path to be included bashrc=~/.bashrc # bash file to be written and reloaded # run the following code unmodified echo $PATH | grep -q &amp;quot;\(^\|:\)$path\(:\|/\{0,1\}$\)&amp;quot; || echo &amp;quot;PATH=\$PATH:$path&amp;quot; &amp;gt;&amp;gt; &amp;quot;$bashrc&amp;quot;; source &amp;quot;$bashrc&amp;quot;  从PATH环境变量移除路径 要从PATH中移除一个路径，需要编辑~/.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-43.html</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-43.html</guid>
      <description>管道 使用|&amp;amp; |&amp;amp;连接一命令的标准输出和标准错误到二命令，而|命令连接一命令的标准输出到二命令。
在这个例子中，使用curl命令加下载这个页面，使用-v选项写一些内容到标准错误中，这个页面被输出到标准输出中。这个页面的标题在&amp;lt;title&amp;gt;和&amp;lt;/tilte&amp;gt;之间。
curl -vs &#39;http://www.google.com/&#39; |&amp;amp; awk &#39;/Host:/{print} /&amp;lt;title&amp;gt;/{match($0,/&amp;lt;title&amp;gt;(.*)&amp;lt;\/title&amp;gt;/,a);print a[1]}&#39;  这将会输出：
&amp;gt; Host: www.google.com Google  但是使用|的话，会输出更多的内容：即哪些被输出到标准错误中的信息，因为只有标准输出被管道到下一个命令。在这个例子中除了最后一行，其他的都是输出到标准错误中的：
* Hostname was NOT found in DNS cache * Trying 172.217.20.228... * Connected to www.google.com (172.217.20.228) port 80 (#0) &amp;gt; GET / HTTP/1.1 &amp;gt; User-Agent: curl/7.35.0 &amp;gt; Host: www.google.com &amp;gt; Accept: */* &amp;gt; * HTTP 1.0, assume close after body &amp;lt; HTTP/1.0 200 OK &amp;lt; Date: Sun, 24 Jul 2016 19:04:59 GMT &amp;lt; Expires: -1 &amp;lt; Cache-Control: private, max-age=0 &amp;lt; Content-Type: text/html; charset=ISO-8859-1 &amp;lt; P3P: CP=&amp;quot;This is not a P3P policy!</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十二)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-42.html</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-42.html</guid>
      <description>scp传输文件 scp传输文件 想要安全的传输一个文件到另一台机器上面：
scp file1.txt tom@server2:$HOME  这个例子将会把file1.txt从我们的机器上面传输到server2的用户tom的家目录内。
scp传输多个文件 scp也可以用来从一个服务器到一个服务器传输多个文件。下面的例子是从my_folder目录传输所有后缀为.txt的文件到server2。下面的例子所有的文件传输到用户的home目录：
scp /my_folder/*.txt tom@server2:$HOME  使用scp下载文件 从远端机器下载文件到本地机器：
scp tom@server2:$HOME/file.txt /local/machine/path/  这里例子展示了如果从tom的家目录下载文件file.txt到本地机器的当前目录。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十一)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-41.html</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-41.html</guid>
      <description>拆分文件 有时候把一个文件分成多个文件时很有用的。如果你有一个大文件，把它分成多个小块是很有用的。
拆分一个文件 直接不带参数的运行spilt命令，将会把一个文件分为1个或多个文件，每个文件最多包含1000行。
split file  这将会创建文件xaa xab xac …，每个文件最多1000行。这里你注意到，所有的文件都是x开头的。如果文件没有1000行，只有创建一个这样的文件。
想要修改文件名前缀的话，在命令的后面添加你想要的文件前缀：
split file customprefix  现在将会创建customprefixaa, customprefixab, customprefixac...这些文件。
指定每个文件的行数，可以使用-l选项。下面的命令将会拆分文件，每个文件最多5000行。
split -l5000 file  或者
split --lines=5000 file  另外你可以指定文件的最大大小而不是行数。这可以通过使用-b或—bytes选项来实现。例如，每个文件最大1M：
split --bytes=1MB file  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四十)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-40.html</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-40.html</guid>
      <description>文件执行顺序 .bash_profile，.bash_login，.bashrc和.profile做这相同的事情：设置和定义函数，变量和排序。
主要的不同是.bashrc在开启一个非登录的交互窗口是调用，.bash_profile和其他文件在登录的shell中执行。无论如何很多人都拥有.bash_profile和相似的.bashrc。
.profile VS .bash_profile(和.bash_login) .profile在很多shell启动的时候读取，包括bash。然后.bash_profile是指定bash的配置。对于通用的初始化代码，放在.profile中，但是指定bash的代码，放到.bash_profile中。
.profile并不是专门为bash设计的，但是.bash_profile是。(.profile是用于Bourne和其他类似的shell的，bash基于这个创作的。)如果找不到.bash_profile，就会去寻找.profile。
如果找不到.bash_profile的话，就会寻找.bash_login，但是最好是使用.bash_profile或.profile。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十九)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-39.html</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-39.html</guid>
      <description>读取文件    参数 详情     IFS 内部字段分隔符   file 文件名或路径   -r 当使用read时，防止反斜杠解析   -t 从readarray读取的每一行中删除尾部换行符   -d DELIM 读取到DELIM的第一个字符中断，而不是换行符    一行一行循环 while IFS= read -r line; do echo &amp;quot;$line&amp;quot; done &amp;lt;file  如果没有包含新行符号的话：
while IFS= read -r line || [ -n &amp;quot;$line&amp;quot; ]; do echo &amp;quot;$line&amp;quot; done &amp;lt;file  逐个字段循环 我们假设字段分隔符是:：
while IFS= read -d : -r field || [ -n &amp;quot;$field&amp;quot; ];do echo &amp;quot;**$field**&amp;quot; done &amp;lt; &amp;lt;(ping google.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十八)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-38.html</link>
      <pubDate>Wed, 06 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-38.html</guid>
      <description>case语句 简单语句 在所有bash版本支持的最简单格式中，case语句执行与模式匹配的case。如果有的话，;;在第一次匹配后中断。
#!/bin/bash var=1 case $var in 1) echo &amp;quot;Antartica&amp;quot; ;; 2) echo &amp;quot;Brazil&amp;quot; ;; 3) echo &amp;quot;Cat&amp;quot; ;; esac  输出：
Antartica  贯穿语句 Version&amp;gt;=4.0
从4.0开始，引入了新的操作符;&amp;amp;，支持贯穿操作。
#!/bin/bash var=1 case $var in 1) echo &amp;quot;Antartica&amp;quot; ;&amp;amp; 2) echo &amp;quot;Brazil&amp;quot; ;&amp;amp; 3) echo &amp;quot;Cat&amp;quot; ;&amp;amp; esac  输出：
Antartica Brazil Cat  子模式匹配贯穿 Version&amp;gt;=4.0
4.0开始，另一个操作符;;&amp;amp;，只有子语句匹配才贯穿的操作。
#!/bin/bash var=abc case $var in a*) echo &amp;quot;Antartica&amp;quot; ;;&amp;amp; xyz) echo &amp;quot;Brazil&amp;quot; ;;&amp;amp; *b*) echo &amp;quot;Cat&amp;quot; ;;&amp;amp; esac  输出：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十七)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-37.html</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-37.html</guid>
      <description>任务管理 显示后台进程 $ jobs [1] Running sleep 500 &amp;amp; (wd: ~) [2]- Running sleep 600 &amp;amp; (wd: ~) [3]+ Running ./Fritzing &amp;amp;  第一个字段是任务的id。+和-表示当前任务结束时的默认任务和下一个候选任务。当在没有任何参数的情况下使用fg或bg命令时，将使用默认作业。
第二个字段是当前任务的状态。第三个字段时用来启动这个进程的命令。
最后一个字段（wd：~）表示sleep命令是从工作目录（home）启动的。
从后台取一个进程到前台  $ fg %2 sleep 600  %2意味着第2个进程。如果fg命令没有带参数，将会把最后一个命令取到前台。
 $ fg %?sle sleep 500  ?sle意味着取出包含sle的命令。如果有多个后台命令匹配，将会出现一个错误。
重启以停止的命令 $ bg [8]+ sleep 600 &amp;amp;  运行后台命令  $ sleep 500 &amp;amp; [1] 7582  把sleep命令放到后台执行。7582就是这个进程的id。
终止一个前台进程 Ctrl+Z终止前台进程，并放入到后台执行。
$ sleep 600 ^Z [8]+ Stopped sleep 600  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十六)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-36.html</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-36.html</guid>
      <description>内部变量 简单介绍一下Bash的内部变量，并说明在什么地方，怎么使用以及何时使用这些变量。
Bash内部变量一览    变量 详情      函数/脚本可以选择的变量或参数。   $* $@ $*和$@和$1 $2..这样的内容是一样的(注意：通常不引用这些内容是没有意义的) &amp;quot;$*&amp;quot; 和 &amp;quot;$1 $2 … 一样。&amp;quot;$@&amp;quot;和&amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot; …一样。&amp;quot;$*&amp;quot;是由$IFS的第一个字符分割的，不一定是空格   $# 传个脚本或者函数的参数的数量   $! 最后放入后台工作(管道的最右边那个)的job的id。(注意：当启用作业控制时，它不一定和作业的组id相同)   $$ bash正在执行的进程的id   $? 最后一个命令的退出状态   $n 指定位置的参数 n=1,2,3,4…9   ${n} 和上面一样，但是n可以大于9   $0 在执行脚本时，是脚本的路径。bash -c &#39;printf &amp;quot;%s\n&amp;quot; &amp;quot;$0&amp;quot;&#39; name。name(内部脚本的第一个参数)或者，argv[0]会获得bash   $_ 命令的最后一个字段   $IFS 内建的字段分隔符   $PATH 用来寻找可执行脚本的路径地址   $OLDPWD 前一个工作目录   PWD 当前的工作目录   FUNCNAME 调用栈内的函数名称数组   BASH_SOURCE 包含FUNCNAME数组中函数的地址的数组。可以用来寻找脚本路径。   $BASH_ALIAS 当前定义别名的管理数组   BASH_REMATCH 上一个正则表达式匹配的结果   BASH_VERSION bash版本的字符串   BASH 到当前执行的bash的绝对路径。(由bash根据argv[0]和$path的值以启发式方式确定；在某些情况下可能是错误的)   BASH_SUBSHELL bash subshell的等级   $UID 运行bash的进程的实际（如果不同则无效）用户ID   $PS1 主进程的命令提示   $PS2 辅助命令行提示（用于附加输入）   PS3 三级命令行提示（用于select循环）   PS4 第四级命令行提示（用于附加详细输出的信息）   RANDOM 0-32767之间的伪随机整数   $REPLY 当变量没有指定时，默认为read的使用的变量。SELECT还用于用户返回的值   PIPESTATUS 数组变量，保存最近执行的前台管道中每个命令的退出状态值。     变量赋值的时候等号前后不能有空格。a=123而不是a = 123。后者（由空格包围的等号）单独表示使用参数=和123运行命令a，尽管在字符串比较运算符（从语法上讲，它是[或[[或使用的任何测试]的参数）中也可以看到。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十五)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-35.html</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-35.html</guid>
      <description>修改shell 查找当前的shell 有好几种方式获取当前的shell：
echo $0 ps -p $$ echo $SHELL  列出所有有效shell 列出所有有效的shell
cat /etc/shells  例如：
$ cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash  修改shell 修改当前的shell可以使用下面的命令：
 export SHELL=/bin/bash exec /bin/bash  修改.profile文件，添加上面的内容。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十四)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-34.html</link>
      <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-34.html</guid>
      <description>模式匹配和正则表达式 获取字符串正则匹配的内容 a=&#39;I am a simple string with digits 1234&#39; pat=&#39;(.*) ([0-9]+)&#39; [[ &amp;quot;$a&amp;quot; =~ $pat ]] echo &amp;quot;${BASH_REMATCH[0]}&amp;quot; echo &amp;quot;${BASH_REMATCH[1]}&amp;quot; echo &amp;quot;${BASH_REMATCH[2]}&amp;quot;  输出：
I am a simple string with digits 1234 I am a simple string with digits 1234  glob未匹配时的行为 $ mkdir globbing $ cd globbing $ mkdir -p folder/{sub,another}folder/content/deepfolder/ touch macy stacy tracy &amp;quot;file with space&amp;quot; folder/{sub,another}folder/content/deepfolder/file .hiddenfile $ shopt -u nullglob $ shopt -u failglob $ shopt -u dotglob $ shopt -u nocaseglob $ shopt -u extglob $ shopt -u globstar  在这个例子里面，使用nullglob和failglob时将没有匹配任何内容。无论使用了哪一个，如果没有匹配的时候，bash将会返回glob本身。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十三)</title>
      <link>http://blog.huaifufeng.com/2019/03/post/bash-section-33.html</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/03/post/bash-section-33.html</guid>
      <description>debug调试 使用-n检查脚本语法 使用-n允许你在不执行脚本的情况下检查这个脚本：
~&amp;gt; $ bash -n testscript.sh testscript.sh: line 128: unexpected EOF while looking for matching `&amp;quot;&#39; testscript.sh: line 130: syntax error: unexpected end of file  使用bashdb调试 bashdb是一个和gdb雷士的工具，使用这个工具你可以实现某行或者某个方法的中断，输出变量的内容，或者重启脚本等等。
通常可以使用包管理器按照这个工具，像在Fedroa中：
sudo dnf install bashdb  你可以从首页上获取这个工具。然后可以使用它像参数一样运行这个脚本：
bashdb &amp;lt;YOUR SCRIPT&amp;gt;  下面是一些你可以使用的命令：
l - show local lines, press l again to scroll down s - step to next line print $VAR - echo out content of variable restart - reruns bashscript, it re-loads it prior to execution.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十二)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-32.html</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-32.html</guid>
      <description>getopts:智能位置-参数分析    参数 详情     optstring 要识别的选项字符串   name 然后命名存储解析选项的位置    pingmap #!/bin/bash # Script name : pingnmap # Scenario : The systems admin in company X is tired of the monotonous job # of pinging and nmapping, so he decided to simplify the job using a script. # The tasks he wish to achieve is # 1. Ping - with a max count of 5 -the given IP address/domain.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十一)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-31.html</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-31.html</guid>
      <description>花括号扩展 修改文件名扩展 $ mv filename.{jar,zip}  这个将会执行mv filename.jar filename.zip这个命令
创建按照年月分组文件的目录 $ mkdir 20{09..11}-{01-12}  执行ls命令，将会看到下面的目录被创建了：
2009-01 2009-04 2009-07 2009-10 2010-01 2010-04 2010-07 2010-10 2011-01 2011-04 2011-07 2011-10 2009-02 2009-05 2009-08 2009-11 2010-02 2010-05 2010-08 2010-11 2011-02 2011-05 2011-08 2011-11 2009-03 2009-06 2009-09 2009-12 2010-03 2010-06 2010-09 2010-12 2011-03 2011-06 2011-09 2011-12  在9前面加上0确保当个数字有一个0。你也可以在数字前面使用多个0，例如：
$ echo {001..10} 001 002 003 004 005 006 007 008 009 010  创建.文件的备份 $ cp .</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三十)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-30.html</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-30.html</guid>
      <description>定制化PS1 修改终端的颜色和提示 gitPS1(){ gitps1=$(git branch 2&amp;gt;/dev/null | grep &#39;*&#39;) gitps1=&amp;quot;${gitps1:+ (${gitps1/#\* /})}&amp;quot; echo &amp;quot;$gitps1&amp;quot; } #Please use the below function if you are a mac user gitPS1ForMac(){ git branch 2&amp;gt; /dev/null | sed -e &#39;/^[^*]/d&#39; -e &#39;s/* \(.*\)/ (\1)/&#39; } timeNow(){ echo &amp;quot;$(date +%r)&amp;quot; } if [ &amp;quot;$color_prompt&amp;quot; = yes ]; then if [ x$EUID = x0 ]; then PS1=&#39;\[\033[1;38m\][$(timeNow)]\[\033[00m\] \[\033[1;31m\]\u\[\033[00m\]\[\033[1;37m\]@\[\033[00m\]\[\033[1;33m\]\h\[\033[00m\] \[\033[1;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\] \[\033[1;31m\]:/#\[\033[00m\] &#39; else PS1=&#39;\[\033[1;38m\][$(timeNow)]\[\033[00m\] \[\033[1;32m\]\u\[\033[00m\]\[\033[1;37m\]@\[\033[00m\]\[\033[1;33m\]\h\[\033[00m\] \[\033[1;34m\]\w\[\033[00m\]\[\033[1;36m\]$(gitPS1)\[\033[00m\] \[\033[1;32m\]:/$\[\033[00m\] &#39; fi else PS1=&#39;[$(timeNow)] \u@\h \w$(gitPS1) :/$ &#39; fi  下面就是配置终端的显示样式：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十九)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-29.html</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-29.html</guid>
      <description>可编程补全 函数实现补全 _mycompletion(){ local command_name=&amp;quot;$1&amp;quot; local current_word=&amp;quot;$2&amp;quot; local previous_word=&amp;quot;$3&amp;quot; # COMPREPLY is an array which has to be filled with the possible completions # compgen is used to filter matching completions COMPREPLY==( $(compgen -W &#39;hello world&#39; -- &amp;quot;$current_word&amp;quot;) ) } complette -F _mycompletion mycommand  使用例子：
$ mycommand [TAB][TAB] hello world $ mycommand h[TAB][TAB] $ mycommand hello  选项和文件名的简单补全 # The following shell function will be used to generate completions for # the &amp;quot;nuance_tune&amp;quot; command.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十八)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-28.html</link>
      <pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-28.html</guid>
      <description>过程替换 比较web文件 下面的例子用diff命令执行过程替换来比较两个文件，而不是创建两个临时文件。
diff &amp;lt;(curl http://www.example.com/page1) &amp;lt;(curl http://www.example.com/page2)  while循环从命令输出获取 下面使用grep命令的输出作为while循环的输出参数：
while IFS=&amp;quot;:&amp;quot; read -r user _ do #&amp;quot;$user&amp;quot; 有/etc/passwd中的密码 done &amp;lt; &amp;lt;(grep &amp;quot;hello&amp;quot; /etc/passwd)  拼接文件 总所周知，你不能在一个命令里面把一个文件既当做输入文件也当做输出文件，例如：
$ cat header.txt body.txt &amp;gt;body.txt  不会产生你希望的结果。当cat命令读取body.txt文件的内容时，这个文件已经被重定向截断，并且内容是空。最后body.txt只会有header.txt的内容。
某些人可能相应使用进程替换来避免这个效果，就是下边这样：
$ cat header.txt &amp;lt;(cat body.txt) &amp;gt; body.txt  将强制在重定向截断文件之前，将body.txt的原始内容以某种方式保存在某个缓冲区中。但是这并没有作用。括号中的cat只有在所有文件描述符都设置好之后才开始读取文件，就像外部的描述符一样。在这种情况下，尝试使用流程替换是没有意义的。
将文件预处理到另一个文件的唯一方法是创建中间文件：
$ cat header.txt body.txt &amp;gt; body.txt.new $ mv body.txt.new body.txt  当使用交互编辑选项-i调用sed、perl或类似的命令时，会在后台默默执行这些命令。
同时通过多个程序传输文件 下面的命令使用wc -l计算同时使用gzip压缩大文件的行数，两者同时运行：
$ tee &amp;gt;(wc -l &amp;gt;&amp;amp;2) &amp;lt; bigfile | gzip &amp;gt; bigfile.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十七)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-27.html</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-27.html</guid>
      <description>Scoping 动态作用域 动态作用域的含义是：动态范围是指变量查找发生在调用函数的范围内，而不是在定义函数的范围内。
$ x=3 $ func1 () { echo &amp;quot;in func1: $x&amp;quot;;} $ func2 () { local x=9; func1;} $ func2 in func1 9 $ func1 in func1: 3  在词汇范围语言中，func1总是在全局范围中查找x的值，因为func1是在本地范围中定义的。
在动态范围语言中，func1查找调用它的范围。当从func2中调用它时，它首先在func2的主体中查找值x。如果没有在那里定义它，它将在全局范围中查找，其中func2是从全局范围调用的。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十六)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-26.html</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-26.html</guid>
      <description>Bash算法    参数 详情     EXPRESSION 执行的表达式    (())算法 #!/bin/bash echo $((2 + 1))  输出3。
#!/bin/bash var1=4 var2=5 ((output=$var1 * $var2)) printf &amp;quot;%d\n&amp;quot; &amp;quot;$output&amp;quot;  输出20
算法命令  let   let num=1+2 let num=&amp;quot;1+2&amp;quot; let &#39;num= 1 + 2&#39; let num=1 num+=2  如果有空格或者填充字符，你就需要引号了。所有下面会出现错误：
 let num= 1 + 2 //错误 let &#39;num = 1 + 2&#39; //正确 let a[1] = 1 + 1 //错误 let &#39;a[1] = 1 + 1&#39; //正确   (())   ((a=$a+1)) //a加1 ((a = a + 1)) //a加1 ((a += 1)) //a加1  我们可以在if表达式中使用(())。例如：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十五)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-25.html</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-25.html</guid>
      <description>Math dc是Unix系统中最古老的命令之一。
它使用reverse polish notation，这意味着：你首先存在数字，然后提供操作符。例如1+1就写成1 1 +。
打印前面存储的数据，使用p命令：
$ echo &#39;2 3 + p&#39; | dc 5 # 或者 $ dc &amp;lt;&amp;lt;&amp;lt; &#39;2 3 + p&#39; 5  你可以多次打印顶层元素：
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;1 1 + p 2 + p&#39; 2 4  负数使用_前缀：
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;_1 p&#39; -1  你可以使用A到F之前的字符标识10到15之间的数字。.表示小数符合。
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;A.4 p&#39; 10.4  dc是任意精度的，这意味着只要内存许可精度是不收限制的。默认情况下精度是0：
$ dc &amp;lt;&amp;lt;&amp;lt; &#39;4 3 / p&#39; 1  我们可以提升之前命令的精度使用k命令。像下面这样：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十四)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-24.html</link>
      <pubDate>Wed, 20 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-24.html</guid>
      <description>Bash的历史替换 快速引用 操作历史记录 #列出所有之前的命令 history #如果你不小心输入了命令，这时候清除所有的历史是很有用的 history -c  事件指示符 #执行历史中第n行的命令 !n #执行最后的命令 !! #执行最后以&#39;text&#39;文本开始的命令 !text #执行最后包含&#39;text&#39;的命令 !?text #执行n行之前的命令 !-n #执行最后一个以&#39;foo&#39;开头的并将&#39;foo&#39;替换为&#39;bar&#39;的命令 ^foo^bar^ #执行当前的命令 !#  单词指示符 它们由:与它们所引用的事件指示符分开。如果事件指示符不是数字开始的，可以省略冒号：!^和!:^是一样的。
#获取最后命令的第一个参数 !^ #获取最后命令的最后参数(!!:$的短格式) !$ #获取最后命令的第3个参数 !:3 #获取最后命令从x到y之间的参数，可以是数字，也可以是 $ ^ !:x-y #获取最后命令处理第0个之外的所有参数，等价于 :^-$ !*  修改 这些会修改前面的事件或单词指示符。
#使用sed语法替换。允许标记在s和可选分隔符之前 :s/foo/bar/ #替换最开始的foo为bar :gs|foo|bar| #替换所有的foo为bar #从最后一个参数删除前导路径(tail) :t #从最后一个参数删除尾随路径(head) :h #删除最后一个参数的文件扩展名 :r  如果Bash变量HISTCONTROL包含ignorrespace或ignoreboth（或者包含模式[ ]*）,这样你不想把你的命令添加到history的时候，可以在命令前面添加空格：
#不保存 foo #保存 bar  以sudo权限执行之前的命令 $ apt-get install r-base E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied) E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十三)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-23.html</link>
      <pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-23.html</guid>
      <description>脚本变量 多变量解析 解析很多变量，最好的办法就是使用while循环，加上case语句和shift。
shift是从一系列变量中回去第一个变量，比如当前是$1，使用这个你将会获得$2。这在一次处理多个变量的时候非常有用。
#!/bin/bash #加载用户定义的变量 while [[ $# &amp;gt; 0 ]] do case &amp;quot;$1&amp;quot; in -a|--valueA） valA=&amp;quot;$2&amp;quot; shift ;; -b|--valueB) valB=&amp;quot;$2&amp;quot; shift ;; --help|*) echo &amp;quot;Usage:&amp;quot; echo &amp;quot; --valueA \&amp;quot;value\&amp;quot;&amp;quot; echo &amp;quot; --valueB \&amp;quot;\value&amp;quot;&amp;quot; echo &amp;quot; --help&amp;quot; exit 1 ;; esac shift done echo &amp;quot;A: $valA&amp;quot; echo &amp;quot;B: $valB&amp;quot;  输入和输出：
$ ./multipleParams.sh --help Usage: --valueA &amp;quot;value&amp;quot; --valueB &amp;quot;value&amp;quot; --help $ ./multipleParams.sh A: B: $ ./multipleParams.sh --valueB 2 A: B: 2 $ .</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十二)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-22.html</link>
      <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-22.html</guid>
      <description>条件表达式 文件类型检查 -e检查文件是否存在，包括所有的文件类型（如：括号，文件。。。）
if [[ -e $filename ]]; then echo &amp;quot;$filename exists&amp;quot; fi  也可以对指定类型的文件格式进行检查：
if [[ -f $filename ]]; then echo &amp;quot;$filename is a regular file&amp;quot; elif [[ -d $filename ]]; then echo &amp;quot;$filename is a directory&amp;quot; elif [[ -p $filename ]]; then echo &amp;quot;$filename is a named pipe&amp;quot; elif [[ -S $filename ]]; then echo &amp;quot;$filename is a named socket&amp;quot; elif [[ -b $filename ]]; then echo &amp;quot;$filename is a block device&amp;quot; elif [[ -c $filename ]]; then echo &amp;quot;$filename is a character device&amp;quot; fi if [[ -L $filename ]]; then echo &amp;quot;$filename is a symbolic link (to any file type)&amp;quot; fi  对于符号链接，使用-L这些测试应用到目标上，当时坏链接的时候返回false。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十一)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-21.html</link>
      <pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-21.html</guid>
      <description>引号 变量和命令替换的双引号 变量的个替换只能够被用在双引号中。
calculation=&#39;2 * 3&#39; echo &amp;quot;$calculation&amp;quot; # prints 2 * 3 echo $calculation # prints 2, the list of files in the current directory, and 3 echo &amp;quot;$(($calculation))&amp;quot; # prints 6  在双引号之外，$var使用变量var的值，然后用空格分隔这个值的每一部分，并将每一部分解析为一个(通配符)模式。除非你需要这种方式，否则每次都把$var放到双引号里面&amp;quot;$var&amp;quot;。
这也适用于命令的方式，&amp;quot;$(mycommand)&amp;quot;输出mycommand的值。mycommand将会输出空格分隔之后的结果。
echo &amp;quot;$var&amp;quot; # good echo &amp;quot;$(mycommand)&amp;quot; # good another=$var # also works, assignment is implicitly double-quoted make -D THING=$var # BAD! This is not a bash assignment. make -D THING=&amp;quot;$var&amp;quot; # good make -D &amp;quot;THING=$var&amp;quot; # also good  命令替换有它自己的上下文环境。编写任意嵌套替换很容易，因为解析器将跟踪嵌套深度，而不是贪婪地搜索第一个“字符”。不过，StackOverflow语法高亮分析错误。例如：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二十)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-20.html</link>
      <pubDate>Sat, 16 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-20.html</guid>
      <description>Here语法 here文档执行命令 ssh -p 21 example@example.com &amp;lt;&amp;lt;EOF echo &#39;printing pwd&#39; echo &amp;quot;\${pwd}&amp;quot; ls -a find &#39;*.txt&#39; EOF  $这里是被逃脱的，因为我们不想让这个变量在当前shell中解析。$(pwd)应该在远端的shell中执行。
另外一种方式：
ssh -p 21 example@example.com &amp;lt;&amp;lt;&#39;EOF&#39; echo &#39;printing pwd&#39; echo &amp;quot;$(pwd)&amp;quot; ls -a find &#39;*.txt&#39; EOF  注意：这个结束的EOF标识需要在一行的最开始（前面没有任何空格）。如果需要缩进的话，当你的hera语法是以&amp;lt;&amp;lt;-开头的话，可以使用tab。查看here文档的缩进和限制字符串来获取更多信息。
here缩进 你可以在here文档中使用tab来进行缩进操作，但是这个时候你就需要使用&amp;lt;&amp;lt;-来代替&amp;lt;&amp;lt;符号了：
$ cat &amp;lt;&amp;lt;- EOF This is some content indented with tabs `\t`. You cannot indent with spaces you __have__ to use tabs. Bash will remove empty space before these lines. __Note__: Be sure to replace spaces with tabs when copying this example.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十九)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-19.html</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-19.html</guid>
      <description>Source source一个文件和执行命令是不同的，因为所有的命令都是在当前bash会话的上下文环境中执行的—这就意味着所有的变量、函数或别名在整个会话中是保持不变的。
创建一个你想要source的文件sourcename.sh：
#!/bin/bash export A=&amp;quot;hello_world&amp;quot; alias sayHi=&amp;quot;echo Hi&amp;quot; sayHello() { echo Hello }  在你当前的bash会话中，source这个文件：
$ source sourcename.sh  从这时开始，在当前的会话中你拥有了被source文件内的所有变量：
$ echo $A hello_world $ sayHi Hi $ sayHello Hello  另外注意：.命令是source命令的简称，所以你可以简单的使用下面的命令：
. sourcename.sh  source虚拟环境 当在一个机器上面开发多个应用的时候，把不同的依赖分别放入不同的虚拟环境是很有用的。
通过使用virtualenv命令，这些环境变量被source到你的shell环境中。这样当你执行一个命令的时候，它是被运行在一个虚拟环境中。
下面是使用pip按照软件的常用方法：
pip install https://github.com/pypa/virtualenv/tarball/15.0.2  创建一个新的环境变量：
virtualenv --python=python3.5 my_env  激活这个环境：
source my_env/bin/activate  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十八)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-18.html</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-18.html</guid>
      <description>Sort    Option meaning     -u 每行输出都唯一    sort是一个Unix命令，用来按顺序对文件中的数据进行排序。
命令输出 sort用来排序一列行。
输入一个文件 sort file.txt  排序另个命令的输出 你可以排序任何输出命令的输出。在下面的例子中，会排序一列符合条件的文件：
find * -name pattern | sort  输出唯一 如果想要输出的行保持唯一，可以使用-u选项。
输出目录中文件的所有者：
ls -l | awk &#39;{print $3}&#39; | sort -u  数字排序 假设我们有下面的文件：
$ cat file 10.Gryffindor 4.Hogwarts 2.Harry 3.Dumbledore 1.The sorting hat  想要按数字排序这些内容，使用-n选项：
sort -n file  这个命令会输出下面的内容：
1.The sorting hat 2.Harry 3.Dumbledore 4.Hogwarts 10.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十七)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-17.html</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-17.html</guid>
      <description>Find find是一个用于在目录中递归搜索与条件匹配的文件（或目录）的命令，然后对所选文件执行某些操作。
find search_path selection_criteria action  按照文件名或扩展名搜索文件 使用指定的文件名在pwd指向的本地目录内搜索文件或目录：
$ find . -name &amp;quot;myFile.txt&amp;quot; ./myFile.txt  使用通配符查找有指定扩展名的文件或目录：
$ find . -name &amp;quot;*.txt&amp;quot; ./myFile.txt ./myFile2.txt  想要搜索包含多个扩展的文件或目录，使用or选项：
$ find . -name &amp;quot;*.txt&amp;quot; -o -name &amp;quot;*.sh&amp;quot;  想要搜索以abc开头，后面跟着一个字符，之后跟着一个数字使用下面的模式：
$ find . -name &amp;quot;abc[a-z][0-9]&amp;quot;  获取指定目录下所有的文件：
$ find /opt  只显示目录下面的文件，使用-type f：
$ find /opt -type f  只显示目录下面的目录，使用-type d:
$ find /opt -type d  对找到的文件执行命令 有时候我们需要在一批文件上面运行命令。这里就可以使用xargs命令。
find . -type d -print | xargs -r chmod 770  上面的命令将会在.</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十六)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-16.html</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-16.html</guid>
      <description>复制    Option Description     -a,-archive 和选项d，p，r一起使用   -b,-backup 在删除之前，建立一个备份   -d,&amp;ndash;no-deference 保存连接   -f,&amp;ndash;force 在不提醒用户的情况下删除目标地址存在的文件   -i,&amp;ndash;interactive 在覆盖前进行提示   -l,&amp;ndash;link 不复制文件，而是使用文件连接   -p,&amp;ndash;preserve 尽可能保留文件的属性   -R,&amp;ndash;recursive 递归复制目录的文件    复制一个文件 把文件foo.txt从/path/to/source/复制到/path/to/target/folder/。
cp /path/to/source/foo.txt /path/to/target/folder/  把文件foo.txt从/path/to/source/复制到/path/to/target/folder/，并且修改文件名称为bar.txt。
cp /path/to/source/foo.txt /path/to/target/folder/bar.txt  复制目录 把目录foo复制到目录bar里面：
cp -r /path/to/foo /path/to/bar  如果目录bar在执行命令之前存在，目录foo和它的内容将会被复制到目录bar中。但是如果执行命令之前bar目录不存在的话，会创建目录bar，并且把目录foo的内容存放到bar中。
参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十五)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-15.html</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-15.html</guid>
      <description>bash参数扩展 $字符引入了参数扩展、命令替换或算术扩展。要扩展的参数名称或符号可以用大括号括起来，大括号是可选的，但可以将变量从紧跟在其后面的字符扩展中选取出来，不然这些字符可以被解释为名称的一部分。
查看更多。
修改字母字符的大小写 Version&amp;gt;=4.0
修改为大写字母：
$ v=&amp;quot;hello&amp;quot; # Just the first character $ printf &#39;%s\n&#39; &amp;quot;${v^}&amp;quot; Hello # All characters $ printf &#39;%s\n&#39; &amp;quot;${v^^}&amp;quot; HELLO # Alternative $ v=&amp;quot;hello world&amp;quot; $ declare -u string=&amp;quot;$v&amp;quot; $ echo &amp;quot;$string&amp;quot; HELLO WORLD  转换字符为小写：
$ v=&amp;quot;BYE&amp;quot; # Just the first character $ printf &#39;%s\n&#39; &amp;quot;${v,}&amp;quot; bYE # All characters $ printf &#39;%s\n&#39; &amp;quot;${v,,}&amp;quot; bye # Alternative $ v=&amp;quot;HELLO WORLD&amp;quot; $ declare -l string=&amp;quot;$v&amp;quot; $ echo &amp;quot;$string&amp;quot; hello world  大写修改为小写，小写修改为大写：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十四)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-14.html</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-14.html</guid>
      <description>函数 带参数函数 在helloJohn.sh文件里面有下面的代码：
#!/bin/bash greet() { local name=&amp;quot;$1&amp;quot; echo &amp;quot;Hello, $name&amp;quot; } greet &amp;quot;John Doe&amp;quot;  执行这个文件：
$ bash helloJohn.sh Hello, John Doe   如果你没有修改参数，可以不用把这个参数放到本地变量中，可以直接使用`echo &amp;ldquo;Hello, $1&amp;rdquo;
 你可以在函数中使用$1，$2，$3等等的变量访问函数的参数。
   注意：对于超过9个的参数，使用$10是没有用的，因为这将被解析成为$10，所以你需要使用${10}、${11}这样的变量。
  在函数中，$@引用所有的参数：   #!/bin/bash foo() { echo &amp;quot;$@&amp;quot; } foo 1 2 3 # output =&amp;gt; 1 2 3   注意：你应该像这里展示的一样，在$@周围使用双引号。
 省略引号将导致shell扩展通配符（即使用户为避免这种情况而专门引用通配符），并且通常会引入不受欢迎的行为，甚至潜在的安全问题。
 foo &amp;quot;string with spaces;&amp;quot; &#39;$HOME&#39; &amp;quot;*&amp;quot; # output =&amp;gt; string with spaces; $HOME *   想要使用默认值的话，用${1:-default_val}的格式：   #!</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十三)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-13.html</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-13.html</guid>
      <description>关联数组 操作关联数组 以下代码段显示了所有需要的用法：
#!/usr/bin/env bash declare -A assoc_array=([key_string]=value \ [one]=&amp;quot;something&amp;quot; \ [two]=&amp;quot;another thing&amp;quot; \ [ three ]=&#39;mind the blanks!&#39; \ [ &amp;quot; four&amp;quot; ]=&#39;count the blanks of this key later!&#39; \ [IMPORTANT]=&#39;SPACES DO ADD UP!!!&#39; \ [1]=&#39;there are no integers!&#39; \ [info]=&amp;quot;to avoid history expansion &amp;quot; \ [info2]=&amp;quot;quote exclamation mark with single quotes&amp;quot; \ ) echo # just a blank line echo now here are the values of assoc_array: echo ${assoc_array[@]} echo not that useful, echo # just a blank line echo this is better: declare -p assoc_array # -p == print echo have a close look at the spaces above\!</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十二)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-12.html</link>
      <pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-12.html</guid>
      <description>数组 数组赋值 列表赋值 如果你熟悉Perl，C或者Java的话，你可能会认为Bash使用逗号来分隔数组的元素，然而不是这样的，Bash使用空格来分隔元素：
# Perl中的数组 my @array = (1, 2, 3, 4); #Bash中的数组 array=(1 2 3 4)  使用新元素创建数组：
array=(&#39;first element&#39; &#39;second element&#39; &#39;third element&#39;)  下标赋值 使用明确的元素索引创建一个数组：
array=([3]=&#39;fourth element&#39; [4]=&#39;fifth element&#39;)  索引赋值 array[0]=&#39;first element&#39; array[1]=&#39;second element&#39;  关联数组 Version&amp;gt;= 4.0
decalare -A array array[first]=&#39;First element&#39; array[second]=&#39;Second elemet&#39;  动态赋值 从其他命令的输出结果创建一个数组，例如使用seq获取1到10的值：
array=(`seq 1 10`)  从脚本的输入参数赋值给数组：
array=(&amp;quot;$@&amp;quot;)  使用循环赋值：
while read -r; do #array+=(&amp;quot;$REPLY&amp;quot;) #数组追加 array[$i]=&amp;quot;$REPLY&amp;quot; #索引赋值 let i++ #索引增加 done &amp;lt; &amp;lt;(seq 1 10) #?</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十一)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-11.html</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-11.html</guid>
      <description>true，false和：命令 无限循环 while true; do echo ok done  或者
while :; do echo ok done  或者
until false; do echo ok done  函数返回 function positive() { return 0 } function negative() { return 1 }  一直或从不执行的代码 if true; then echo Always executed fi if false; then echo Never executed fi  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(十)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-10.html</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-10.html</guid>
      <description>控制结构    Parameter to [ or test Details     File Operators Details   -e &amp;ldquo;$file&amp;rdquo; 如果文件存在，返回true   -d &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个目录的话，返回true   -f &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个普通文件的话，返回true   -h &amp;ldquo;$file&amp;rdquo; 如果文件存在并且是一个符号链接的话，返回true   String Comparators Details   -z &amp;ldquo;$str&amp;rdquo; 字符串长度为0时为true   -n &amp;ldquo;$str&amp;rdquo; 字符串长度不为0时为true   &amp;rdquo;$str&amp;rdquo; = &amp;ldquo;$str2&amp;rdquo; 如果字符串$str等于字符串$str2。对整数是不合适的，虽然可以工作，但是结果可能不符合预期。   &amp;rdquo;$str&amp;rdquo; != &amp;ldquo;$str2&amp;rdquo; 如果字符串$str不等于$str2时返回true   Integer Comparators Details   &amp;rdquo;$int1&amp;rdquo; -eq &amp;ldquo;$int2&amp;rdquo; 如果整数相等返回true   &amp;rdquo;$int1&amp;rdquo; -ne &amp;ldquo;$int2&amp;rdquo; 如果整数不相等返回true   &amp;rdquo;$int1&amp;rdquo; -gt &amp;ldquo;$int2&amp;rdquo; 如果整数$int1大于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -ge &amp;ldquo;$int2&amp;rdquo; 如果整数$int1大于等于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -lt &amp;ldquo;$int2&amp;rdquo; 如果整数$int1小于$int2返回true   &amp;rdquo;$int1&amp;rdquo; -le &amp;ldquo;$int2&amp;rdquo; 如果整数$int1小于等于$int2返回true    命令列表的条件执行 如何使用命令列表的条件执行 任何内建的命令、表达式或函数，以及外部的命令或脚本都可以使用&amp;amp;&amp;amp;或||运算符有条件的执行。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(九)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-9.html</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-9.html</guid>
      <description>重定向    Parameter Details     内部文件标识 整形   重定向 &amp;gt;或&amp;lt;或&amp;lt;&amp;gt;   外部文件标识或路径 文件标识或路径后面加&amp;amp;    重定向标准输出 &amp;gt;重定向当前命令的标准输出（STDOUT）到一个文件或者另外的描述符。
下面的例子会把ls命令的标准输出，输出到一个文件file.txt：
$ ls &amp;gt;file.txt $ &amp;gt; file.txt ls  如果目标文件不存在的话，就会创建这个文件，否则就会重置这个文件。
默认的文件标识符是标准输出，或者没有提供的话就是1。下面的命令和之前的一样，只是指定了标准输出：
$ ls 1&amp;gt;file.txt  注意：重定向是执行的shell初始化的，而不是由执行的命令初始化的，因此在命令执行前，初始化工作就已经完成了。
追加 Vs 重置 重置 &amp;gt;  文件不存在创建指定文件 重置（删除文件内容） 向文件写入内容  $ echo &amp;quot;first line&amp;quot; &amp;gt; /tmp/lines $ echo &amp;quot;second line&amp;quot; &amp;gt; /tmp/lines $ cat /tmp/lines second line  追加 &amp;gt;&amp;gt;  不存在创建文件 追加文件（向文件末尾写入内容）  # Overwrite existing file $ echo &amp;quot;first line&amp;quot; &amp;gt; /tmp/lines # Append a second line $ echo &amp;quot;second line&amp;quot; &amp;gt;&amp;gt; /tmp/lines $ cat /tmp/lines first line second line  重定向到STDOUT和STDERR 文件标识符0和1是指针。我们通过重定向更改文件描述符指向的内容。&amp;gt;/dev/null意味着1指向/dev/null。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(八)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-8.html</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-8.html</guid>
      <description>任务和进程 任务处理 创建任务 要创建一个任务，可以在命令后面添加&amp;amp;符号：
$ sleep 10 &amp;amp; [1] 20024  你也可以创建一个运行任务进程，可以按下Ctrl+z：
前后台进程 想要把一个后台进程获取到前台执行，可以使用fg命令加上%和进程数：
$ sleep 10 &amp;amp; [1] 20024 $ fg %1 sleep 10  现在你可以控制流程，想要把进程放回到后台运行的话，使用bg命令。因为终端的缓存，你需要使用Ctrl+z来终端进行。
$ sleep 10 ^Z [1]+ Stopped sleep 10 $ bg %1 [1]+ sleep 10 &amp;amp;  因为程序员的&amp;rdquo;惰性&amp;rdquo;，当只有一个进程或者想要处理列表中第一个进程，可以只适使用一个%。
$ sleep 10 &amp;amp; [1] 20024 $ fg % # to bring a process to foreground &#39;fg %&#39; is also working. sleep 10  或者：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(七)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-7.html</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-7.html</guid>
      <description>别名 shell的别名是一种创建新命令或者在已有命令添加自己代码的方式。这和shell的函数有重叠的地方，但是shell函数更加通用，最好优先使用。
绕过别名 有时候你想临时绕过一个别名，而不是让别名不能使用了。下面就是一个例子：
alias ls=&#39;ls --color=auto&#39;  如果我们想要使用ls命令而不是ls别名，有下面几种方法：
 使用内建的command命令：command ls 使用命令的完整路径：/bin/ls 在命令名的任何地方添加一个\：\ls或l\s 把命令引用起来：&amp;rdquo;ls&amp;rdquo;或&amp;rsquo;ls&amp;rsquo;  创建别名 alias word=&#39;command&#39;  使用word就是运行命令command。任何追加到别名后面的参数就会添加到命令后面：
 alias myAlias=&#39;some command --with --options&#39; myAlias foo bar baz  上面的别名将会执行下面的命令：
some command --with --options foo bar baz  想要在一行中执行多个命令，可以使用&amp;amp;&amp;amp;连接多个命令字符串。李润：
alias print_things=&#39;echo &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;bar&amp;quot; &amp;amp;&amp;amp; echo &amp;quot;baz&amp;quot;&#39;  删除别名 删除别名使用下面的命令：
unalias {alias_name}  例如：
# create an alias $ alias now=&#39;date&#39; # preview the alias $ now Thu Jul 21 17:11:25 CEST 2016 # remove the alias $ unalias now # test if removed $ now -bash: now: command not found  BASH_ALIASES 别名是一些命令的快捷方式，可以在交互式bash实例中定义和使用。这些别名被保存在一个名字文件BASH_ALIASES的关联数组文件。想要在脚本中使用这些别名的话，必须在交互式的shell中：</description>
    </item>
    
    <item>
      <title>Bash专业笔记(六)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-6.html</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-6.html</guid>
      <description>grep 找bar文件中的foo字符：
$ grep foo ~/Desktop/bar  寻找bar文件中不包含foo字符的其他字符串：
$ grep –v foo ~/Desktop/bar  显示所有以foo结尾的字符串：
$ grep &amp;quot;*foo&amp;quot; ~/Desktop/bar  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(五)</title>
      <link>http://blog.huaifufeng.com/2019/02/post/bash-section-5.html</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/bash-section-5.html</guid>
      <description>cat    Option Description     -n 输出行号   -v 使用^和M-代替不能打印的字符，除了LFD和TAB   -T 使用^I代替TAB   -E 使用$代替换行符(LF)   -e 和-vE一个含义   -b 输出非空行行号，覆盖-n   -A 等价于-vET   -s 抑制重复输出空行    拼接文件 这是cat命令的主要作用：
$ cat file1 file2 file3 &amp;gt; file_all  cat命令也用来把拼接文件的结果作为管道的一部分：
$ cat file1 file2 file3 | grep foo  输出文件内容 $ cat file.txt  将会输出文件的所有内容。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(四)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-4.html</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-4.html</guid>
      <description>文件列表    Option Description     -a, &amp;ndash;all 列出所有文件，包含.开头的文件   -A, &amp;ndash;almost-all 列出所有文件，处理.和..   -c 按修改时间排序文件   -d, &amp;ndash;directory 列出所有的目录   -h, &amp;ndash;human-readable 使用人可读的单位列出文件的大小（K, M等）   -H 和上面的参数一样，只是使用1000来代替1024   -l 显示文件的详细信息   -o 显示详细信息处理分组信息   -r, &amp;ndash;reverse 倒序显示文件内容   -s, &amp;ndash;size 显示文件的块大小   -S 以文件大小排序   &amp;ndash;sort=WORD 按照某个词排序（size，version，status等）。ps：mac没有这个选项   -t 按照修改时间排序   -u 按照访问时间排序   -v 按照版本排序   -1 每行返回一个文件    列出文件详情 ls命令的-l参数，打印文件长列表格式的详细信息。如果没有指定文件夹，默认列出当前文件夹的内容。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(三)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-3.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-3.html</guid>
      <description>导航目录 绝对目录和相对目录 想要切换到一个绝对路径的目录，可以使用/开头的完整目录名称：
$ cd /home/username/project/abc  如果你想到达的目录在这个目录的下级目录，可以使用一个相对路径。例如，你当前在/home/username/project目录，如果想要到这个目录的abc子目录：
$ cd abc  如果你想到当前目录的上级目录，可以使用..符号。比如，如果你当前在/home/username/project/abc这个目录，现在想要到/home/username/project这个目录，可以使用下面的命令：
$ cd ..  这也可以称作“向上”目录。
到之前目录 在当前的shell中，你可以到你之前在的目录，而不用管这个目录在哪：
$ cd -  如果多次执行这个目录，你将会在当前目录和之前的目录之间切换。
home目录 默认的目录是home目录（$HOME，特别是/home/username），所以当没有带目录参数的执行cd命令的时候，将会直接到home目录：
$ cd  或者你可以更加明确的执行：
$ cd $HOME  home目录的简单符合是~，所以也可以这样执行：
$ cd ~  脚本目录 通常，有两种bash脚本：
 在当前目录执行的系统工具。 相对于自己目录修改文件的项目工具。  对第二中脚本来说，到的脚本所在的目录是非常有用的。这可以使用下面的命令：
$ cd &amp;quot;$(dirname &amp;quot;$(readlink -f &amp;quot;$0&amp;quot;)&amp;quot;)&amp;quot;  这个命令运行了3个命令：
 readlink -f &amp;quot;$0&amp;quot;获取当前脚本的目录。 dirname获取脚本的目录。 cd修改当前的目录到dirname返回的目录。  参考：Bash Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Bash专业笔记(二)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-2.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-2.html</guid>
      <description>脚本shebang 环境shebang 想要使用bash命令执行一个脚本文件，可以使用可以执行的env来指定PATH环境变量中的bash命令。脚本文件的第一行需要是：带有bash参数的绝对路径的env可执行文件：
#!/usr/bin/env bash  只有在使用下面这样的方式执行脚本的时候，shebang里面的env命令才会被解析：
script.sh  当然，这个脚本必须有执行权限。
当直接指明bash解析器来执行脚本的时候，这个shebang是被忽略的：
bash script.sh  直接shebang 想要用bash来执行一个脚本，也可以定义一个可以执行的bash路径：
#!/bin/bash  当直接执行脚本的时候，shebang将会被解析并执行：
./script.sh  脚本需要可以执行的权限。
当bash解析器直接指明来执行这个脚本的时候，这个shebang不会被执行：
bash script.sh  其他的shebang 操作系统内核能识别的有两种程序：一种是用ELF (ExtenableLoadableFormat)头声明的二进制程序，通常是编译生成的；另一种就是各种的脚本。
如果一个文件的第一行以#!开头，下一个字符串必须是一个解析器的路径。如果操作系统内核读到了这行，会调用路径指向的解析器，然后把后面的字符都传给这个解析器作为参数。如果没有文件焦作something或者wrong：
#!/bin/bash something wrong echo &amp;quot;This line never gets printed&amp;quot;  bash执行的时候，参数something wrong是不存在的。脚本文件的名称也会被添加。下面看下直接声明echo命令的shebang：
#&amp;quot;/bin/echo something wrong # and now call this script named &amp;quot;thisscript&amp;quot; like so: # thisscript one two # the output will be: something wrong ./thisscript one two  一些想awk的程序就用这种技术来运行长时间留在硬盘上的脚本。</description>
    </item>
    
    <item>
      <title>Bash专业笔记(一)</title>
      <link>http://blog.huaifufeng.com/2019/01/post/bash-section-1.html</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/bash-section-1.html</guid>
      <description>开始Bash Hello World 交互shell Bash shell通常是使用其交互模式：这允许你输入和修改命令，当你按下Return键的时候，就会执行这些命令。大多数基于Unix和类Unix的操作系统都会使用Bash作为它们默认的shell（特别是Linux和macOS）。当终端打开的时候会自动的进入交互模式的Bash shell。
使用下面的方式输出一个Hello World：
$ echo &amp;quot;Hello World&amp;quot; #&amp;gt; Hello World # Output Example  注意点：
 你可以在终端中通过修改shell的名称来修改shell。比如：sh，bash等等 echo是Bash内建的一个命令，会把它接收到的参数输出到标准输出中。默认它会在输出的后面输出一个新行。  非交互shell Bash shell也可以在脚本中被按照非交互模式运行，当shell不需要人工操作时。交互的行为和非交互的行为都是唯一的：Unix V7 Bourne shell和其他的衍生shell 的一项重要设计原则。因此，任何在命令行中可以执行的命令都可以放到脚本中重复使用。
下面的步骤创建了一个Hello World脚本：
 创建一个叫hello-world.sh的文件。   $ touch hello-world.sh   为文件添加执行权限：chmod +x hello-world.sh
 添加下面的代码：
   #!/bin/bash echo &amp;quot;Hello World&amp;quot;  第一行：脚本的第一行必须以字符串#!开始，这被叫做 shebang。这个shebang通知操作系统去允许/bin/bash，并且把文件的路径作为参数传递给这个命令。像：/bin/bash hello-world.sh
第二行：使用echo命令把Hello world输出到标准输出。
 在命令行中执行hello-world.sh这个脚本可以使用下面的人一个方式：
 ./hello-world.sh 最常用的方法，也是最推荐的方法。 /bin/bash hello-world.sh bash hello-world.</description>
    </item>
    
  </channel>
</rss>