<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/tags/git/</link>
    <description>Recent content in Git on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 04 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/tags/git/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Git专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</guid>
      <description>配置    Parameter Detals     &amp;ndash;system 编辑为每个人使用的系统配置（在linux上，配置文件在$(prefix)/etc/gitconfig）   &amp;ndash;global 修改为你的每个仓库使用的全局配置文件（在linux上，配置文件在~/.gitconfig）   &amp;ndash;local 编辑指定仓库的配置文件，在你仓库的.git/config这个文件内，这个是默认的配置    配置编辑器 有多个方式来配置你commit和rebase的时候使用的编辑器：
 修改core.editor配置项：   $ git config --global core.editor nano   设置GIT_EDITOR环境变量：  举个例子，应用到一个命令：
 $ GIT_EDITOR=nano git commit  或者为终端执行的所有git命令。注意：直到你关闭了终端，这个配置才会生效：
 $ export GIT_EDITOR=nano   想要修改终端所有程序的编辑器，不仅仅是git，可以VISUAL或EDITOR环境变量（可以查看VISUAL vs EDITOR）:   $ export EDITOR=nano  注意：像上面一样，这个命令只会应用到当前的终端页面。你的shell通常会有一个配置文件，允许你永远的设置你的配置。（比如在bash时，可以添加上面的配置到~/.bashrc获取~/.bash_profile配置文件）。
一些文本编辑器（主要是GUI编辑器）一次只运行一个实例，如果你已经打开了一个实例，通常会退出。如果您的文本编辑器就是这种情况，Git将打印Aborting commit due to empty commit message。不允许你先编辑你的提交信息。如果你遇到了这种情况，检查你的编辑器文档是否有--wait这个配置项。允许你在文档关闭之前终端提交。</description>
    </item>
    
    <item>
      <title>Git专业笔记（十三）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</link>
      <pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-13.html</guid>
      <description>分支    Parameter Detals     -d,&amp;ndash;delete 删除分支。这个分支必须合并到它的远端分支，如果设置了--track或--set-upstream的话，就需要在HEAD中   -D --delete --force强制删除的简称   -m,&amp;ndash;move 移动/重命名分支和相应的reflog   -M --move —force命令的简称   -r,&amp;ndash;remotes 列出或删除（使用-d）远端追踪的分支   -a,&amp;ndash;all 列出远端追踪分支和本地分支   &amp;ndash;list 激活列表模式。git branch &amp;lt;pattern&amp;gt;会试着新建分支。git branch -- list &amp;lt;pattern&amp;gt;列出所有匹配的分支   &amp;ndash;set-upstream 如果指定的分支不存在或者指定了--force参数，行为会和--track一样。否则在创建分支时设置像--track那样的配置，除了分支指向的地方没有改变    创建和切换新分支 创建一个新分支，并且保留在当前分支，执行下面的命令：
$ git branch &amp;lt;name&amp;gt;  通常，分支名称不得包含空格，并且符合列出的这里列出的其他规范。切换到已经存在的分支：
$ git checkout &amp;lt;name&amp;gt;  创建并且切换到新分支：
$ git checkout -b &amp;lt;name&amp;gt;  在指定索引创建一个分支，而不是在当前分支的最后提交（就是HEAD），可以使用下面任何一个命令：</description>
    </item>
    
    <item>
      <title>Git专业笔记（十二）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-12.html</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-12.html</guid>
      <description>rebase    Parameter Detals     &amp;ndash;continue 在解决完merge冲突之后，重新开始执行rebase命令   &amp;ndash;abort 中断rebase操作之后，重新吧HEAD定位到原有分支上。如果在使用rebase命令的时候提供了分支名，HEAD将会被设置到这个分支上。否则HEAD将会重新设置到rebase操作开始的位置。   &amp;ndash;keep-empty 保留那些没有修改的提交   &amp;ndash;skip 重新开始rebase命令，忽略掉当前的补丁   -m,&amp;ndash;merge 在rebase的时候使用megre策略。当使用递归(默认)合并策略的话，这允许rebase知道上游的重命名。注意rebase合并的工作方式是从上游分支顶部的工作分支重放每个提交。因此，当合并冲突发生时，报告为我们的一方是迄今为止重新定位的系列，从上游开始，他们是工作分支。换句话说，双方交换。   &amp;ndash;stat 显示上次rebase之后，上游做的修改。这些不同将会有rebase.stat配置项控制   -x, &amp;ndash;exec command 执行交互式rebase，在每个提交和执行command之间暂停    本地分支rebase rebase在另外提交的顶部应用一系列的提交。rebase一个分支的话，首先切换到这个分支，然后rebase到另一个分支的顶部：
$ git checkout topic $ git rebase master  这会导致：
	A---B---C topic / D---E---F---G master  变成：
 A&#39;--B&#39;--C&#39; topic / D---E---F---G master  这些操作可以合并到一个简单命令上面：切换分支然后执行rebase命令</description>
    </item>
    
    <item>
      <title>Git专业笔记（十一）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-11.html</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-11.html</guid>
      <description>别名 简单别名 有两种方法来创建Git别名：
 编辑~/.gitconfig文件：   [alias] ci = commit st = status co = checkout   使用命令行：   git config --global alias.ci &amp;quot;commit&amp;quot; git config --global alias.st &amp;quot;status&amp;quot; git config --global alias.co &amp;quot;checkout&amp;quot;  在别名创建之后：
 git ci就是git commit git st就是git status git co就是git checkout  像正常的命令一样，别名也可以使用参数，例如：
 git ci -m &amp;quot;Commit message...&amp;quot; git co -b feature-42  显示搜索别名 你可以使用--get-regexp选项来列出所有的别名：
$ git config --get-regexp &#39;^alias\.&#39;  搜索别名 想要搜索别名的话，在.</description>
    </item>
    
    <item>
      <title>Git专业笔记（十）</title>
      <link>http://blog.huaifufeng.com/2019/02/post/git-section-10.html</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/02/post/git-section-10.html</guid>
      <description>提交    参数 详情     &amp;ndash;message, -m 包含在提交中的信息。这将会打开一个编辑器   &amp;ndash;amend 指定这个参数将会把当前暂存区的信息添加到之前的提交内。请注意，这将会修改之前的提交历史   &amp;ndash;no-edit 使用选择的提交信息但是不打开编辑器，例如：git commit --amend --no-edit追加提交到之前的提交上，并且不修改提交信息。   &amp;ndash;all, -a 提交包括未暂存的文件在内的修改   &amp;ndash;date 手动设置关联到这个提交的日期信息   &amp;ndash;only 只提交指定路径的信息。这将只会提交指定的文件   &amp;ndash;patch,-p 使用交互的补丁选择窗口来选择提交哪些修改   -S[keyid], -S &amp;ndash;gpg- sign[=keyid], -S &amp;ndash;no-gpg-sign Sign commit, GPG-sign commit, 取消 commit.gpgSign 配置变量   -n,&amp;ndash;no-verify 这个参数取消执行预提交和提交信息的钩子。详情看钩子    暂存提交修改 基础 在你修改了你的本地文件之后，在你准备提交这些修改之前，需要把文件暂存起来。
例如，如果你修改README.md和program.py这两文件：
$ git add README.</description>
    </item>
    
    <item>
      <title>Git专业笔记（九）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-9.html</link>
      <pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-9.html</guid>
      <description>submodule clone一个有子模块的仓库 当你克隆了一个有子模块的仓库时，你需要初始化和更新他们：
$ git clone --recursive https://github.com/username/repo.git  这将会克隆关联的子模块，并且把子模块放到合适的位置上面（包括子模块关联的子模块）。这个命令等价于在仓库克隆之后立即执行git submodule update --init --recursive这个命令。
更新子模块 如果一个子模块引用了另一个仓库中的子模块的特定提交。想要切换到所有引用子模块的特定状态的话，可以使用下面的命令：
$ git submodule update --recursive  有时候为了替换引用子模块当前的状态，你想要把本地米宽的分支切换到远端的最新状态。使用下面的命令可以把所有引用的子模块切换到远端最新的分支：
$ git submodule foreach git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;  或者使用默认的git pull参数：
$ git submodule foreach git pull  注意：这将只会更新本地工作区副本。如果一个子模块用这个命令更新了，他将会出现在git status命令的文件列表内。如果你想要把你的引用更新到最新的状态，你可以提交这些修改：
 git add &amp;lt;submodule_directory&amp;gt; git commit  如果你使用git pull的话，这写修改可能会造成合并冲突。你可以使用git pull —rebase来把修改到会到最新。大多数情况下这会减少出现冲突的次数。这也会把所有的分支pull到本地：
$ git submodule foreach git pull --rebase  想要把某个分支切换到最新的状态，可以使用：
$ git submodule update --remote &amp;lt;submodule_directory&amp;gt;  添加子模块 你可以把另外的Git仓库当做你自己项目的一个文件夹，使用Git来追踪：</description>
    </item>
    
    <item>
      <title>Git专业笔记（八）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-8.html</link>
      <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-8.html</guid>
      <description>merge    parameter Details     -m 在merge提交里使用的信息   -v 显示详细的输出   &amp;ndash;abort 中断把文件恢复到之前的状态   &amp;ndash;ff-only 当一个merge提交被要求的话立即中断   &amp;ndash;no-ff 强制创建一个merge提交，即使它不是强制的   &amp;ndash;no-commit 假装merge失败了，允许去检查和调整这个结果   &amp;ndash;stat merge合并之后，展示状态的不同   -n/&amp;ndash;no-stat 不显示状态的不同   &amp;ndash;sqaush 允许对这个分支的merge修改做一个单独的提交    自动合并 当两个分支的提交不冲突的话，Git可以自动的合并他们：
~/Stack Overflow(branch:master) » git merge another_branch Auto-merging file_a Merge made by the &#39;recursive&#39; strategy. file_a | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)  找到没有merge提交的分支 有时候你有一些已经把修改merge到master上的分支。这将找出来所有不是master分支并且和master分支没有区别提交的分支。这用来查找在PR合并到master之后，没有删除的分支非常有帮助：</description>
    </item>
    
    <item>
      <title>Git专业笔记（七）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-7.html</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-7.html</guid>
      <description>撤销修改 返回前一个提交 返回前一个提交，首先使用git log找到前一个提交的hash值。然后要临时返回那个提交的话，使用下面的命令：
$ git checkout 789abcd  这将返回hash值为789abcd的提交。现在你可以在不影响你的HEAD的情况下，在这个老提交的基础上建立新的提交。你可以使用branch或checkout -b命令来建立一个分支，然后把这些修改放到这个分支上面。
使用下面的命令返回上一个提交的话，会保留之前的修改：
$ git reset --soft 789abcd  去返回上一个提交，可以使用下面的命令：
$ git reset --soft HEAD~  想要抛弃某个提交之后的修改，可以使用下面的命令：
$ git reset --hard 789abcd  想要抛弃上一个提交之后的修改，使用下面的命令：
$ git reset --hard HEAD~  注意：你可以使用reflog和reset恢复丢弃的提交，但是没有提交的修改是无法恢复的。
撤销修改 撤消对工作副本中文件或目录的更改。
$ git checkout -- file.txt  下面的命令将会递归的应用到当前目录的所有文件和文件夹上面，他将撤销工作区副本的所有修改：
$ git checkout .  想要撤销部分修改的话，可以使用---patch选项。这样对每个修改，你都将被询问，是要撤销还是保留：
$ git checkout --patch -- dir  想要撤销添加到index的修改，使用下面的命令：
$ git reset --hard  如果没有—hard选项的话，这将会执行一个软reset命令。</description>
    </item>
    
    <item>
      <title>Git专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-6.html</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-6.html</guid>
      <description>git diff    parameter details     -p, -u, &amp;ndash;patch 生成补丁。   -s, &amp;ndash;no-patch 取消差异的输出。对于像git diff这样显示补丁的命令非常有用。或者用来取消—patch选项的效果。   &amp;ndash;raw 输出原生格式信息的文件差异信息。   &amp;ndash;diff-algorithm= 选择差异对比的算法。可选的算法有：myers，minimal，patience，histogram   &amp;ndash;summary 输出一个压缩的扩展头信息，包括（创建，重命名和模式修改等）   &amp;ndash;name-only 只展示修改文件的名称   &amp;ndash;name-status 展示已修改文件的名称和状态，常见的状态有：M 修改 A 添加 D 删除   &amp;ndash;check 如果修改出现了标记冲突和空白错误会发出警告。被视作空白错误的信息是由core.whitespace控制的。默认情况下，尾随空格（包括仅由空格组成的行）和空格字符（在行的初始缩进内紧跟制表符）被视为空格错误。如果出现问题就会以非0的退出码退出。不和--exit-code兼容。   &amp;ndash;full-index 当想产生补丁格式的输出时，取代最开始的几个字符，将会把完整的pre-和post-image二进制对象显示在索引行中。   &amp;ndash;binary 除了像--full-index外，还会输出一个可以用于git apply命令的二进制差异文件。   -a, &amp;ndash;text 把所有的文件视作文本。   &amp;ndash;color 设置颜色模式：如果要将diff设置为较小并保持git的颜色，请使用--color=always    展示工作区差异 $ git diff  这将展示当前分支未暂存的修改和之前的提交的差异。这只展示相对于索引的差异，也就是只展示你可以在下次提交的，但是还没有提交的修改。想要添加这些修改，可以使用git add。</description>
    </item>
    
    <item>
      <title>Git专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-5.html</link>
      <pubDate>Sun, 27 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-5.html</guid>
      <description>忽略文件文件夹 这章的主题是介绍怎么避免把不想要的文件（或者文件的修改）添加到Git仓库内。有好几种方式可以实现这个目的：全局或者本地的.gitignore ，.git/exclude，git update-index --assume-unchanged，git update-index --skip-tree。但是请记住Git是用来管理内容的：忽略实际忽略的是文件夹的内容。一个空的文件夹将会被自动忽略，因为它不能不添加到仓库内。
.gitignore 你可以让Git通过添加一个或多个.gitignore文件来忽略某些文件或者文件夹，即不把这些内容通过Git来追踪。
在一些软件项目中，.gitignore文件会包含一列在构建程序或运行时产生的文件或文件夹。在.gitignore中，可能包含指向下面内容的名称或路径：
 临时资源，像缓存，log文件，编译文件等 不应该分享给其他人的配置文件 包含密码、秘钥、证书等隐秘信息的文件  当在顶层目录创建这个文件时，这些规则将会应用到这个仓库所有的文件和子目录。当在子目录创建时，这些规则只会应用到这个目录和这个目录子目录的文件中。
当一个文件或目录被忽略了，这代表：
 不会被Git库追踪。 不会再git status和git diff命令中输出处理。 不会通过git add -A命令暂存这些内容。  在一些特殊的场景下，你需要把已经追踪的文件忽略掉，这时你要特别小心。可以查看下面章节：忽略已提交内容。
例子： 下面是一些.gitignore中比较简单的例子，基于glob file patterns：
# Lines starting with `#` are comments. # Ignore files called &#39;file.ext&#39; file.ext # Comments can&#39;t be on the same line as rules! # The following line ignores files called &#39;file.ext # not a comment&#39; file.ext # not a comment # Ignoring files with full path.</description>
    </item>
    
    <item>
      <title>Git专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-4.html</link>
      <pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-4.html</guid>
      <description>暂存区 暂存所有文件 想要删除一个远端的分支：
$ git add -A  在Git 2.0+之后的版本
$ git add .  在版本2.x时，git add .命令将会添加当前目录及其子目录下的所有修改的文件。但是在1.x的版本，只会暂存新建或修改的文件，不会暂存删除的文件。
使用git add -A或者git add --all来存储所有修改的文件，不管在哪个版本都是有效的。
取消存储的修改文件 $ git reset &amp;lt;filePath&amp;gt;  添加大片修改 你可以看到大片的选项是怎么被存储的，通过使用patch选项：
$ git add -p  或者
$ git add --patch  这个命令将会打开一个交互界面，允许你查看修改，并且决定哪些内容去被存储起来：
Stage this hunk [y,n,q,a,d,/,s,e,?]?   y stage this hunk for the next commit n do not stage this hunk for the next commit q quit; do not stage this hunk or any of the remaining hunks a stage this hunk and all later hunks in the file d do not stage this hunk or any of the later hunks in the file g select a hunk to go to / search for a hunk matching the given regex j leave this hunk undecided, see next undecided hunk J leave this hunk undecided, see next hunk k leave this hunk undecided, see previous undecided hunk K leave this hunk undecided, see previous hunk s split the current hunk into smaller hunks e manually edit the current hunk ?</description>
    </item>
    
    <item>
      <title>Git专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-3.html</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-3.html</guid>
      <description>操作远端 删除远端分支 想要删除一个远端的分支：
$ git push [remote-name] --delete [branch-name]  或者
$ git push [remote-name] :[branch-name]  修改远端地址 查看已经存在的远端地址：
$ git remote -v # origin https://github.com/username/repo.git (fetch) # origin https://github.com/usernam/repo.git (push)  修改仓库的地址：
$ git remote set-url origin https://github.com/username/repo2.git # Change the &#39;origin&#39; remote&#39;s URL  查看验证新的远端地址：
$ git remote -v # origin https://github.com/username/repo2.git (fetch) # origin https://github.com/username/repo2.git (push)  远端列表 查看这个仓库关联的远端列表：
$ git remote  查看这个仓库关联的远端列表，包括这些远端的fetch和push的Url地址。
$ git remote --verbose  或者</description>
    </item>
    
    <item>
      <title>Git专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-2.html</link>
      <pubDate>Fri, 18 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-2.html</guid>
      <description>查看历史    Parameter Explanation     -q, &amp;ndash;quiet Quiet, suppresses diff output   &amp;ndash;source Shows source of commit   &amp;ndash;use-mailmap Use mail map file (changes user info for committing user)   &amp;ndash;decorate[=&amp;hellip;] Decorate options   &amp;ndash;L &amp;lt; n,m:file&amp;gt; Show log for specific range of lines in a file, counting from 1. Starts from line n, goes to line m. Also shows diff.</description>
    </item>
    
    <item>
      <title>Git专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/01/post/git-section-1.html</link>
      <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/01/post/git-section-1.html</guid>
      <description>开始学习Git 创建自己的项目，并添加、提交文件 首页在终端验证你是否已经安装有Git：
在所有的操作系统上，都可以使用下面的命令：
$ git --version  在类Unix系统还可以使用下面的命令：
$ which git  如果什么都没有返回，或者没有通过验证，这就表明你需要通过下载并运行安装程序，在你的系统上安装Git。查看Git官网，上面有特别详细和容易的安装教程。
安装完Git之后，在你真正的提交之前，还需要配置好你的名称和邮件地址。
一旦安装成功Git，你就可以到你希望进行版本管理的文件夹下，初始化一个空的Git仓库：
$ git init  这会创建一个隐藏的.git文件夹，用来存放Git工作需要的信息。
接下来检查下Git将把什么文件加入到仓库内，这是非常值得注意的，也是在添加、提交文件之前的必要操作：
$ git status  检查文件的列表，你可以告诉Git哪些文件你想进行版本的管理（避免将像密码这样的重要信息或者污染仓库的信息添加到Git仓库里面）：
$ git add &amp;lt;file/directory name #1&amp;gt; &amp;lt;file/directory name #2&amp;gt; &amp;lt; ... &amp;gt;  如果所有的文件你都想和能访问这个仓库的人分享，有一个简单的命令可以添加当前目录和当前目录子目录内的所有文件：
$ git add .  这将“暂存”所有的文件，等待将这些文件加入版本管理，准备在你的第一次提交中提交它们。
对于你不想添加到版本管理的文件，你可以在执行add之前命令创建一个名.gitignore的文件，并且填写里面的内容。
提交所有已经添加的文件，同时填写一个提交的注释信息：
$ git commit -m &amp;quot;Initial commit&amp;quot;  这使用提供的信息创建了一个新的提交。一个提交就像你整个项目的一个快照。现在你就可以把本地的文件push到远端的仓库内，如果有需要的时候，你可以重新返回这里。
如果你忽略了-m参数，你默认的编辑器将会打开，你可以在编辑器里面编辑并且保存提交信息。
添加远端仓库 想要添加一个新的远端仓库地址，你可以在你仓库所在的文件夹内，在终端内执行git remote add命令。
1. 一个远端的名称，比如```origin``` 2. 一个远端的URL地址，比如```https://&amp;lt;your-git-service-address&amp;gt;/user/repo.git``` ```shell $ git remote add origin https://&amp;lt;your-git-service-address&amp;gt;/owner/repository.</description>
    </item>
    
  </channel>
</rss>