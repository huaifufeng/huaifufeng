<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/tags/mysql/</link>
    <description>Recent content in Mysql on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 04 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL专业笔记(二十)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/bash-section-20.html</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/bash-section-20.html</guid>
      <description>字符串运算符    名称 描述     ASCII() 返回最左侧字符的数值   BIN() 返回包含数字的二进制表示的字符串   BIT_LENGTH() 返回以位为单位的参数长度   CHAR() 返回整数参数对应的字符   CHAR_LENGTH() 返回参数中的字符数量   CONCAT() 返回拼接的字符串   CONCAT_WS() 返回指定分隔符拼接的字符串   ELT() 返回指定索引位置的字符串   EXPORT_SET() 返回一个字符串，使得对于值位中设置的每个位，您获得一个on字符串，并且对于每个未设置的位，您将获得一个off字符串   FIELD() 返回第一个参数在随后参数中的索引位置        参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十九)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/bash-section-19.html</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/bash-section-19.html</guid>
      <description>算术 算术运算符 MySQL提供了下面的算术运算符。
   运算符 名称 例子     + 加法 SELECT 3+5; -&amp;gt; 8 SELECT 3.5+5.5 -&amp;gt; 9.0 SELECT 3.5 + 2 -&amp;gt; 5.5   - 减法 SELECT 3 - 5; -&amp;gt; -2   * 乘法 SELECT 3 * 5; -&amp;gt; 15   / 除法 SELECT 20 / 4; -&amp;gt; 5 SELECT 355 / 133; -&amp;gt; 3.1416 SELECT 10.0 / 0; -&amp;gt; NULL   DIV 整除 SELECT 5 DIV 2; -&amp;gt; 2   % 或者 MOD 取余 SELECT 7 % 3; -&amp;gt; 1 SELECT 15 MOD 4; -&amp;gt; 3 SELECT 15 MOD -4; -&amp;gt; 3 SELECT -15 MOD 4; -&amp;gt; -3 SELECT -15 MOD -4; -&amp;gt; -3 SELECT 3 MOD 2.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十八)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/bash-section-18.html</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/bash-section-18.html</guid>
      <description>UNION 使用UNION组合SELECT语句 你可以使用UNION来组合两个结果相同的查询的结果。
例如，你想要两个独立表的所有联系信息，authors和editors，你可以使用UNION关键字：
SELECT name, email, phone_number FROM authors UNION SELECT name, email, phone_number FROM editors;  使用UNION将会自动过滤重复信息。如果你想要保留重复信息，你可以使用UNION ALL。
组合不同列的数据 SELECT name. caption as title, year, pages FROM books UNION SELECT name. title, year, 0 as pages FROM movies;  将两个不同列的记录集组合时，使用默认值模拟确实的列。
ORDER BY 如果你需要排序UNION之后的结果集，使用下面的语法：
( SELECT ... ) UNION ( SELECT ... ) ORDER BY  如果没有添加括号的话，ORDER BY语句将会添加到最后的SELECT语句上面。
OFFSET分页 当在UNION上添加LIMIT的时候，下面这个语法可以使用:
( SELECT ... ORDER BY x LIMIT 10 ) UNION ( SELECT .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十七)</title>
      <link>http://blog.huaifufeng.com/2019/05/post/bash-section-17.html</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/05/post/bash-section-17.html</guid>
      <description>JOIN表带有相同列 join 3个带有相同列的表 CREATE TABLE Table1 ( id INT UNSIGNED NOT NULL, created_on DATE NOT NULL, PRIMARY KEY (id) ) CREATE TABLE Table2 ( id INT UNSIGNED NOT NULL, personName VARCHAR(255) NOT NULL, PRIMARY KEY (id) ) CREATE TABLE Table3 ( id INT UNSIGNED NOT NULL, accountName VARCHAR(255) NOT NULL, PRIMARY KEY (id) )  在建表之后，你就可以使用一个查询语句从三个表中寻找具有相同名称的id：
SELECT t1.id AS table1Id, t2.id AS table2Id, t3.id AS table3Id FROM Table1 t1 LEFT JOIN Table2 t2 ON t2.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-16.html</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-16.html</guid>
      <description>JOIN JOIN可视化效果 如果您是一个面向视觉的人，这个venn图可以帮助您理解MySQL中存在的不同类型的连接。
与子查询join(&amp;ldquo;派生&amp;rdquo;表) SELECT x,... FROM ( SELECT y, ... FROM ...) AS a JOIN tbl ON tbl.x = a.y WHERE ...  这将会执行一个子查询放入一个临时表，然后join这个临时tbl。
在5.6之前，临时表上面不能有索引，因此这可能是非常低效：
SELECT ... FROM ( SELECT y, ... FROM ... ) AS a JOIN ( SELECT x, ... FROM ... ) AS b WHERE ...  在5.6，优化器可以计算出最好的索引然后在运行中创建它(这会有一些开销，所以仍然不是&amp;rdquo;完美的&amp;rdquo;)。
另外通用的方式是在子查询中创建一些东西：
SELECT @n := @n + 1, ... FROM ( SELECT @n:=0 ) AS initialize JOIn the_real_table ORDER BY .</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-15.html</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-15.html</guid>
      <description>ERROR 1055 最新版本的MySQL开始为之前的一些查询产生1055的错误。这个主题就是来介绍一下这样的错误。MySQL团队一直在努力让GROUP BY的扩展失效，或者至少让开发人员便于编写这样的查询。
无用GROUP BY返回不可预测的结果：墨菲定律 SELECT item.item_id, users.category, COUNT(*) number_of_uses FROM item JOIN uses ON item.item_id = uses.item_id GROUP item.item_id  将会显示 item表的行，并且显示表uses中关联的行数。也会显示uses.category中的值。
这个查询在(ONLY_FULL_GROUP_BY标识出现之前)MySQL中可以执行。这里使用了非标准的GROUP BY。
但是这有个问题：如果在JOIN语句的ON条件中匹配到了多个uses记录，那么MySQL将会从这些记录中返回一行的category字段值。哪一条？查询优化器，应用的用户都不能提前知道。准确的说：结果是不可预期的。MySQL将会返回任何想要返回的值。
*不可预期就是随机的*，有一个显著的区别。有人希望每次都有一个随机的选择。因此，如果一个选择的随机的，你可以在调试或测试中观察到这个情况。不可预期的结果是坏的：MySQL每次返回相同的结果，知道不相同了。有时候在新版本的MySQL中会有不同的结果。有时候这是导致问题的增长的表。什么会出问题，什么将会出问题，什么时候出问题你不知道。这叫做墨菲定律。
MySQL团队在努力让开发者更难犯这个错误。新版本的MySQL有一个叫做ONLY_GROUP_BY的sql_mod标签。当这个标识设置了，MySQL将会返回一个1055错误， 拒绝运行这个查询。
无用SELECT * ，如果修复 有时候有一个像下面这样的查询，在SELECT中使用*：
SELECT item.*, COUNT(*) number_of_uses FROM item JOIN uses ON item.item_id = uses.item_id GROUP BY item.item_id  当设置了ONLY_FULL_GROUP_BY，这样的查询就需要优化了。
要做优化的话，需要使用一个带有GROUP BY子句的子查询，让这个子查询返回每个item_id对应的number_of_uses字段。这个子查询很短也很简洁，因为它只需要查询uses表。
SELECT item_id, COUNT(*) number_of_uses FROM uses GROUP BY item_id;  然后我们和item表一起使用这个子查询：
SELECT item.*,usecount.number_of_uses FROM item JOIN ( SELECT item_id, COUNT(*) number_of_uses FROM uses GROUP BY item_id ) usecount ON item_item_id = usecount.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-14.html</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-14.html</guid>
      <description>GROUP BY    参数 详情     expression1, expression2,&amp;hellip;expression_n 没有包含在聚合函数中的表达式必须是GROUP BY中的表达式   aggregate_function 像SUM COUNT MIN MAX 或者 AVG这样的函数   tables 你希望获取数据的表。在FROM语句中至少包含一个表   WHERE condition 可选的。要选择的记录必须满足的条件。    HAVING SELECT department, COUNT(*) AS &amp;quot;Man_Power&amp;quot; FROM employees GROUP BY department HAVING COUNT(*) &amp;gt;= 10;  使用GROUP BY … HAVING来过滤聚合记录类似于使用SELECT … WHERE过滤单个记录。
你也可以使用HAVING Man_Power &amp;gt;= 10因为在HAVING已经能够理解这些别名。
GROUP_CONCAT GROUP_CONCAT用来拼接表达式的值，而不是每个列一个结果。这意味着选择的多列会把作为一列返回&amp;rdquo;Name(1):Score(*)&amp;ldquo;。
Name Score Adam A+ Adam A- Adam B Adam C+ Bill D- John A- SELECT Name, GROUP_CONCAT(Score ORDER BY Score DESC SEPERATOR &amp;quot; &amp;quot;) AS Grades FROM Grade GROUP BY Name  结果</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十三)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-13.html</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-13.html</guid>
      <description>ORDER BY 语境 下面的SELECT语句包含指定的顺序：
SELECT ... FROM ... WHERE ... GROUP by ... HAVING ... ORDER BY ... LIMIT ... OFFSET ...; (SELECT ... )UNION ( SELECT ... ) ORDER BY ... --排序union之后的结果 SELECT ... GROUP_CONCAT(DISTINCT x ORDER BY ... SEPARATOR ... ) ... ALTER TABLE ... ORDER BY ... -- 对MyISAM可能有用，对InnoDB无  基础用法 ORDER BY x
x可以是任何数据类型
 NULL比非NULL值优先 默认是ASC，升序 字符串(VARCHAR等)按照定义时的COLLATION来排序 ENUM按照定义时的顺序排序  升序/降序 ORDER BY x ASC -- 和默认行为一样 ORDER BY x DESC --降序 ORDER BY lastname,firstname --两列排序 ORDER BY submit_date DESC --最新的 ORDER BY submit_date DESC, id ASC -   ASC = Ascending DESC=Descending NULL首先出现，即使是降序 在上面的例子中，增加索引 INDEX(x) INDEX(lastname, firstname) INDEX(submit_date)可以提升性能  一些技巧 ORDER BY FIND_IN_SET(card_type, &amp;quot;MASTER-CARD, VISA, DISCOVER&amp;quot;) -- MASTER-CARD先 ORDER x IS NULL, x -- 按照x排序，NULL放最后  自定义排序</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十二)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-12.html</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-12.html</guid>
      <description>UPDATE JOIN语句更新 考虑有一个生存表叫做questions_mysql和一个表示批量导入CSV数据的最后一个记录iwtQuestions使用LOAD_DATA_INFILE。工作表在导入前被截断，数据被导入，并且这个过程在这里不显示。
更新生产表数据使用一个和导入数据表的join语句。
UPDATE questions_mysql q JOIN iwtQuestions i ON i.qId = q.qId SET q.closeVotes = i.closeVotes, q.votes = i.votes, q.answers = i.answers, q.views = i.views;  这里别名q和i是变量使用表名的简写。这简化开发和可读性。
主键qId代表题目id。这里join匹配的四个列会被更新。
基本更新 更新一行
UPDATE customers SET email=&#39;luke_smith@email.com&#39; WHERE id=1;  这个查询语句更新customers表中id为1的记录的email字段的内容，这里修改为luke_smith@email.com。数据表中老内容和新内容在下面显示了：
更新所有行
UPDATE customers SET lastname=&#39;smith&#39;;  这个查询更新customers表中所有记录的lastname字段为smith。下面是老内容和新内容的对比：
注意：在UPDATE语句中使用WHERE是很必要的。如果你没有使用条件语句的话，表中所有记录都会被更新。在上面例子中customers表中所有记录的lastname都更新为smith。
批量更新 使用不同的值更新多行时，可以使用批量更新：
UPDATE people SET name = (CASE id WHEN 1 THEN &#39;Karl&#39; WHEN 2 THEN &#39;Tom&#39; WHEN 3 THEN &#39;Mary&#39; END) WHERE id IN (1, 2, 3);  这里使用一条查询更新多条记录而不是每行使用一条查询。这个CASE语句需要包含WHERE语句中的所有制。</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十一)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-11.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-11.html</guid>
      <description>DELETE    参数 详情     LOW_PRIORITY 如果提供了LOW_PRIORITY，删除操作只有在没有其他进程从数据表上读取数据的时候才会执行   IGNORE 如果提供了IGNORE，任何删除时遇到的错误都将忽略   table 你想要删除记录的表   WHERE conditions 指定要删除数据的条件表达式。如果没有指定条件的话，所有的表记录都会被删除。   ORDER BY expression 如果提供了ORDER BY，将会按照顺序删除记录   LIMIT 控制删除的最大记录数量。提供的number_rows将会被删除。    多表删除 MySQL的DELETE语句可以用于JOIN语句，允许指定需要删除的表。这用来避免嵌套语句很有用。下面是一个表：
create table people ( id int primary key, name varchar(100) not null, gender char(1) not null ); insert into people(id, name, gender) values (1, &#39;Kathy&#39;, &#39;f&#39;),(2, &#39;John&#39;, &#39;m&#39;),(3,&#39;Paul&#39;,&#39;m&#39;),(4,&#39;Kim&#39;,&#39;f&#39;); create table pets ( id int auto_increment primary key, ownerId int not null, name varchar(100) not null, color varchar(100) not null ); insert into pets(ownerId, name, color) values (1, &#39;Rover&#39;, &#39;beige&#39;), (2, &#39;Bubbles&#39;, &#39;purple&#39;), (3, &#39;Spot&#39;, &#39;black and white&#39;), (1, &#39;Rover2&#39;, &#39;white&#39;); id name gender 1 Kathy f 2 John m 3 Paul m 4 Kim f id ownerId name color 1 1 Rover beige 2 2 Bubbles purple 3 3 black and white 4 1 Rover2 white  如果你想要删除Paul的宠物：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(十)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-10.html</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-10.html</guid>
      <description>INSERT ON DUPLICATE KEY UPDATE INSERT INTO `table_name` (`index_field`, `other_field_1`, `other_filed_2`) VALUES (`index_value`, `insert_value`, `other_value`) ON DUPLICATE KEY UPDATE `other_field_1` = &#39;update_value&#39;, `other_field_2` = VALUES(`other_field_2`);  这将会在table_name中插入指定的值，但是当唯一键存在的时候，将会更新other_field_1的值为一个新值。
有时候，但重复主键时使用VALUES()来获取原本的值，而不是更新为一个新值。这种方式下，你可以使用INSERT和UPDATE设置不同的值。在上面的例子中，other_field_1在INSERT的时候设置为insert_value或者在UPDATE的时候设置为update_value。但是other_field_2将一直设置为other_value。
对于插入重复Key更新(IODKU)工作的至关重要的一样就是表 包含唯一的键，这将会是造成重复的原因。这个唯一的键可以是主键，也可以不是。它可以是单列的唯一键，也可以是多了的组合键。
插入多个行 INSERT INTO `my_table` (`field_1`, `field_2`) VALUES (&#39;data_1&#39;, &#39;data_2&#39;), (&#39;data_1&#39;, &#39;data_3&#39;), (&#39;data_4&#39;, &#39;data_5&#39;);  这是一次性添加多条记录的INSERT语句。
这种匹配插入数据的操作比一条一条的插入数据快的多。特别是一次插入100条数据是单条数据插入的10倍。
忽略已存在的行
在插入大行数据集时，在某些情况下，最好跳过通常由于列限制(如重复主键)而导致插入失败的情况。这可以通过INSERT IGNORE来实现这个功能。
假设有下面这样的数据：
SELECT * FROM `people`; --- Produces: +----+------+ | id | name | +----+------+ | 1 | john | | 2 | anna | +----+------+ INSERT IGNORE INTO `people` (`id`, `name`) VALUES (&#39;2&#39;, &#39;anna&#39;), -- 没有IGNORE的话，这行将会产生错误 (&#39;3&#39;， &#39;mike&#39;); SELECT * FROM `people`; --- Produces: +----+--------+ | id | name | +----+--------+ | 1 | john | | 2 | anna | | 3 | mike | +----+--------+  最重要的事是记住INSERT IGNORE也会静静的跳过那些错误，下面是MySQL文档的说明：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(九)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-09.html</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-09.html</guid>
      <description>MySQL的注释 增加注释 有多种类型的注释：
# 注释到行尾 -- 注释到行尾 /* 注释符号内部 */ /* 多行注释 */  例子：
SELECT * FROM t1; --这是一个注释 CREATE TABLE stack ( /* username varchar(30), */ id int );  —符号要求在符号后面，注释前面有一个空格，否则将认为是一个命令，并且引发一个错误。
#注释正常 /*注释正常*/ --注释错误  表定义注释 CREATE TABLE menagerie.bird( bird_id INT NOT NULL AUTO_INCREMENT, species VARCHAR(300) DEFAULT NULL COMMENT &#39;字段注释&#39;, INDEX idx_species(species) COMMENT &#39;索引&#39;， PRIMARY KEY (bird_id) ) ENGINE=InnoDB COMMENT &amp;quot;表注释&amp;quot;;  在COMMENT后面添加一个=是可选的。查看手册。
这些注释不像其他的注释，保存在schema中，可以使用SHOW CREATE TABLE或从information_schema中获取。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(八)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-08.html</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-08.html</guid>
      <description>变量 设置变量 有一些方法来设置变量：
 可以使用SET将变量设置为特定的、字符串、数字和日期  SET @var_string = &amp;quot;my_var&amp;quot;; SET @var_num = &#39;2&#39;; SET @var_date = &#39;2015-07-20&#39;;   你可以使用下面的方法设置变量为select语句的结果：  Select @var := &#39;123&#39;; (注意：当你没有使用SET设置变量的时候，你需要使用:=，因为在其他的语句(select, update)中，&amp;quot;=&amp;quot;是用来比较的，所以当你在等号前面增加一个冒号的时候，这表明这不是一个比较语句，而是一个SET语句)   你可以使用INTO设置一个变量作为select语句的返回值  (当我需要动态选择要查询的分区时，这是特别有用的)
SET @start_date = &#39;2015-07-20&#39;; SET @end_date = &#39;2016-01-31&#39;; #这获取年月来确定使用的分区 SET @start_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @start_date)); SET @end_yearmonth = (SELECT EXTRACT(YEAR_MONTH FROM @end_date)); #把分区放入变量 SELECT GROUP_CONCAT(partition_name) FROME information_schema.partitions p WHERE table_name=&#39;partitioned_table&#39; AND SUBSTRING_INDEX(partition_name, &#39;P&#39;, -1) BETWEEN @start_yearmonth AND @end_yearmonth INTO @partitions; #把查询放入变量。因为MySQL不会把我们的变量任务是一个变量，所有我们需要拼接语句并执行这个语句 SET @query = CONCAT(&#39;CREATE TABLE part_of_partitioned_table(PRIMARY KEY(id)) SELECT partitioned_table.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(七)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-07.html</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-07.html</guid>
      <description>创建数据库    参数 详情     CREATE DATABASE 创建一个指定名称的数据库   CREATE SHEMA CREATE DATABASE 的别名   IF NOT EXISTS 如果指定的数据库存在的话，使用这个语句避免出现错误   create_specification create_specification指定的数据库的特征：像CHARACTER SET和COLLATE(数据库排序特征)    创建数据库，用户和授权 创建数据库。注意可以使用别名SCHEMA。
CREATE DATABASE Baseball; --创建名称为Baseball的数据库  如果数据库已经存在了，将会返回错误1007。想要避免这个错误，使用：
CREATE DATABASE IF NOT EXISTS Baseball;  相似的：
DROP DATABASE IF EXISTS Baseball; --当数据库存在时删除数据库 DROP DATABASE xyzl; --数据库如果不存在，返回1008错误  因为可以存在上面的错误，所以DDL语句通常和IF EXISTS一起使用。
用户创建数据库时，可以同时设置默认的字符集和排序规则，例如：
CREATE DATABASE Baseball CHARACTER SET utf8 COLLATE utf8_general_ci; SHOW CREATE TABLE Baseball; +----------+-------------------------------------------------------------------+ | Database | Create Database | +----------+-------------------------------------------------------------------+ | Baseball | CREATE DATABASE `Baseball` /*!</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(六)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-06.html</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-06.html</guid>
      <description>Limit和Offset Limit和Offset的关系 假设有下面这样的users表：
   id username     1 User1   2 User2   3 User3   4 User4   5 User5    为了限制SELECT查询中返回的结果集数量，可以使用LIMIT语句加上一个或两个整数作为参数(0也可以)。
LIMIT语句一个参数
当只提供了一个参数，这将只会限制返回的行数：
SELECT * FROM users ORDER BY id ASC LIMIT 2; id username 1 User1 2 User2  如果参数是0的话，将会返回0个值。
还需要注意，这里ORDER BY语句是很重要的，用来指定第一行的结果(当按照另一列排序时)。
LIMIT使用两个参数
当LIMIT语句使用两个参数时：
 第一个参数表示从结果集中显示的行-这个值通常是offset，因为这个值表示受约束结果集的开始之前的行。这个值允许是0，表示非约束结果集的第一行。 第二个参数表示结果集要显示的最大结果数量。  查看下面的查询：
SELECT * FROM users ORDER BY id ASC LIMIT 2,3; id username 3 User3 4 User4 5 User5  注意当第一个参数为0时，这个结果集等价于只传入了一个参数。这意味着下面两个语句由相同的结果：</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(五)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-05.html</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-05.html</guid>
      <description>NULL NULL的使用  不知道的数据：像end_date，rating 可选的数据：像middle_initial(尽管空字符是更加合适的) 0/0：某些运算的结果，像0除以0 NULL不等于空字符&amp;rdquo;&amp;ldquo;或者0 其他？  验证NULL  IS NULL或IS NOT NULL：= NULL将不会像你预期的一样 x &amp;lt;=&amp;gt; y是一种&amp;rdquo;null安全&amp;rdquo;的比较  在LEFT JOIN语句中检查a中的行在b中没有合适的行对应。
SELECT ... FROM a LEFT JOIN b ON ... WHERE b.id IS NULL:  参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(四)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-04.html</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-04.html</guid>
      <description>倒引号 倒引号用法 有很多例子在查询中使用倒引号，但是还是有很多人不清楚在什么时候或什么地方使用倒引号`。
倒引号主要用于防止一个调用&amp;rdquo;MySQL保留字&amp;rdquo;的错误。当你使用PHPmyAdmin创建一个表的时候，可能会遇到一个警告或提示：你正在使用MySQL的保留字。
例如，你创建一个包含字段&amp;rdquo;group&amp;rdquo;的表，你会遇到这个警告。这是因为你可能会使用下面的查询：
SELECT student_name, AVG(test_score) FROM student GROUP BY group;  为了确保你的查询不会出现错误，你可以在关键字上面增加倒引号：
SELECT student_name, AVG(test_score) FROM student GROUP BY `group`;  表
不仅仅列名需要添加倒引号，表名也需要添加倒引号。例如，当你需要JOIN多个表的时候：
SELECT `users`.`username`, `groups`.`group` FROM `users`;  易于阅读
正如你看到的，在表名或列表两边添加倒引号，也让查询更加容易阅读。
例如当你在书写全是小写时的查询时：
select student_name, AVG(test_score) from student group by group select `student_name`, AVG(`test_score`) from `student` group by `group`  查看MySQL关键字和保留字的手册。带有(R)标识的是保留字。其他的都是关键字。保留字需要特别小心。
参考：MySQL Notes for Professionals book</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(三)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-03.html</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-03.html</guid>
      <description>SELECT SELECT语句用来从一个或多个表中获取搜索到的行。
DISTINCT 在SELECT后面添加DISTINCT表示删除重复的行。
CREATE TABLE `car` ( `car_id` INT UNSIGNED NOT NULL PRIMARY KEY, `name` VARCHAR(20), `price` DECIMAL(8,2) ); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (1, &#39;Audi A1&#39;, &#39;20000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (2, &#39;Audi A1&#39;, &#39;15000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (3, &#39;Audi A2&#39;, &#39;40000&#39;); INSERT INTO CAR (`car_id`, `name`, `price`) VALUES (4, &#39;Audi A2&#39;, &#39;40000&#39;); SELECT DISTINCT `name`, `price` FROM CAR; ----------------- name | price Audi A1 | 20000.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(二)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-02.html</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-02.html</guid>
      <description>数据格式 CHAR(n) CHAR(n)是包含固定长度的n个字符的字符串。如果CHARACTER SET utf8mb4，这意味着它完全占用4个字节，不管里面包含什么文本。
大多数使用情况下CHAR(n)处理包含英文字符的字符串，因此应该设置ascii字符集(latin1也可以)。
country_code CHAR(2) CHARACTER SET ascii, postal_code CHAR(6) CHARACTER SET ascii, uuid CHAR(39) CHARACTER SET ascii, -- more discussion elsewhere  DATE DATETIME TIMESTAMP YEAR TIME DATE处理日期不包含时间部分。格式是&#39;YYYY-MM-DD&#39;，范围是1000-01-01到9999-12-31。
DATETIME是包含时间的日期格式&#39;YYYY-MM-DD HH:MM:SS&#39;。范围是1000-01-01 00:00:00到9999-12-31 23:59:59。
TIMESTAMP是整数类型的时间格式，包括日期和时间两部分。使用的范围是1970-01-01 00:00:01到2038-01-19 03:14:07 UTC (使用4个字节)
YEAR表示年份，范围从1901到2155(使用1个字节)
TIME表示一个&amp;rsquo;HH:MM:SS&amp;rsquo;格式的时间。范围从-838:59:59到838:59:59。
存储大小：
   数据类型 MySQL5.6.4之前 MySQL5.6.4及之后     YEAR 1字节 1字节   DATE 3字节 3字节   TIME 3字节 3字节+分数秒存储   DATETIME 8字节 5字节+分数秒存储   TIMESTAMP 4字节 4字节+分数秒存储    分数秒(5.</description>
    </item>
    
    <item>
      <title>MySQL专业笔记(一)</title>
      <link>http://blog.huaifufeng.com/2019/04/post/bash-section-01.html</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/bash-section-01.html</guid>
      <description>开始学习MySQL 版本历史
   1.0 1995-05-23     3.19 1996-12-01   3.20 1997-01-01   3.21 1998-10-01   3.22 1999-10-01   3.23 2001-01-22   4.0 2003-03-01   4.1 2004-10-01   5.0 2005-10-01   5.1 2008-11-27   5.5 2010-11-01   5.6 2013-02-01   5.7 2015-10-01    开始 创建MySQL数据库 CREATE DATABASE mydb;  返回：
 Query OK, 1 row affected (0.</description>
    </item>
    
  </channel>
</rss>