<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 怀府小阁</title>
    <link>http://blog.huaifufeng.com/tags/java/</link>
    <description>Recent content in Java on 怀府小阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 30 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.huaifufeng.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java专业笔记（六）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/java-section-6.html</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/java-section-6.html</guid>
      <description>Java代码文档化 Java代码的文档通常使用javadoc生成的。Javadoc是Sun公司创建的用来从Java源码中生成HTML格式的API文档的工具。使用HTML格式可以方便的吧相关的文档链接到一起。
1. 从命令行创建javadocs 许多IDE都支持工Javadocs自动生成HTML文档。一些构建工具（例如Maven和Gradle）也有可以处理HTML创建的插件。
但是这些工具不是必须要来生成javadoc HTML的。可以使用命令行工具javadoc。
这个工具的基本用法是：
javadoc JavaFile.java  这将会从JavaFile.java文件中的Javadoc注释中产生HTML文件。
命令行工具更好的用法是递归的读取[source-directory]中的所有java文件，创建[package.name]和所有子包的文档，并把这些文档存放到[docs-directory]中：
javadoc -d [docs-directory] -subpackages -sourcepath [source-directory] [package.name]  2. 类文档 所有的javadoc注释都以一个块注释开头，后面跟着一个星号(/**)，以一个快注释结尾(*/)。可选的，每一行可以以任意空格和一个星号开头，生成文档的时候会忽略这些空格和星号。
/** * 类的简单概述，以句号结束。 * * 通常在概述和详情之间会留一行空白。概述(在第一个句号之前的内容)会用在类或包的描述部分。 * * 可以使用下面的行内标记(不是完整的例子)： * {@link some.other.class.Documentation} 连接到其他的文档或符号 * {@link some.other.class.Documentation Some Display Name} 可以通过在文档或符号定位器之后添加 * 名称来定义连接的外观 * {@code code goes here} 用于格式化作为代码 * {@literal &amp;lt;&amp;gt;[]()foo} 用于在不转换为HTML标记或其他标记的情况下解释文本 * * 或者可以在类文档的末尾使用下面的标记(不是详细的列表)： * * @author 王子 * @version 1.0 * @since 5/10/15 * @see some.</description>
    </item>
    
    <item>
      <title>Java专业笔记（五）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/java-section-5.html</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/java-section-5.html</guid>
      <description>Java编译器 - javac 1. javac命令 简单例子
假设有一个HelloWorld.java的文件包含下面的java代码：
public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;quot;Hello World!&amp;quot;); } }  (对上面代码的解释，查看Java语言入门部分)
我们可以使用下面的命令编译上面的文件：
$ javac HelloWorld.java  这将会产生一个HelloWorld.class的文件，我们可以像下面这样运行这个文件：
$ java HelloWorld Hello World!  上面例子的关键点是：
 源码文件HelloWorld.java必须和源码文件中的类名相匹配，这里是HelloWorld。如果他们不匹配的话，你会遇到一个编译错误。 二进制文件HelloWorld.class和类的名称一样的。如果你重命名HelloWorld.class，当你运行的时候，将会遇到一个错误。 当使用java运行一个java程序的时候，你使用的是类名而不是二进制文件的名称。  包的例子
最佳实践的Java倒霉使用包来组织类的命名空间，并减少类名冲突的风险。
如果你想要在包com.example中声明HelloWorld类，需要在HelloWorld.java中包含下面的java源码：
package com.example; public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;quot;Hello World!&amp;quot;); } }  这个源码文件需要包含在和包名一致的目录树结构中：
. //当前目录 | -----com | -----example | -----HelloWorld.</description>
    </item>
    
    <item>
      <title>Java专业笔记（四）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/java-section-4.html</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/java-section-4.html</guid>
      <description>引用数据类型 1. 间接引用 .运算符就是间接引用。
Object obj = new Object(); String text = obj.toString(); //obj就是间接引用  间接引用遵循引用存储的内存地址，到内存中实际对象存储的位置。找到对象后，调用请求的方法（例子中是toString）。
当一个引用的值是null，间接引用江湖导致一个NullPointerException的异常：
Object obj = null; obj.toString(); //语句执行的时候，抛出一个NullPointerException的异常  null表示没有一个值，也就是说，跟在地址后面没有结果，所以没有可以调用对象的方法。
2. 实例化引用类型 Object obj = new Object(); //注意new  在例子中：
 Object是一个引用类型 obj是一个存储新引用值的变量 Object()是调用Object的构造方法  发生了什么：
 在内存中申请对象的空间 调用构造函数Object()初始化内存空间 内存地址存储在obj中，所以它引用新创建的对象  这个和基本类型是不同的：
int i = 0;  这里i中存储10的实际值。
参考：Java® Notes for Professionals book</description>
    </item>
    
    <item>
      <title>Java专业笔记（三）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/java-section-3.html</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/java-section-3.html</guid>
      <description>Getters和Setters 这个文章讨论getters和setters，Java类中提供的标准数据访问方法。
1. 使用一个setter或getter来实现约束 Setters和Getters运行一个对象有限制的访问和修改私有的变量。例如：
public class Person { private String name; public String getName() { return this.name; } public void setName(String name) { if (name != null &amp;amp;&amp;amp; name.length() &amp;gt; 2) { this.name = name; } } }  在这个Person类中，有一个单独的变量：name。这个变量可以通过getName()方法访问，使用setName(String)方法进行修改，然而，设置一个新的名字要求这个名字不为空并且长度大于2个字符。使用一个setter方法而不是把这个变量name变为public，这样就允许其他人进行有限制的修改。也可以在getter方法上面进行限制：
public String getName(){ if (name.length() &amp;gt; 16) { return &amp;quot;Name is too large!&amp;quot;; } else { return this.name; } }  在上面修改过的getName()方法中，只有在name的长度小于或等于16的时候才会返回。否则，将会返回&amp;quot;Name is too large!&amp;quot;。这允许编程人员创建允许访问和修改的变量，但是可以客户端类随便的修改这个变量。
2. 为什么使用Getters和Setters? 假设Java中有一个包含getters和setters的基础的类：</description>
    </item>
    
    <item>
      <title>Java专业笔记（二）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/java-section-2.html</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/java-section-2.html</guid>
      <description>类型转换 1. 数字元素转换 数字值可以有两种转换方式。
当原本的类型比目标类型小的时候，*隐式*转换就会发生。
//隐式转换 byte byteVar = 42; short shortVar = byteVar; int intVar = shortVar; long longVar = intVar; float floatVar = longVar; double doubleVar = floatVar;  当原本的类型比目标类型大的时候，*显示*转换就必须要使用了。
//显示转换 double doubleVar = 42.0d; float floatVar = (float) doubleVar; long longVar = (long)floatVar; int intVar = (int)longVar; short shortVar = (short)intVar; byte byteVar = (byte) shortVar;  当从浮点数元素（float, double）向整数值转换的时候，这个数字是向下取整的。
2. 基础数字提升 static void testNumericPromotion() { char char1 = 1, char2 = 2; short short1 = 1, short2 = 2; int int1 = 1, int2 = 2; float float1 = 1.</description>
    </item>
    
    <item>
      <title>Java专业笔记（一）</title>
      <link>http://blog.huaifufeng.com/2019/04/post/java-section-1.html</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://blog.huaifufeng.com/2019/04/post/java-section-1.html</guid>
      <description>开始学习java    Java SE 版本 代码名称 结束时间 发布日期     Java SE 10 None future 2018-03-20   Java SE 9 None future 2017-07-27   Java SE 8 Spider future 2014-03-18   Java SE 7 Dophin 2015-04-14 2011-07-28   Java SE 6 Mustang 2013-04-16 2006-12-23   Java SE 5 Tiger 2009-11-04 2004-10-04   Java SE 1.4 Merlin prior to 2009-11-04 2002-02-06   Java SE 1.</description>
    </item>
    
  </channel>
</rss>